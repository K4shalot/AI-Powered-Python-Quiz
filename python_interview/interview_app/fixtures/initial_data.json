[
{
  "model": "interview_app.category",
  "pk": 1,
  "fields": {
    "name": "Python Core"
  }
},
{
  "model": "interview_app.category",
  "pk": 2,
  "fields": {
    "name": "OOP"
  }
},
{
  "model": "interview_app.category",
  "pk": 3,
  "fields": {
    "name": "Data Structures & Algorithms"
  }
},
{
  "model": "interview_app.category",
  "pk": 4,
  "fields": {
    "name": "Web & Django"
  }
},
{
  "model": "interview_app.category",
  "pk": 5,
  "fields": {
    "name": "Databases"
  }
},
{
  "model": "interview_app.category",
  "pk": 6,
  "fields": {
    "name": "System Design & Architecture"
  }
},
{
  "model": "interview_app.category",
  "pk": 7,
  "fields": {
    "name": "Concurrency"
  }
},
{
  "model": "interview_app.category",
  "pk": 8,
  "fields": {
    "name": "Other"
  }
},
{
  "model": "interview_app.question",
  "pk": 1,
  "fields": {
    "question": "Чому Python? Які його переваги та ключові особливості?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 2,
  "fields": {
    "question": "Які основні типи даних існують у Python і як вони взаємодіють між собою? Наведіть приклади.",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 3,
  "fields": {
    "question": "Що ви розумієте під літералами в Python?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 4,
  "fields": {
    "question": "Чому Python є інтерпретованою мовою?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 5,
  "fields": {
    "question": "Що таке PEP 8?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 6,
  "fields": {
    "question": "Що таке простір імен у Python?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 7,
  "fields": {
    "question": "Що таке модулі в Python?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 8,
  "fields": {
    "question": "Що таке локальні та глобальні змінні в Python?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 9,
  "fields": {
    "question": "Що таке ключові слова в Python?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 10,
  "fields": {
    "question": "Як перевірити тип змінної?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 11,
  "fields": {
    "question": "Що таке ООП і які його основні принципи?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 12,
  "fields": {
    "question": "Що таке Абстракція (Abstraction)?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 13,
  "fields": {
    "question": "Що таке Інкапсуляція (Encapsulation)?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 14,
  "fields": {
    "question": "Що таке Наслідування (Inheritance)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 15,
  "fields": {
    "question": "Що таке Поліморфізм (Polymorphism)?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 16,
  "fields": {
    "question": "Яка різниця між класом і об'єктом?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 17,
  "fields": {
    "question": "Що таке self у Python?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 18,
  "fields": {
    "question": "Що таке __init__ метод?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 19,
  "fields": {
    "question": "Яка різниця між атрибутами класу і атрибутами об'єкта?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 20,
  "fields": {
    "question": "Що таке метод класу, статичний метод і звичайний метод?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 21,
  "fields": {
    "question": "Як реалізується поліморфізм у Python?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 22,
  "fields": {
    "question": "Що таке композиція та агрегація? Як вони відрізняються від наслідування?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 23,
  "fields": {
    "question": "Що таке магічні (dunder) методи? Назвіть кілька.",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 24,
  "fields": {
    "question": "Що таке mutable та immutable об'єкти? Наведіть приклади кожного типу.",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 25,
  "fields": {
    "question": "Чому рядки (str) у Python є immutable?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 26,
  "fields": {
    "question": "Поясніть різницю між списком (list) і кортежем (tuple) і дайте приклади використання.",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 3
  }
},
{
  "model": "interview_app.question",
  "pk": 27,
  "fields": {
    "question": "Що таке множина (set) у Python? Чим вона відрізняється від списку?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 3
  }
},
{
  "model": "interview_app.question",
  "pk": 28,
  "fields": {
    "question": "Як працює словник (dict) у Python? Які типи даних можна використовувати як ключі?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 3
  }
},
{
  "model": "interview_app.question",
  "pk": 29,
  "fields": {
    "question": "Що станеться, якщо використати mutable обʼєкт як ключ у словнику?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 3
  }
},
{
  "model": "interview_app.question",
  "pk": 30,
  "fields": {
    "question": "У чому різниця між циклами for і while? Наведіть приклади їх використання.",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 31,
  "fields": {
    "question": "Як перервати цикл до його завершення? Наведіть приклад із використанням оператора break.",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 32,
  "fields": {
    "question": "Як пропустити одну ітерацію в циклі? Наведіть приклад із використанням оператора continue.",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 33,
  "fields": {
    "question": "Як зупинити нескінченний цикл, якщо умова виходу не виконується?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 34,
  "fields": {
    "question": "Чи можна використовувати else разом із циклом for або while? Що це означає?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 35,
  "fields": {
    "question": "Що таке list comprehensions? У чому їх переваги порівняно зі звичайними циклами?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 36,
  "fields": {
    "question": "Чи можна використовувати вкладені list comprehensions? Наведіть приклад.",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 37,
  "fields": {
    "question": "Що таке генератори в Python? Як їх створювати?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 38,
  "fields": {
    "question": "Чим генератори відрізняються від list comprehensions? Наведіть приклад їх застосування.",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 39,
  "fields": {
    "question": "Що таке функції в Python?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 40,
  "fields": {
    "question": "Що таке __init__ у Python?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 41,
  "fields": {
    "question": "Як реалізувати кілька конструкторів у класі Python?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 42,
  "fields": {
    "question": "Як уникнути змін mutable об'єктів, переданих у функцію?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 43,
  "fields": {
    "question": "Чим небезпечне використання mutable об'єктів як значення за замовчуванням у функціях?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 44,
  "fields": {
    "question": "Що таке декоратори у Python?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 45,
  "fields": {
    "question": "Поясніть, що таке Bytecode у Python і як він створюється.",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 46,
  "fields": {
    "question": "Що відбувається під час виконання Python-коду, починаючи від запуску .py файлу?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 47,
  "fields": {
    "question": "Переваги Django?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 48,
  "fields": {
    "question": "Недоліки Django?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 49,
  "fields": {
    "question": "Основні компоненти стандартного проекту Django?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 50,
  "fields": {
    "question": "Що таке Django ORM?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 51,
  "fields": {
    "question": "Моделі (Models) у Django?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 4
  }
},
{
  "model": "interview_app.question",
  "pk": 52,
  "fields": {
    "question": "В чому різниця між copy() та deepcopy()?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 53,
  "fields": {
    "question": "Що таке незмінні типи (immutable) у Python?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 54,
  "fields": {
    "question": "Що таке змінні типи (mutable) у Python?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 55,
  "fields": {
    "question": "Що таке heap у Python?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 3
  }
},
{
  "model": "interview_app.question",
  "pk": 56,
  "fields": {
    "question": "Що таке Namespace у Python?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 57,
  "fields": {
    "question": "Що таке контейнер (Container object) у Python?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 58,
  "fields": {
    "question": "Який паттерн реалізовують None, False, True в Python?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 59,
  "fields": {
    "question": "Що таке перетворення типів у Python?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 60,
  "fields": {
    "question": "Що таке Boolean у Python?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 61,
  "fields": {
    "question": "Для чого використовується модуль decimal у Python?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 62,
  "fields": {
    "question": "Яка різниця між операторами ==, is та функцією isinstance()?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 63,
  "fields": {
    "question": "Що таке анотації типів (Type Hints) та PEP 484?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 64,
  "fields": {
    "question": "Що таке mypy?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 65,
  "fields": {
    "question": "Для чого використовується ParamSpec у Python?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 66,
  "fields": {
    "question": "Що таке Generic у Python?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 67,
  "fields": {
    "question": "Для чого використовується TypeVar у Python?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 68,
  "fields": {
    "question": "Для чого використовуються файли з розширенням .pyi?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 69,
  "fields": {
    "question": "Що таке послідовності (Sequences) у Python?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 3
  }
},
{
  "model": "interview_app.question",
  "pk": 70,
  "fields": {
    "question": "Які операції підтримують більшість послідовностей?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 3
  }
},
{
  "model": "interview_app.question",
  "pk": 71,
  "fields": {
    "question": "Що таке зрізи (slices) у Python?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 72,
  "fields": {
    "question": "Синтаксис зрізів?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 73,
  "fields": {
    "question": "Чи можна змінити окремий символ всередині рядка?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 74,
  "fields": {
    "question": "Як кодувати рядки?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 75,
  "fields": {
    "question": "Як декодувати рядки?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 76,
  "fields": {
    "question": "Які є види форматування рядка?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 77,
  "fields": {
    "question": "Що таке інтернування рядків?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 78,
  "fields": {
    "question": "В чому різниця між списком і кортежем?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 3
  }
},
{
  "model": "interview_app.question",
  "pk": 79,
  "fields": {
    "question": "В чому різниця між масивами (Arrays) та списками (Lists) у Python?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 3
  }
},
{
  "model": "interview_app.question",
  "pk": 80,
  "fields": {
    "question": "Як зробити список унікальним (без повторюваних елементів)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 3
  }
},
{
  "model": "interview_app.question",
  "pk": 81,
  "fields": {
    "question": "Що таке range у Python?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 82,
  "fields": {
    "question": "Як порівнюються послідовності у Python?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 3
  }
},
{
  "model": "interview_app.question",
  "pk": 83,
  "fields": {
    "question": "any та all",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 84,
  "fields": {
    "question": "Що повертає функція enumerate?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 85,
  "fields": {
    "question": "Як визначити, чи є об'єкт хешованим",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 86,
  "fields": {
    "question": "Що таке множина (set)?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": "Trainee",
    "category": 3
  }
},
{
  "model": "interview_app.question",
  "pk": 87,
  "fields": {
    "question": "Що таке словник (dict)?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 3
  }
},
{
  "model": "interview_app.question",
  "pk": 88,
  "fields": {
    "question": "Які нюанси при використанні чисел як ключів?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 89,
  "fields": {
    "question": "Що таке ООП і які його основні принципи?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 90,
  "fields": {
    "question": "Що таке абстракція (Abstraction)?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 91,
  "fields": {
    "question": "Що таке інкапсуляція (Encapsulation)?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 92,
  "fields": {
    "question": "Що таке наслідування (Inheritance)?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 93,
  "fields": {
    "question": "Що таке поліморфізм (Polymorphism)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 94,
  "fields": {
    "question": "Яка різниця між класом і обʼєктом?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 95,
  "fields": {
    "question": "Що таке self у Python?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 96,
  "fields": {
    "question": "Що таке метод __init__?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 97,
  "fields": {
    "question": "Що таке метод __new__ і чим він відрізняється від __init__? В якій послідовності вони виконуються?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 98,
  "fields": {
    "question": "Що таке self у Python?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 99,
  "fields": {
    "question": "Як отримати список атрибутів обʼєкта?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 100,
  "fields": {
    "question": "Що таке магічні методи (dunder methods) і для чого вони потрібні?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 101,
  "fields": {
    "question": "Яка різниця між __str__ та __repr__?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 102,
  "fields": {
    "question": "Чим відрізняються __getattr__ та __getattribute__?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 103,
  "fields": {
    "question": "Що таке __qualname__?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 104,
  "fields": {
    "question": "Як у класі посилатися на батьківський клас?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 105,
  "fields": {
    "question": "Чи можливе множинне наслідування у Python?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 106,
  "fields": {
    "question": "Що таке MRO (Method Resolution Order)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 107,
  "fields": {
    "question": "Що таке проблема ромба (Diamond problem)?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 108,
  "fields": {
    "question": "Що таке міксіни (mixins)?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 109,
  "fields": {
    "question": "Що таке абстрактні класи та методи?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 110,
  "fields": {
    "question": "Чому дорівнює вираз object() == object()?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 111,
  "fields": {
    "question": "Що таке __slots__?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 112,
  "fields": {
    "question": "Що означають атрибути з _value та __value?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 113,
  "fields": {
    "question": "Що таке качина типізація (duck typing)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 114,
  "fields": {
    "question": "Що таке перевантаження операторів (operator overloading)?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 115,
  "fields": {
    "question": "Як створити клас за допомогою type()?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 116,
  "fields": {
    "question": "У чому різниця між @staticmethod та @classmethod?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 117,
  "fields": {
    "question": "Для чого потрібен метод __subclasshook__?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 118,
  "fields": {
    "question": "Що таке властивість (@property)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 119,
  "fields": {
    "question": "Що таке дескриптор?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 120,
  "fields": {
    "question": "Коли слід використовувати дескриптори?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 121,
  "fields": {
    "question": "Які є види дескрипторів?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 122,
  "fields": {
    "question": "Які є методи у дескрипторів?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 123,
  "fields": {
    "question": "Які проблеми можуть виникнути з дескрипторами?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 124,
  "fields": {
    "question": "Що таке метакласи?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 125,
  "fields": {
    "question": "Що таке type і як працює пошук метакласу?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 126,
  "fields": {
    "question": "Навіщо використовувати метакласи?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 127,
  "fields": {
    "question": "Що таке контекстний менеджер?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 128,
  "fields": {
    "question": "Що таке простори імен в Python та правило LEGB?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 129,
  "fields": {
    "question": "Що таке локальні та глобальні змінні? global, nonlocal?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 130,
  "fields": {
    "question": "Що таке модуль?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 131,
  "fields": {
    "question": "Як отримати ім'я модуля?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 132,
  "fields": {
    "question": "Як Python знаходить модулі при імпорті?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 133,
  "fields": {
    "question": "Що таке пакет?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 134,
  "fields": {
    "question": "Що таке import?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 135,
  "fields": {
    "question": "У чому різниця між from package import item та import package.item?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 136,
  "fields": {
    "question": "Що таке виняток (Exception)?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": "Junior",
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 137,
  "fields": {
    "question": "Як обробити виняток?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 138,
  "fields": {
    "question": "Що станеться, якщо помилку не обробити?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 139,
  "fields": {
    "question": "Як перехопити виняток, виконати дії і знову його викликати?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 140,
  "fields": {
    "question": "Для чого може використовуватися конструкція try...finally без except?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 141,
  "fields": {
    "question": "Що таке ланцюжок винятків?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 142,
  "fields": {
    "question": "Для чого потрібен блок else в try...except?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 143,
  "fields": {
    "question": "Що робить contextlib.suppress?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 144,
  "fields": {
    "question": "Що можна передати у конструктор винятку?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 145,
  "fields": {
    "question": "Які є основні класи винятків?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 146,
  "fields": {
    "question": "В яких випадках можна обробити SyntaxError?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 147,
  "fields": {
    "question": "Чи можна створювати власні винятки?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 148,
  "fields": {
    "question": "Для чого потрібні попередження (warnings) і як створити власне?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 149,
  "fields": {
    "question": "Для чого потрібний модуль warnings?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 150,
  "fields": {
    "question": "Що таке файловий об'єкт?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": "Junior",
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 151,
  "fields": {
    "question": "Які існують типи файлових об'єктів?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 152,
  "fields": {
    "question": "В чому відмінність текстових і бінарних файлів?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 153,
  "fields": {
    "question": "Як користуватися функцією open()?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 154,
  "fields": {
    "question": "З чого складається процес закриття файлів?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 155,
  "fields": {
    "question": "Що роблять методи tell() і seek()?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 156,
  "fields": {
    "question": "Що роблять StringIO і BytesIO?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 157,
  "fields": {
    "question": "Чи є файлові об'єкти контекстними менеджерами?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 158,
  "fields": {
    "question": "Що таке серіалізація?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 159,
  "fields": {
    "question": "У чому різниця між json.dumps/dump та json.loads/load?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 160,
  "fields": {
    "question": "Що робити, якщо потрібно серіалізувати дані, які не підтримуються стандартним модулем json?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 161,
  "fields": {
    "question": "Для чого потрібні функції з модуля pickle?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 162,
  "fields": {
    "question": "Що таке асинхронність?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 163,
  "fields": {
    "question": "Що таке корутини (співпрограми)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 164,
  "fields": {
    "question": "Як реалізована асинхронність в Python?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 165,
  "fields": {
    "question": "Що таке asyncio?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": "Junior",
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 166,
  "fields": {
    "question": "Що таке async/await, навіщо вони потрібні і як їх використовувати?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 167,
  "fields": {
    "question": "Що таке event loop (цикл подій) в asyncio і як він працює?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 168,
  "fields": {
    "question": "Що таке мультиплексування вводу/виводу?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 169,
  "fields": {
    "question": "Чому асинхронний код з await може виконуватись синхронно?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 170,
  "fields": {
    "question": "Як запустити код конкурентно в asyncio?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 171,
  "fields": {
    "question": "Для чого використовується asyncio.create_task()?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 172,
  "fields": {
    "question": "Для чого використовується asyncio.TaskGroup?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 173,
  "fields": {
    "question": "Для чого використовується gather()?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 174,
  "fields": {
    "question": "Для чого використовуються wait_for(), as_completed(), wait()?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 175,
  "fields": {
    "question": "Для чого використовується asyncio.to_thread?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 176,
  "fields": {
    "question": "Що таке aiohttp?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 177,
  "fields": {
    "question": "Які типові помилки при роботі з asyncio?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 178,
  "fields": {
    "question": "Скільки потоків та процесів працює під час асинхронного виконання коду?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 179,
  "fields": {
    "question": "Що таке потік (Thread) та процес (Process)?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 180,
  "fields": {
    "question": "В чому відмінність потоків від процесів?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 181,
  "fields": {
    "question": "Які недоліки потоків?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 182,
  "fields": {
    "question": "Які існують способи синхронізації процесів та потоків?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 183,
  "fields": {
    "question": "Як використовуються черги (Queues) для синхронізації та передачі даних?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 184,
  "fields": {
    "question": "Як використовуються бар'єри (Barriers) для синхронізації?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 185,
  "fields": {
    "question": "Як передавати інформацію між процесами?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 186,
  "fields": {
    "question": "Що таке гонка (race condition)? Як з нею боротися?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": "Junior",
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 187,
  "fields": {
    "question": "Що таке GIL? Які проблеми в нього є?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 188,
  "fields": {
    "question": "Як GIL пов'язаний зі збирачем сміття (GC)?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 189,
  "fields": {
    "question": "Як реалізовано багатопотоковість у Python?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 190,
  "fields": {
    "question": "Який життєвий цикл потоку (thread) в Python?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 191,
  "fields": {
    "question": "Для чого використовують ThreadPool? Як виділяються та повертаються потоки в ThreadPool?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 192,
  "fields": {
    "question": "Як працює thread.local?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 193,
  "fields": {
    "question": "Які завдання добре паралеляться, а які погано?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 194,
  "fields": {
    "question": "Потрібно обчислити 100 рівнянь. Робити це у потоках або ні?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 195,
  "fields": {
    "question": "Що таке грінлети (зелені потоки)?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 196,
  "fields": {
    "question": "Що таке сигнали в Python і як вони пов'язані з плануванням потоків?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 197,
  "fields": {
    "question": "Що таке системний виклик fork()?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 198,
  "fields": {
    "question": "Для яких завдань варто використовувати потоки, для яких — процеси, а для яких — асинхронність?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 199,
  "fields": {
    "question": "Що таке інтерпретатор і як він працює в Python?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 200,
  "fields": {
    "question": "Які є види інтерпретаторів Python?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 201,
  "fields": {
    "question": "Що таке Cython?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 202,
  "fields": {
    "question": "Які механізми використовує Python для очищення пам'яті?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 203,
  "fields": {
    "question": "Що таке збирач сміття (garbage collector)?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 204,
  "fields": {
    "question": "Як працює підрахунок посилань (Reference Counting)?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 205,
  "fields": {
    "question": "Які існують способи синхронізації процесів та потоків? Як передавати інформацію з одного процесу до іншого?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 206,
  "fields": {
    "question": "Що таке гонка (race condition)? Як з нею боротися?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 207,
  "fields": {
    "question": "Що таке GIL? Які проблеми в нього є?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 208,
  "fields": {
    "question": "Як реалізовано багатопотоковість у Python?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 209,
  "fields": {
    "question": "Для чого використовують ThreadPool? Як працює пул потоків?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 210,
  "fields": {
    "question": "Що таке thread.local?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 211,
  "fields": {
    "question": "Які завдання добре паралеляться, а які погано у Python?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 212,
  "fields": {
    "question": "Що таке блокуючі операції?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 213,
  "fields": {
    "question": "Чи варто обчислювати 100 рівнянь у потоках?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 214,
  "fields": {
    "question": "Що таке грінлети? Наведи приклади.",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 215,
  "fields": {
    "question": "Що таке Django?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 216,
  "fields": {
    "question": "Що таке Flask?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 217,
  "fields": {
    "question": "Що таке FastAPI?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 218,
  "fields": {
    "question": "Що таке pytest?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 219,
  "fields": {
    "question": "Що таке SQLAlchemy ORM?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 5
  }
},
{
  "model": "interview_app.question",
  "pk": 220,
  "fields": {
    "question": "Що таке Celery?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 7
  }
},
{
  "model": "interview_app.question",
  "pk": 221,
  "fields": {
    "question": "Як працює логічний оператор and?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 222,
  "fields": {
    "question": "Що таке FizzBuzz?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 223,
  "fields": {
    "question": "Як перевірити, чи є рядок паліндромом у Python?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 3
  }
},
{
  "model": "interview_app.question",
  "pk": 224,
  "fields": {
    "question": "Що таке SOLID у програмуванні?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 225,
  "fields": {
    "question": "Що таке патерн 'API Gateway' і яку проблему він вирішує в мікросервісній архітектурі?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 6
  }
},
{
  "model": "interview_app.question",
  "pk": 226,
  "fields": {
    "question": "Поясніть теорему CAP. Які дві з трьох властивостей зазвичай обирають сучасні розподілені системи?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 6
  }
},
{
  "model": "interview_app.question",
  "pk": 227,
  "fields": {
    "question": "Чим принципово відрізняється `git rebase` від `git merge`?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 228,
  "fields": {
    "question": "Для чого використовується команда `git cherry-pick`?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 229,
  "fields": {
    "question": "Що таке мульти-етапні збірки (multi-stage builds) в Docker і яку перевагу вони дають?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 6
  }
},
{
  "model": "interview_app.question",
  "pk": 230,
  "fields": {
    "question": "У чому різниця між `docker volume` та `bind mount`?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 6
  }
},
{
  "model": "interview_app.question",
  "pk": 231,
  "fields": {
    "question": "Що таке 'N+1' проблема запитів в ORM і як її вирішити в Django?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 4
  }
},
{
  "model": "interview_app.question",
  "pk": 232,
  "fields": {
    "question": "Поясніть рівні ізоляції транзакцій в базах даних (ACID).",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 5
  }
},
{
  "model": "interview_app.question",
  "pk": 233,
  "fields": {
    "question": "Що таке індекси в базах даних і як працює B-Tree індекс?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 5
  }
},
{
  "model": "interview_app.question",
  "pk": 234,
  "fields": {
    "question": "Як працює механізм Dependency Injection в FastAPI?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 4
  }
},
{
  "model": "interview_app.question",
  "pk": 235,
  "fields": {
    "question": "Що таке Pydantic і чому він є ключовим компонентом FastAPI?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 4
  }
},
{
  "model": "interview_app.question",
  "pk": 236,
  "fields": {
    "question": "Для чого в Django використовуються Signals (сигнали)? Наведіть приклад.",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 4
  }
},
{
  "model": "interview_app.question",
  "pk": 237,
  "fields": {
    "question": "Поясніть різницю між `Serializer`, `ModelSerializer` та `HyperlinkedModelSerializer` у Django Rest Framework.",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 4
  }
},
{
  "model": "interview_app.question",
  "pk": 238,
  "fields": {
    "question": "Що таке JWT (JSON Web Token)? З яких частин він складається?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 4
  }
},
{
  "model": "interview_app.question",
  "pk": 239,
  "fields": {
    "question": "Що таке 'CORS' (Cross-Origin Resource Sharing) і чому це важливо для веб-API?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 4
  }
},
{
  "model": "interview_app.question",
  "pk": 240,
  "fields": {
    "question": "Що таке 'mocking' та 'patching' у тестуванні? Яку бібліотеку для цього зазвичай використовують у Python?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 241,
  "fields": {
    "question": "Поясніть призначення та скоупи (scopes) фікстур у `pytest`.",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 242,
  "fields": {
    "question": "Що таке патерн 'Circuit Breaker' (автоматичний вимикач)?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 6
  }
},
{
  "model": "interview_app.question",
  "pk": 243,
  "fields": {
    "question": "Що таке ідемпотентність в контексті REST API?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 4
  }
},
{
  "model": "interview_app.question",
  "pk": 244,
  "fields": {
    "question": "Що таке gRPC і чим він відрізняється від REST?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 6
  }
},
{
  "model": "interview_app.question",
  "pk": 245,
  "fields": {
    "question": "Як працює Middleware у Django? Чому важливий порядок їх визначення у `settings.py`?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 4
  }
},
{
  "model": "interview_app.question",
  "pk": 246,
  "fields": {
    "question": "Для чого використовується `git reflog`?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 247,
  "fields": {
    "question": "Що таке Helm і для чого він використовується в екосистемі Kubernetes?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 6
  }
},
{
  "model": "interview_app.question",
  "pk": 248,
  "fields": {
    "question": "Поясніть різницю між 'Blue-Green Deployment' та 'Canary Deployment'.",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 6
  }
},
{
  "model": "interview_app.question",
  "pk": 249,
  "fields": {
    "question": "Що таке `select_for_update()` в Django ORM і коли його слід використовувати?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": "Strong Junior",
    "category": 4
  }
},
{
  "model": "interview_app.question",
  "pk": 250,
  "fields": {
    "question": "Що таке Django Channels і яку проблему він вирішує?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 4
  }
},
{
  "model": "interview_app.question",
  "pk": 251,
  "fields": {
    "question": "Як працює 'background tasks' у FastAPI?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 7
  }
},
{
  "model": "interview_app.question",
  "pk": 252,
  "fields": {
    "question": "Чому сортування паролів є поганою практикою і що слід використовувати замість цього?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 3
  }
},
{
  "model": "interview_app.question",
  "pk": 253,
  "fields": {
    "question": "Що таке 'Connection Pooling' в контексті баз даних?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 5
  }
},
{
  "model": "interview_app.question",
  "pk": 254,
  "fields": {
    "question": "Що таке 'Infrastructure as Code' (IaC)? Наведіть приклади інструментів.",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 6
  }
},
{
  "model": "interview_app.question",
  "pk": 255,
  "fields": {
    "question": "Поясніть призначення файлу `.pyi` (stub file).",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 256,
  "fields": {
    "question": "У чому різниця між реляційними (SQL) та нереляційними (NoSQL) базами даних?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 5
  }
},
{
  "model": "interview_app.question",
  "pk": 257,
  "fields": {
    "question": "Що таке кешування 'write-through' та 'cache-aside' (read-aside)?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 5
  }
},
{
  "model": "interview_app.question",
  "pk": 258,
  "fields": {
    "question": "Що таке 'Sharding' бази даних?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 5
  }
},
{
  "model": "interview_app.question",
  "pk": 259,
  "fields": {
    "question": "Для чого використовується `__slots__` в класах Python і який у нього є недолік?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 260,
  "fields": {
    "question": "Що таке 'TDD' (Test-Driven Development)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 261,
  "fields": {
    "question": "Поясніть, що таке CSRF (Cross-Site Request Forgery) атака і як Django захищає від неї.",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 4
  }
},
{
  "model": "interview_app.question",
  "pk": 262,
  "fields": {
    "question": "Що таке 'message queue' (черга повідомлень), як-от RabbitMQ або Kafka, і для чого їх використовують?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 6
  }
},
{
  "model": "interview_app.question",
  "pk": 263,
  "fields": {
    "question": "Що таке 'Stateful' та 'Stateless' архітектури?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 6
  }
},
{
  "model": "interview_app.question",
  "pk": 264,
  "fields": {
    "question": "У чому різниця між `ProcessPoolExecutor` та `ThreadPoolExecutor` з модуля `concurrent.futures`?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 7
  }
},
{
  "model": "interview_app.question",
  "pk": 265,
  "fields": {
    "question": "Що таке патерн 'Saga' і яку проблему він вирішує в мікросервісній архітектурі?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 6
  }
},
{
  "model": "interview_app.question",
  "pk": 266,
  "fields": {
    "question": "Поясніть патерн CQRS (Command Query Responsibility Segregation).",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 6
  }
},
{
  "model": "interview_app.question",
  "pk": 267,
  "fields": {
    "question": "Що таке 'Idempotent Consumer' в системах обміну повідомленнями?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 6
  }
},
{
  "model": "interview_app.question",
  "pk": 268,
  "fields": {
    "question": "Для чого в Git використовується команда `git bisect`?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 269,
  "fields": {
    "question": "Що таке `git worktree` і в яких випадках це корисно?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 270,
  "fields": {
    "question": "Що таке 'StatefulSet' в Kubernetes і чим він відрізняється від 'Deployment'?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 271,
  "fields": {
    "question": "Що таке 'Ingress' в Kubernetes?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 272,
  "fields": {
    "question": "Поясніть призначення віконних функцій (Window Functions) в SQL. Наведіть приклад.",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 273,
  "fields": {
    "question": "Що таке 'Common Table Expressions' (CTE) в SQL і яку перевагу вони дають?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 274,
  "fields": {
    "question": "Для чого в Redis використовується структура даних 'Sorted Set'?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 275,
  "fields": {
    "question": "Що таке 'weak reference' в Python і для чого може знадобитися модуль `weakref`?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 276,
  "fields": {
    "question": "Як працює `functools.lru_cache`? Поясніть механізм 'Least Recently Used'.",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 277,
  "fields": {
    "question": "У чому полягає різниця між 'concurrency' (конкурентність) та 'parallelism' (паралелізм)?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 278,
  "fields": {
    "question": "Що таке 'deadlock' в базах даних і як його уникнути?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 279,
  "fields": {
    "question": "Що таке 'property-based testing' і чим воно відрізняється від 'example-based testing'?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 280,
  "fields": {
    "question": "Для чого в Django використовуються кастомні менеджери моделей (custom model managers)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 281,
  "fields": {
    "question": "Що таке 'Throttling' в Django Rest Framework?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 282,
  "fields": {
    "question": "Що таке 'lifespan' події у FastAPI і як вони використовуються?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 283,
  "fields": {
    "question": "Поясніть OAuth 2.0 потік 'Authorization Code Grant'.",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 284,
  "fields": {
    "question": "Що таке 'secrets management' і чому не можна зберігати секрети в Git?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 285,
  "fields": {
    "question": "Що таке 'structured logging' і які переваги воно дає?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 286,
  "fields": {
    "question": "Для чого потрібен `asyncio.Semaphore`?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 287,
  "fields": {
    "question": "Що таке `contextvars` в Python і чим вони відрізняються від `thread.local`?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 288,
  "fields": {
    "question": "Що таке 'mutation testing'?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 289,
  "fields": {
    "question": "Які стратегії API версіонування ви знаєте?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 290,
  "fields": {
    "question": "Поясніть, що таке 'Consistent Hashing'.",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 291,
  "fields": {
    "question": "Що таке 'Bloom Filter' і для чого він використовується?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 292,
  "fields": {
    "question": "Як працює механізм 'subtests' в `unittest`?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 293,
  "fields": {
    "question": "У чому різниця між Celery 'chain', 'chord' та 'group'?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 294,
  "fields": {
    "question": "Що таке 'Service Discovery' в мікросервісній архітектурі?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 295,
  "fields": {
    "question": "Що таке 'Observability' і з яких трьох стовпів воно складається?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 296,
  "fields": {
    "question": "Для чого використовується `EXPLAIN ANALYZE` в PostgreSQL?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 297,
  "fields": {
    "question": "Що таке 'server-side cursors' в `psycopg2` і коли їх варто використовувати?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 298,
  "fields": {
    "question": "Як реалізувати кастомну аутентифікацію в Django Rest Framework?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 299,
  "fields": {
    "question": "Що таке 'Twelve-Factor App' методологія?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 300,
  "fields": {
    "question": "Яка різниця між Cython та CFFI?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 301,
  "fields": {
    "question": "Що таке 'distributed tracing' і як воно допомагає в мікросервісній архітектурі?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 302,
  "fields": {
    "question": "Яка роль 'broker' та 'backend' в архітектурі Celery?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 303,
  "fields": {
    "question": "Чим принципово відрізняється Prometheus від традиційних систем моніторингу?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 304,
  "fields": {
    "question": "Що таке 'Trie' (префіксне дерево) і де воно застосовується?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 305,
  "fields": {
    "question": "Поясніть Liskov Substitution Principle (LSP) з SOLID. До яких проблем призводить його порушення?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 306,
  "fields": {
    "question": "Що таке Dependency Inversion Principle (DIP) і як він пов'язаний з Dependency Injection?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 307,
  "fields": {
    "question": "Що таке патерн 'Value Object' в Domain-Driven Design (DDD)?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 308,
  "fields": {
    "question": "Що таке GraphQL і яка його ключова відмінність від REST?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 309,
  "fields": {
    "question": "Як працює `memoryview` в Python і в яких випадках його використання є доцільним?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 310,
  "fields": {
    "question": "Що таке 'namespace packages' і як вони відрізняються від звичайних пакетів?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 311,
  "fields": {
    "question": "Як працює 'covering index' в базах даних?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 312,
  "fields": {
    "question": "Яка різниця між синхронною та асинхронною реплікацією бази даних?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 313,
  "fields": {
    "question": "Для чого потрібен PgBouncer?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 314,
  "fields": {
    "question": "Що таке F() вирази (expressions) в Django ORM?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 315,
  "fields": {
    "question": "Що таке Q() об'єкти в Django ORM?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 4
  }
},
{
  "model": "interview_app.question",
  "pk": 316,
  "fields": {
    "question": "Чим `ViewSet` відрізняється від `APIView` в Django Rest Framework?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 4
  }
},
{
  "model": "interview_app.question",
  "pk": 317,
  "fields": {
    "question": "Як працюють `Future` та `Task` в `asyncio`?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 7
  }
},
{
  "model": "interview_app.question",
  "pk": 318,
  "fields": {
    "question": "Що таке 'service mesh' (наприклад, Istio, Linkerd) і які функції він надає?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 6
  }
},
{
  "model": "interview_app.question",
  "pk": 319,
  "fields": {
    "question": "Як працює Gunicorn? Поясніть модель 'pre-fork worker'.",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 6
  }
},
{
  "model": "interview_app.question",
  "pk": 320,
  "fields": {
    "question": "Що таке 'XSS' (Cross-Site Scripting) і як від нього захиститися?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 4
  }
},
{
  "model": "interview_app.question",
  "pk": 321,
  "fields": {
    "question": "Що таке 'Insecure Deserialization'?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 322,
  "fields": {
    "question": "Що таке Web Application Firewall (WAF) і де він знаходиться в архітектурі?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 6
  }
},
{
  "model": "interview_app.question",
  "pk": 323,
  "fields": {
    "question": "Для чого використовується модуль `tracemalloc` в Python?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 324,
  "fields": {
    "question": "Поясніть, як працює `cProfile` для профілювання коду.",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 325,
  "fields": {
    "question": "Як працює 'backpressure' в системах потокової обробки даних?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 7
  }
},
{
  "model": "interview_app.question",
  "pk": 326,
  "fields": {
    "question": "Що таке 'canary testing'?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 327,
  "fields": {
    "question": "Що таке 'Chaos Engineering'?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 328,
  "fields": {
    "question": "Поясніть, що таке `__mro__` атрибут класу і як він використовується.",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 329,
  "fields": {
    "question": "Що таке 'database router' в Django і для чого він потрібен?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 4
  }
},
{
  "model": "interview_app.question",
  "pk": 330,
  "fields": {
    "question": "У чому полягає різниця між форматами серіалізації Avro та Parquet?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 5
  }
},
{
  "model": "interview_app.question",
  "pk": 331,
  "fields": {
    "question": "Що таке 'eventual consistency'?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 5
  }
},
{
  "model": "interview_app.question",
  "pk": 332,
  "fields": {
    "question": "Що таке 'monkey patching' і коли це може бути виправданим?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 333,
  "fields": {
    "question": "Як працює 'atomic transaction' в базах даних?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 5
  }
},
{
  "model": "interview_app.question",
  "pk": 334,
  "fields": {
    "question": "Чим відрізняються `select` та `epoll` для мультиплексування I/O?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 7
  }
},
{
  "model": "interview_app.question",
  "pk": 335,
  "fields": {
    "question": "Поясніть різницю між 'EAFP' (Easier to Ask for Forgiveness than Permission) та 'LBYL' (Look Before You Leap) в Python. Який підхід є більш ідіоматичним для мови?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 336,
  "fields": {
    "question": "Як саме реалізований словник (dict) в CPython починаючи з версії 3.6?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 337,
  "fields": {
    "question": "Що таке протокол дескрипторів і як Python використовує його для реалізації властивостей (@property) та методів?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 338,
  "fields": {
    "question": "Поясніть різницю в пріоритеті між 'data descriptors' та 'non-data descriptors'.",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 339,
  "fields": {
    "question": "Як працює Global Interpreter Lock (GIL) в CPython і які операції його тимчасово звільняють?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 7
  }
},
{
  "model": "interview_app.question",
  "pk": 340,
  "fields": {
    "question": "Що таке 'generations' у збирачі сміття (Garbage Collector) CPython?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 341,
  "fields": {
    "question": "Що таке Abstract Syntax Tree (AST) в Python і для чого використовується модуль `ast`?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 342,
  "fields": {
    "question": "Як працює віртуальна машина Python (PVM)?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 343,
  "fields": {
    "question": "Для чого потрібен `__slots__` і як він впливає на використання пам'яті?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 344,
  "fields": {
    "question": "Що таке 'string interning' в Python і як воно працює?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 345,
  "fields": {
    "question": "Поясніть, що робить `__getattribute__` і чим він небезпечний.",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 346,
  "fields": {
    "question": "Як працює алгоритм C3 лінеаризації для MRO (Method Resolution Order)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 347,
  "fields": {
    "question": "Що таке 'coroutine' і як воно еволюціонувало від генераторів?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 7
  }
},
{
  "model": "interview_app.question",
  "pk": 348,
  "fields": {
    "question": "Для чого потрібен `yield from`?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 349,
  "fields": {
    "question": "Як працює `collections.deque` і чому операції з обох кінців є O(1)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 3
  }
},
{
  "model": "interview_app.question",
  "pk": 350,
  "fields": {
    "question": "Що таке 'Protocol' з модуля `typing` і як він реалізує структурну типізацію (static duck typing)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 351,
  "fields": {
    "question": "Що таке `ParamSpec` та `Concatenate` з модуля `typing`?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 352,
  "fields": {
    "question": "Що таке 'frame object' в Python?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 353,
  "fields": {
    "question": "Як працює Timsort, алгоритм сортування, що використовується в `list.sort()` та `sorted()`?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": "Strong Junior",
    "category": 3
  }
},
{
  "model": "interview_app.question",
  "pk": 354,
  "fields": {
    "question": "Для чого потрібен декоратор `functools.wraps`?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 355,
  "fields": {
    "question": "Що таке `contextlib.ExitStack` і в яких випадках він корисний?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 356,
  "fields": {
    "question": "Чому не можна використовувати `len()` для перевірки порожності ітератора?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 357,
  "fields": {
    "question": "Що таке 'subinterpreters' і яку проблему вони можуть вирішити в майбутньому?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 7
  }
},
{
  "model": "interview_app.question",
  "pk": 358,
  "fields": {
    "question": "Для чого призначений метод `__set_name__` у дескрипторах?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 359,
  "fields": {
    "question": "Яка різниця між `is` та `==` при порівнянні `None`, `True`, `False`?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 360,
  "fields": {
    "question": "Що робить функція `itertools.tee`?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": "Junior",
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 361,
  "fields": {
    "question": "Який механізм дозволяє Python імпортувати .zip архіви як пакети?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 1
  }
},
{
  "model": "interview_app.question",
  "pk": 362,
  "fields": {
    "question": "Чим 'shallow copy' відрізняється від 'deep copy' для вкладених об'єктів?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 2
  }
},
{
  "model": "interview_app.question",
  "pk": 363,
  "fields": {
    "question": "Що таке 'фаззінг' (fuzzing) і як його можна застосувати до Python коду?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 364,
  "fields": {
    "question": "Що таке 'walrus operator' (`:=`) і яку проблему він вирішує?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 365,
  "fields": {
    "question": "Що таке 'Unit of Work' патерн і як його реалізує SQLAlchemy Session?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 366,
  "fields": {
    "question": "Поясніть різницю між `session.flush()` та `session.commit()` в SQLAlchemy.",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 367,
  "fields": {
    "question": "Яка різниця між стратегіями завантаження `joinedload`, `subqueryload` та `selectinload` в SQLAlchemy?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 368,
  "fields": {
    "question": "Що таке 'connection pooling' в SQLAlchemy і для чого потрібен `QueuePool`?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 369,
  "fields": {
    "question": "Як Alembic визначає, які зміни потрібно внести в міграцію при `autogenerate`?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 370,
  "fields": {
    "question": "Що таке 'branching' міграцій в Alembic і коли це може статися?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 371,
  "fields": {
    "question": "Чим відрізняються індекси GIN та GiST в PostgreSQL?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 372,
  "fields": {
    "question": "Для чого в PostgreSQL використовуються 'advisory locks'?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 373,
  "fields": {
    "question": "Що таке 'LISTEN'/'NOTIFY' в PostgreSQL?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": "Junior",
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 374,
  "fields": {
    "question": "Яка різниця в моделюванні даних для MongoDB (документна БД) порівняно з реляційною БД?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 375,
  "fields": {
    "question": "Що таке 'Time to Live' (TTL) індекс у MongoDB?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": "Junior",
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 376,
  "fields": {
    "question": "Що таке 'message acknowledgment' в Celery і як воно впливає на надійність?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 377,
  "fields": {
    "question": "Як працює механізм 'retry' з 'exponential backoff' в Celery?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 378,
  "fields": {
    "question": "Для чого використовується Celery Beat?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 379,
  "fields": {
    "question": "Що таке 'prompt engineering'?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 380,
  "fields": {
    "question": "Що таке 'zero-shot', 'one-shot' та 'few-shot' prompting?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 381,
  "fields": {
    "question": "Що таке 'Chain-of-Thought' (CoT) prompting?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 382,
  "fields": {
    "question": "Яка роль 'system prompt' при взаємодії з моделлю OpenAI?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 383,
  "fields": {
    "question": "Що таке 'Function Calling' (або 'Tool Use') в API мовних моделей?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 384,
  "fields": {
    "question": "Як параметр `temperature` впливає на відповідь моделі OpenAI?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 385,
  "fields": {
    "question": "Що таке 'embeddings' і для чого вони використовуються в роботі з LLM?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 386,
  "fields": {
    "question": "Що таке 'Retrieval-Augmented Generation' (RAG)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 387,
  "fields": {
    "question": "Що таке 'tokenization' і чому важливо розуміти, як працює токенізатор моделі?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 388,
  "fields": {
    "question": "Коли варто розглядати 'fine-tuning' моделі замість промпт-інжинірингу?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 389,
  "fields": {
    "question": "Що таке 'Outbox Pattern'?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 390,
  "fields": {
    "question": "Що таке 'mutual TLS' (mTLS)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 391,
  "fields": {
    "question": "Яка різниця між 'write-through' та 'write-behind' (write-back) кешуванням?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 392,
  "fields": {
    "question": "Що таке 'Leaky Bucket' алгоритм для rate limiting?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 393,
  "fields": {
    "question": "Що таке 'Trie' (префіксне дерево) і де воно застосовується?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 394,
  "fields": {
    "question": "Що таке 'WebSockets' і чим вони відрізняються від Server-Sent Events (SSE)?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 395,
  "fields": {
    "question": "Чим відрізняються методи запуску процесів 'fork', 'spawn' та 'forkserver' в модулі `multiprocessing`?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 396,
  "fields": {
    "question": "Для чого потрібен TCP `KEEP_ALIVE` і як він працює на рівні сокетів?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 397,
  "fields": {
    "question": "Що таке 'Nagle's algorithm' і чому його іноді вимикають для чутливих до затримок додатків?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 398,
  "fields": {
    "question": "Що таке eBPF (extended Berkeley Packet Filter) і як він може використовуватися для observability Python-додатків?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 399,
  "fields": {
    "question": "Яка різниця між симетричним та асиметричним шифруванням? Наведіть приклади алгоритмів.",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 400,
  "fields": {
    "question": "Що таке 'Certificate Authority' (CA) і яку роль вона відіграє в TLS/SSL?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 401,
  "fields": {
    "question": "Що таке 'timing attack'?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 402,
  "fields": {
    "question": "Яка різниця між 'stream processing' та 'batch processing'?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 403,
  "fields": {
    "question": "Що таке 'data lake' і чим він відрізняється від 'data warehouse'?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 404,
  "fields": {
    "question": "Що таке 'Sidecar pattern' в архітектурі контейнерів?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 405,
  "fields": {
    "question": "У чому полягає різниця між 'serverless' (напр., AWS Lambda) та 'container-as-a-service' (напр., AWS Fargate)?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 406,
  "fields": {
    "question": "Для чого в PostgreSQL використовуються 'Foreign Data Wrappers' (FDW)?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 407,
  "fields": {
    "question": "Що таке 'table partitioning' в PostgreSQL і які переваги воно дає?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 408,
  "fields": {
    "question": "Як працює `pg_trgm` розширення в PostgreSQL?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 409,
  "fields": {
    "question": "Що таке 'load balancing' і які є основні алгоритми (напр., Round Robin, Least Connections)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 410,
  "fields": {
    "question": "Що таке 'Content Delivery Network' (CDN) і як він працює?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 411,
  "fields": {
    "question": "Поясніть, що таке 'Conway's Law'.",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 412,
  "fields": {
    "question": "Що таке 'API Gateway' і чим він відрізняється від 'Backend for Frontend' (BFF)?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 413,
  "fields": {
    "question": "Як працює `sys.meta_path` і як він дозволяє створювати кастомні імпортери?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 414,
  "fields": {
    "question": "Для чого потрібен Python C API?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 415,
  "fields": {
    "question": "Що таке Celery 'Flower'?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 416,
  "fields": {
    "question": "Як можна організувати маршрутизацію задач в Celery до різних черг?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 417,
  "fields": {
    "question": "Що таке 'availability zone' (AZ) та 'region' в хмарних провайдерах, як-от AWS?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 418,
  "fields": {
    "question": "Що таке 'Infrastructure as Code' (IaC) і чим Terraform відрізняється від Ansible?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 419,
  "fields": {
    "question": "Що таке 'rolling update' стратегія розгортання?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 420,
  "fields": {
    "question": "Що таке 'gRPC-Web'?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 421,
  "fields": {
    "question": "Яка різниця між 'authentication' та 'authorization'?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 422,
  "fields": {
    "question": "Що таке 'consistent hashing'?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 423,
  "fields": {
    "question": "Що таке 'binary protocol' і які його переваги над текстовими (напр., JSON)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 424,
  "fields": {
    "question": "Що таке 'OpenTelemetry'?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 425,
  "fields": {
    "question": "Що таке 'predicate pushdown' в оптимізаторі запитів?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 426,
  "fields": {
    "question": "Чим відрізняються стратегії об'єднання 'Nested Loop', 'Hash Join' та 'Merge Join'?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 427,
  "fields": {
    "question": "Що таке 'кардинальність' (cardinality) в контексті баз даних і чому вона важлива для оптимізатора?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 428,
  "fields": {
    "question": "Для чого потрібен `VACUUM` (особливо `AUTOVACUUM`) в PostgreSQL?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 429,
  "fields": {
    "question": "Що таке 'partial index' (частковий індекс) і коли його варто використовувати?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 430,
  "fields": {
    "question": "Що таке 'index-only scan'?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 431,
  "fields": {
    "question": "Поясніть, що таке рекурсивний CTE і для яких задач він використовується.",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 432,
  "fields": {
    "question": "Яка різниця між `UNION` та `UNION ALL`?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 433,
  "fields": {
    "question": "Для чого використовуються `INTERSECT` та `EXCEPT`?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 434,
  "fields": {
    "question": "Що таке 'materialized view' і коли її варто використовувати?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 435,
  "fields": {
    "question": "Що таке 'trigger' в базі даних і які можуть бути недоліки його використання?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 436,
  "fields": {
    "question": "Поясніть рівні ізоляції транзакцій: 'Read Uncommitted', 'Read Committed', 'Repeatable Read', 'Serializable'.",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 437,
  "fields": {
    "question": "Що таке 'phantom read' і який мінімальний рівень ізоляції запобігає йому?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 438,
  "fields": {
    "question": "Для чого в SQL використовуються `SAVEPOINT`?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 439,
  "fields": {
    "question": "Що таке 'Two-Phase Commit' (2PC)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 440,
  "fields": {
    "question": "Як працюють оператори `->`, `->>` та `@>` для JSONB в PostgreSQL?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 441,
  "fields": {
    "question": "Що таке 'denormalization' і коли її виправдано застосовувати?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 442,
  "fields": {
    "question": "Чому використання UUID як первинного ключа може вплинути на продуктивність B-Tree індексів?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 443,
  "fields": {
    "question": "Що таке `CHECK` constraint?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 444,
  "fields": {
    "question": "Як працює `GROUPING SETS`?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 445,
  "fields": {
    "question": "Для чого потрібна функція `COALESCE`?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 446,
  "fields": {
    "question": "Чим відрізняються `ROW_NUMBER()`, `RANK()` та `DENSE_RANK()`?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 447,
  "fields": {
    "question": "Що таке `FILTER` clause для агрегатних функцій в SQL?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 448,
  "fields": {
    "question": "Що таке `BRIN` (Block Range Index) в PostgreSQL і коли він ефективний?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 449,
  "fields": {
    "question": "Що таке 'deferrable constraints'?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 450,
  "fields": {
    "question": "Що робить `EXPLAIN (ANALYZE, BUFFERS)`?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 451,
  "fields": {
    "question": "Що таке 'WAL' (Write-Ahead Logging) в PostgreSQL?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 452,
  "fields": {
    "question": "Чим `TRUNCATE` відрізняється від `DELETE`?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 453,
  "fields": {
    "question": "Що таке 'sequence' в базі даних?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 454,
  "fields": {
    "question": "Чому запити з `OR` на кількох колонках часто є неефективними?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 455,
  "fields": {
    "question": "У чому ключова відмінність між Continuous Delivery та Continuous Deployment?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 456,
  "fields": {
    "question": "Який ефект має порядок команд в Dockerfile на кешування шарів?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 457,
  "fields": {
    "question": "Для чого використовується `.dockerignore` файл?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 458,
  "fields": {
    "question": "У якій ситуації Kubernetes перезапустить контейнер: при збої Liveness Probe чи Readiness Probe?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 459,
  "fields": {
    "question": "Що таке 'requests' та 'limits' для ресурсів (CPU, memory) в Kubernetes?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 460,
  "fields": {
    "question": "Чим `ConfigMap` відрізняється від `Secret` в Kubernetes?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 461,
  "fields": {
    "question": "Що таке Helm в екосистемі Kubernetes?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 462,
  "fields": {
    "question": "Що таке 'Service' в Kubernetes і які є його основні типи?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 463,
  "fields": {
    "question": "Яка різниця між WSGI та ASGI серверами (напр., Gunicorn vs Uvicorn)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 464,
  "fields": {
    "question": "Як зазвичай налаштовують взаємодію Nginx та Gunicorn в продакшені?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 465,
  "fields": {
    "question": "Що таке ідемпотентність в контексті інструментів конфігурації, як-от Ansible?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 466,
  "fields": {
    "question": "Що таке 'Terraform provider'?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 467,
  "fields": {
    "question": "Чому використання IAM Roles на EC2-інстансах є безпечнішим, ніж зберігання access keys?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 468,
  "fields": {
    "question": "Що таке 'cold start' в Serverless-функціях (напр., AWS Lambda)?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 469,
  "fields": {
    "question": "Що таке 'CI runner' (або 'agent')?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 470,
  "fields": {
    "question": "Яка різниця між 'pipeline as code' та конфігурацією CI/CD через UI?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 471,
  "fields": {
    "question": "Що таке 'artifact' в контексті CI/CD?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 472,
  "fields": {
    "question": "Що таке 'blue-green deployment'?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 473,
  "fields": {
    "question": "Що таке 'health check' ендпоінт і для чого він потрібен?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 474,
  "fields": {
    "question": "Яка різниця між `docker-compose up` та `docker-compose run`?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 475,
  "fields": {
    "question": "Що таке 'overlay network' в Docker Swarm або Kubernetes?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 476,
  "fields": {
    "question": "Що таке 'SSL Termination'?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 477,
  "fields": {
    "question": "Для чого потрібен 'init container' в Kubernetes?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 478,
  "fields": {
    "question": "Що таке 'Prometheus Exporter'?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 479,
  "fields": {
    "question": "Чим 'Pull' модель збору метрик (як у Prometheus) відрізняється від 'Push' моделі?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 480,
  "fields": {
    "question": "Що таке 'distributed tracing' і яку проблему воно вирішує в мікросервісах?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 481,
  "fields": {
    "question": "Що таке 'git-flow'?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 482,
  "fields": {
    "question": "Що таке 'semantic versioning' (SemVer)?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 483,
  "fields": {
    "question": "Для чого потрібен `requirements.txt` і чим він відрізняється від `setup.py` (або `pyproject.toml`)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 484,
  "fields": {
    "question": "Що таке 'virtual environment' в Python і яку проблему він вирішує?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 485,
  "fields": {
    "question": "Що означає 'Uniform Interface' як одне з ключових обмежень REST?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 486,
  "fields": {
    "question": "Що таке HATEOAS (Hypermedia as the Engine of Application State)?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 487,
  "fields": {
    "question": "Чим фундаментально відрізняється HTTP метод `PATCH` від `PUT`?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 488,
  "fields": {
    "question": "Що таке 'ідемпотентність' HTTP-методу? Які методи є ідемпотентними?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 489,
  "fields": {
    "question": "Що таке 'безпечний' (safe) HTTP-метод?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 490,
  "fields": {
    "question": "Для чого використовується HTTP метод `OPTIONS`?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 491,
  "fields": {
    "question": "Як працює HTTP-заголовок `Cache-Control`?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 492,
  "fields": {
    "question": "Як працює валідація кешу за допомогою заголовків `ETag` та `If-None-Match`?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 493,
  "fields": {
    "question": "Що таке 'CORS preflight request'?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 494,
  "fields": {
    "question": "Чим відрізняються HTTP статуси `301 Moved Permanently` та `302 Found`?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 495,
  "fields": {
    "question": "Що таке HTTP Strict Transport Security (HSTS)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 496,
  "fields": {
    "question": "Поясніть, що таке TLS Handshake.",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 497,
  "fields": {
    "question": "Що таке 'Server Name Indication' (SNI) і яку проблему воно вирішує?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 498,
  "fields": {
    "question": "Що таке 'Perfect Forward Secrecy' (PFS)?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 499,
  "fields": {
    "question": "Для чого використовується HTTP-заголовок `Content-Security-Policy` (CSP)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 500,
  "fields": {
    "question": "Яка різниця між HTTP-куками та `localStorage`?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 501,
  "fields": {
    "question": "Що таке 'API Rate Limiting' і чому це важливо?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 502,
  "fields": {
    "question": "В якому випадку слід використовувати статус `202 Accepted`?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 503,
  "fields": {
    "question": "Що таке 'JSON Patch' (RFC 6902)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 504,
  "fields": {
    "question": "Що таке 'Certificate Chain'?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 505,
  "fields": {
    "question": "Що означає `public` та `private` в директиві `Cache-Control`?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 506,
  "fields": {
    "question": "Для чого використовується HTTP-заголовок `Accept`?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 507,
  "fields": {
    "question": "Що таке 'Connection Pooling' на рівні HTTP-клієнта (напр., в бібліотеці `requests`)?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 508,
  "fields": {
    "question": "Що таке 'head-of-line blocking' в HTTP/1.1?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 509,
  "fields": {
    "question": "Яка роль атрибутів `SameSite`, `Secure` та `HttpOnly` для кук?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 510,
  "fields": {
    "question": "Чим відрізняється статус `401 Unauthorized` від `403 Forbidden`?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 511,
  "fields": {
    "question": "Що таке 'OpenAPI Specification' (раніше Swagger)?",
    "correct_answer_key": "b",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 512,
  "fields": {
    "question": "У чому полягає проблема 'lost update' в API і як її можна вирішити?",
    "correct_answer_key": "a",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 513,
  "fields": {
    "question": "Що таке 'Cipher Suite' в TLS?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.question",
  "pk": 514,
  "fields": {
    "question": "Що таке 'gRPC-Gateway'?",
    "correct_answer_key": "c",
    "user_answer": null,
    "complexity": null,
    "category": 8
  }
},
{
  "model": "interview_app.option",
  "pk": 1,
  "fields": {
    "question": 1,
    "key": "a",
    "text": "Python швидкий у виконанні завдяки компіляції в машинний код."
  }
},
{
  "model": "interview_app.option",
  "pk": 2,
  "fields": {
    "question": 1,
    "key": "b",
    "text": "Python є виключно мовою низького рівня для системного програмування."
  }
},
{
  "model": "interview_app.option",
  "pk": 3,
  "fields": {
    "question": 1,
    "key": "c",
    "text": "Однією з головних переваг Python є його читабельний синтаксис. Мова була створена з урахуванням того, щоб код був зрозумілим для людей, і вона наближена до природної мови."
  }
},
{
  "model": "interview_app.option",
  "pk": 4,
  "fields": {
    "question": 2,
    "key": "a",
    "text": "У Python існують числові типи (int, float, complex), рядки (str), послідовності (list, tuple, range), словники (dict), множини (set) та логічний тип (bool). Взаємодія залежить від операцій. Числа і рядки незмінні, списки змінні."
  }
},
{
  "model": "interview_app.option",
  "pk": 5,
  "fields": {
    "question": 2,
    "key": "b",
    "text": "Python підтримує лише один тип даних — рядок."
  }
},
{
  "model": "interview_app.option",
  "pk": 6,
  "fields": {
    "question": 2,
    "key": "c",
    "text": "Типи даних у Python не мають взаємодії між собою."
  }
},
{
  "model": "interview_app.option",
  "pk": 7,
  "fields": {
    "question": 3,
    "key": "a",
    "text": "Літерали — це змінні, які можна перепризначити у програмі."
  }
},
{
  "model": "interview_app.option",
  "pk": 8,
  "fields": {
    "question": 3,
    "key": "b",
    "text": "Літерали — це функції, які повертають числа."
  }
},
{
  "model": "interview_app.option",
  "pk": 9,
  "fields": {
    "question": 3,
    "key": "c",
    "text": "Літерали — це фіксовані значення, які використовуються безпосередньо в коді, наприклад числа, рядки, логічні значення (True, False)."
  }
},
{
  "model": "interview_app.option",
  "pk": 10,
  "fields": {
    "question": 4,
    "key": "a",
    "text": "Python виконує код рядок за рядком через інтерпретатор, що дає змогу швидко тестувати, але виконується повільніше за компільовані мови."
  }
},
{
  "model": "interview_app.option",
  "pk": 11,
  "fields": {
    "question": 4,
    "key": "b",
    "text": "Python не підтримує виконання коду безпосередньо."
  }
},
{
  "model": "interview_app.option",
  "pk": 12,
  "fields": {
    "question": 4,
    "key": "c",
    "text": "Python завжди компілюється в машинний код перед виконанням."
  }
},
{
  "model": "interview_app.option",
  "pk": 13,
  "fields": {
    "question": 5,
    "key": "a",
    "text": "PEP 8 — це рекомендації зі стилю написання читабельного коду Python."
  }
},
{
  "model": "interview_app.option",
  "pk": 14,
  "fields": {
    "question": 5,
    "key": "b",
    "text": "PEP 8 — це база даних для зберігання Python модулів."
  }
},
{
  "model": "interview_app.option",
  "pk": 15,
  "fields": {
    "question": 5,
    "key": "c",
    "text": "PEP 8 — це інструмент для запуску Python програм."
  }
},
{
  "model": "interview_app.option",
  "pk": 16,
  "fields": {
    "question": 6,
    "key": "a",
    "text": "Простір імен — це спеціальна функція для обробки рядків у Python."
  }
},
{
  "model": "interview_app.option",
  "pk": 17,
  "fields": {
    "question": 6,
    "key": "b",
    "text": "Простір імен — це модуль для роботи з файлами."
  }
},
{
  "model": "interview_app.option",
  "pk": 18,
  "fields": {
    "question": 6,
    "key": "c",
    "text": "Простір імен — це область коду, де зберігаються значення змінних та інших об'єктів, пов'язані з певними іменами. В Python є вбудовані, глобальні та локальні простори імен."
  }
},
{
  "model": "interview_app.option",
  "pk": 19,
  "fields": {
    "question": 7,
    "key": "a",
    "text": "Модулем в Python називають будь-який файл з програмою, наприклад module_name.py."
  }
},
{
  "model": "interview_app.option",
  "pk": 20,
  "fields": {
    "question": 7,
    "key": "b",
    "text": "Модулі — це бібліотеки, які не можна імпортувати в Python."
  }
},
{
  "model": "interview_app.option",
  "pk": 21,
  "fields": {
    "question": 7,
    "key": "c",
    "text": "Модулі — це типи даних для зберігання чисел."
  }
},
{
  "model": "interview_app.option",
  "pk": 22,
  "fields": {
    "question": 8,
    "key": "a",
    "text": "Локальні змінні — це змінні, що зберігаються на диск, а глобальні — в пам’яті."
  }
},
{
  "model": "interview_app.option",
  "pk": 23,
  "fields": {
    "question": 8,
    "key": "b",
    "text": "Локальні змінні оголошені всередині функції і доступні тільки там, глобальні — поза функціями і видимі скрізь у програмі."
  }
},
{
  "model": "interview_app.option",
  "pk": 24,
  "fields": {
    "question": 8,
    "key": "c",
    "text": "Локальні змінні видимі всюди, а глобальні лише всередині функції."
  }
},
{
  "model": "interview_app.option",
  "pk": 25,
  "fields": {
    "question": 9,
    "key": "a",
    "text": "Ключові слова — це назви файлів у проекті Python."
  }
},
{
  "model": "interview_app.option",
  "pk": 26,
  "fields": {
    "question": 9,
    "key": "b",
    "text": "Ключові слова — це зарезервовані слова з особливим значенням у мові, як for, while, if, def тощо."
  }
},
{
  "model": "interview_app.option",
  "pk": 27,
  "fields": {
    "question": 9,
    "key": "c",
    "text": "Ключові слова — це імена змінних, які можна змінювати у програмі."
  }
},
{
  "model": "interview_app.option",
  "pk": 28,
  "fields": {
    "question": 10,
    "key": "a",
    "text": "За допомогою функції print()"
  }
},
{
  "model": "interview_app.option",
  "pk": 29,
  "fields": {
    "question": 10,
    "key": "b",
    "text": "За допомогою функції input()"
  }
},
{
  "model": "interview_app.option",
  "pk": 30,
  "fields": {
    "question": 10,
    "key": "c",
    "text": "За допомогою функції type()"
  }
},
{
  "model": "interview_app.option",
  "pk": 31,
  "fields": {
    "question": 11,
    "key": "a",
    "text": "ООП — це тип змінних у Python."
  }
},
{
  "model": "interview_app.option",
  "pk": 32,
  "fields": {
    "question": 11,
    "key": "b",
    "text": "ООП — це мова програмування, яку використовують лише для веб-розробки."
  }
},
{
  "model": "interview_app.option",
  "pk": 33,
  "fields": {
    "question": 11,
    "key": "c",
    "text": "ООП — це парадигма програмування, яка організовує програму навколо об'єктів, які мають атрибути та методи."
  }
},
{
  "model": "interview_app.option",
  "pk": 34,
  "fields": {
    "question": 12,
    "key": "a",
    "text": "Приховування складності реалізації та показ лише суттєвої інформації."
  }
},
{
  "model": "interview_app.option",
  "pk": 35,
  "fields": {
    "question": 12,
    "key": "b",
    "text": "Можливість використовувати один і той самий інтерфейс для різних типів об’єктів."
  }
},
{
  "model": "interview_app.option",
  "pk": 36,
  "fields": {
    "question": 12,
    "key": "c",
    "text": "Обмеження доступу до частин об'єкта для захисту даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 37,
  "fields": {
    "question": 13,
    "key": "a",
    "text": "Створення нового класу на основі вже існуючого."
  }
},
{
  "model": "interview_app.option",
  "pk": 38,
  "fields": {
    "question": 13,
    "key": "b",
    "text": "Приховування складності реалізації."
  }
},
{
  "model": "interview_app.option",
  "pk": 39,
  "fields": {
    "question": 13,
    "key": "c",
    "text": "Обмеження доступу до частин об'єкта — захист даних від прямої зовнішньої зміни."
  }
},
{
  "model": "interview_app.option",
  "pk": 40,
  "fields": {
    "question": 14,
    "key": "a",
    "text": "Приховування складності реалізації."
  }
},
{
  "model": "interview_app.option",
  "pk": 41,
  "fields": {
    "question": 14,
    "key": "b",
    "text": "Створення нового класу на основі вже існуючого (батьківського)."
  }
},
{
  "model": "interview_app.option",
  "pk": 42,
  "fields": {
    "question": 14,
    "key": "c",
    "text": "Використання одного інтерфейсу для різних типів об’єктів."
  }
},
{
  "model": "interview_app.option",
  "pk": 43,
  "fields": {
    "question": 15,
    "key": "a",
    "text": "Створення нового класу на основі вже існуючого."
  }
},
{
  "model": "interview_app.option",
  "pk": 44,
  "fields": {
    "question": 15,
    "key": "b",
    "text": "Обмеження доступу до частин об'єкта."
  }
},
{
  "model": "interview_app.option",
  "pk": 45,
  "fields": {
    "question": 15,
    "key": "c",
    "text": "Можливість використовувати один і той самий інтерфейс для різних типів об’єктів."
  }
},
{
  "model": "interview_app.option",
  "pk": 46,
  "fields": {
    "question": 16,
    "key": "a",
    "text": "Клас — це змінна, об'єкт — це функція."
  }
},
{
  "model": "interview_app.option",
  "pk": 47,
  "fields": {
    "question": 16,
    "key": "b",
    "text": "Клас — це шаблон, об'єкт — це конкретний екземпляр класу з власними значеннями."
  }
},
{
  "model": "interview_app.option",
  "pk": 48,
  "fields": {
    "question": 16,
    "key": "c",
    "text": "Об'єкт — це шаблон, клас — це екземпляр."
  }
},
{
  "model": "interview_app.option",
  "pk": 49,
  "fields": {
    "question": 17,
    "key": "a",
    "text": "Посилання на поточний об'єкт для доступу до його атрибутів і методів."
  }
},
{
  "model": "interview_app.option",
  "pk": 50,
  "fields": {
    "question": 17,
    "key": "b",
    "text": "Змінна для зберігання класу."
  }
},
{
  "model": "interview_app.option",
  "pk": 51,
  "fields": {
    "question": 17,
    "key": "c",
    "text": "Функція для створення об'єкта."
  }
},
{
  "model": "interview_app.option",
  "pk": 52,
  "fields": {
    "question": 18,
    "key": "a",
    "text": "__init__ — це змінна класу."
  }
},
{
  "model": "interview_app.option",
  "pk": 53,
  "fields": {
    "question": 18,
    "key": "b",
    "text": "__init__ — це конструктор, який автоматично викликається при створенні об’єкта і ініціалізує його початковий стан."
  }
},
{
  "model": "interview_app.option",
  "pk": 54,
  "fields": {
    "question": 18,
    "key": "c",
    "text": "__init__ — це метод для видалення об'єкта."
  }
},
{
  "model": "interview_app.option",
  "pk": 55,
  "fields": {
    "question": 19,
    "key": "a",
    "text": "Атрибут класу унікальний для кожного об'єкта, а атрибут об'єкта спільний для всіх."
  }
},
{
  "model": "interview_app.option",
  "pk": 56,
  "fields": {
    "question": 19,
    "key": "b",
    "text": "Обидва атрибути однакові і не мають відмінностей."
  }
},
{
  "model": "interview_app.option",
  "pk": 57,
  "fields": {
    "question": 19,
    "key": "c",
    "text": "Атрибут класу спільний для всіх об'єктів, задається поза __init__, атрибут об'єкта унікальний для кожного і задається в __init__ через self."
  }
},
{
  "model": "interview_app.option",
  "pk": 58,
  "fields": {
    "question": 20,
    "key": "a",
    "text": "Звичайний метод працює з об'єктом (має доступ до self), метод класу працює з класом (має доступ до cls), статичний метод не має доступу ні до класу, ні до об'єкта."
  }
},
{
  "model": "interview_app.option",
  "pk": 59,
  "fields": {
    "question": 20,
    "key": "b",
    "text": "Всі методи працюють лише з об'єктом і мають доступ до self."
  }
},
{
  "model": "interview_app.option",
  "pk": 60,
  "fields": {
    "question": 20,
    "key": "c",
    "text": "Метод класу і статичний метод це синоніми, а звичайний метод не існує."
  }
},
{
  "model": "interview_app.option",
  "pk": 61,
  "fields": {
    "question": 21,
    "key": "a",
    "text": "Поліморфізм означає використання змінних різних типів одночасно."
  }
},
{
  "model": "interview_app.option",
  "pk": 62,
  "fields": {
    "question": 21,
    "key": "b",
    "text": "Поліморфізм — це особливий тип циклу в Python."
  }
},
{
  "model": "interview_app.option",
  "pk": 63,
  "fields": {
    "question": 21,
    "key": "c",
    "text": "Поліморфізм реалізується через наслідування та перевизначення методів."
  }
},
{
  "model": "interview_app.option",
  "pk": 64,
  "fields": {
    "question": 22,
    "key": "a",
    "text": "Наслідування — 'є типом', композиція — 'має' (об’єкт створюється всередині класу), агрегація — 'має', але об’єкт передається ззовні."
  }
},
{
  "model": "interview_app.option",
  "pk": 65,
  "fields": {
    "question": 22,
    "key": "b",
    "text": "Композиція та агрегація — це синоніми наслідування."
  }
},
{
  "model": "interview_app.option",
  "pk": 66,
  "fields": {
    "question": 22,
    "key": "c",
    "text": "Наслідування — це спосіб приховати методи класу."
  }
},
{
  "model": "interview_app.option",
  "pk": 67,
  "fields": {
    "question": 23,
    "key": "a",
    "text": "Методи, які не можна викликати в коді."
  }
},
{
  "model": "interview_app.option",
  "pk": 68,
  "fields": {
    "question": 23,
    "key": "b",
    "text": "Магічні методи — спеціальні методи, що починаються і закінчуються двома підкресленнями, які змінюють поведінку об'єктів."
  }
},
{
  "model": "interview_app.option",
  "pk": 69,
  "fields": {
    "question": 23,
    "key": "c",
    "text": "Методи, які автоматично видаляють об'єкти з пам'яті."
  }
},
{
  "model": "interview_app.option",
  "pk": 70,
  "fields": {
    "question": 24,
    "key": "a",
    "text": "Mutable — це змінні, immutable — це константи."
  }
},
{
  "model": "interview_app.option",
  "pk": 71,
  "fields": {
    "question": 24,
    "key": "b",
    "text": "Mutable об'єкти можна змінювати після створення (list, dict), immutable — не можна змінювати (str, tuple)."
  }
},
{
  "model": "interview_app.option",
  "pk": 72,
  "fields": {
    "question": 24,
    "key": "c",
    "text": "Mutable і immutable — це типи функцій."
  }
},
{
  "model": "interview_app.option",
  "pk": 73,
  "fields": {
    "question": 25,
    "key": "a",
    "text": "Тому що рядки не використовуються часто."
  }
},
{
  "model": "interview_app.option",
  "pk": 74,
  "fields": {
    "question": 25,
    "key": "b",
    "text": "Тому що Python не підтримує змінні рядки."
  }
},
{
  "model": "interview_app.option",
  "pk": 75,
  "fields": {
    "question": 25,
    "key": "c",
    "text": "Через простоту, ефективність та безпеку."
  }
},
{
  "model": "interview_app.option",
  "pk": 76,
  "fields": {
    "question": 26,
    "key": "a",
    "text": "Списки — це типи ключів, а кортежі — це функції."
  }
},
{
  "model": "interview_app.option",
  "pk": 77,
  "fields": {
    "question": 26,
    "key": "b",
    "text": "Списки змінні і використовуються для колекцій, які змінюються, кортежі незмінні і застосовуються для фіксованих даних та ключів словників."
  }
},
{
  "model": "interview_app.option",
  "pk": 78,
  "fields": {
    "question": 26,
    "key": "c",
    "text": "Списки і кортежі однакові, різниця лише у назві."
  }
},
{
  "model": "interview_app.option",
  "pk": 79,
  "fields": {
    "question": 27,
    "key": "a",
    "text": "Множина — тип рядка."
  }
},
{
  "model": "interview_app.option",
  "pk": 80,
  "fields": {
    "question": 27,
    "key": "b",
    "text": "Множина — невпорядкована колекція унікальних елементів, на відміну від списку, де можуть бути повтори і порядок важливий."
  }
},
{
  "model": "interview_app.option",
  "pk": 81,
  "fields": {
    "question": 27,
    "key": "c",
    "text": "Множина — це відсортований список чисел."
  }
},
{
  "model": "interview_app.option",
  "pk": 82,
  "fields": {
    "question": 28,
    "key": "a",
    "text": "Словник зберігає лише послідовності чисел."
  }
},
{
  "model": "interview_app.option",
  "pk": 83,
  "fields": {
    "question": 28,
    "key": "b",
    "text": "Словник зберігає пари ключ-значення, ключі мають бути хешованими (immutable типи)."
  }
},
{
  "model": "interview_app.option",
  "pk": 84,
  "fields": {
    "question": 28,
    "key": "c",
    "text": "Словник — це список ключів без значень."
  }
},
{
  "model": "interview_app.option",
  "pk": 85,
  "fields": {
    "question": 29,
    "key": "a",
    "text": "Ключ прийметься і словник працюватиме нормально."
  }
},
{
  "model": "interview_app.option",
  "pk": 86,
  "fields": {
    "question": 29,
    "key": "b",
    "text": "Виникне TypeError: unhashable type, оскільки mutable об'єкти не можуть бути ключами."
  }
},
{
  "model": "interview_app.option",
  "pk": 87,
  "fields": {
    "question": 29,
    "key": "c",
    "text": "Обʼєкт буде автоматично перетворений на immutable."
  }
},
{
  "model": "interview_app.option",
  "pk": 88,
  "fields": {
    "question": 30,
    "key": "a",
    "text": "For використовується для фіксованої кількості ітерацій, while виконується доки умова істинна."
  }
},
{
  "model": "interview_app.option",
  "pk": 89,
  "fields": {
    "question": 30,
    "key": "b",
    "text": "For виконується доки умова істинна, while — для фіксованої кількості кроків."
  }
},
{
  "model": "interview_app.option",
  "pk": 90,
  "fields": {
    "question": 30,
    "key": "c",
    "text": "Цикли for і while однакові і не мають відмінностей."
  }
},
{
  "model": "interview_app.option",
  "pk": 91,
  "fields": {
    "question": 31,
    "key": "a",
    "text": "Оператор break припиняє поточну ітерацію циклу і передає керування на наступний оператор після циклу."
  }
},
{
  "model": "interview_app.option",
  "pk": 92,
  "fields": {
    "question": 31,
    "key": "b",
    "text": "Оператор pass зупиняє весь скрипт."
  }
},
{
  "model": "interview_app.option",
  "pk": 93,
  "fields": {
    "question": 31,
    "key": "c",
    "text": "Оператор continue пропускає наступну ітерацію циклу."
  }
},
{
  "model": "interview_app.option",
  "pk": 94,
  "fields": {
    "question": 32,
    "key": "a",
    "text": "Оператор break пропускає поточну ітерацію."
  }
},
{
  "model": "interview_app.option",
  "pk": 95,
  "fields": {
    "question": 32,
    "key": "b",
    "text": "Оператор stop завершує цикл."
  }
},
{
  "model": "interview_app.option",
  "pk": 96,
  "fields": {
    "question": 32,
    "key": "c",
    "text": "Оператор continue пропускає поточну ітерацію циклу і переходить до наступної."
  }
},
{
  "model": "interview_app.option",
  "pk": 97,
  "fields": {
    "question": 33,
    "key": "a",
    "text": "Використовують оператор continue."
  }
},
{
  "model": "interview_app.option",
  "pk": 98,
  "fields": {
    "question": 33,
    "key": "b",
    "text": "Використовують оператор pass."
  }
},
{
  "model": "interview_app.option",
  "pk": 99,
  "fields": {
    "question": 33,
    "key": "c",
    "text": "Використовують оператор break, щоб вийти з циклу."
  }
},
{
  "model": "interview_app.option",
  "pk": 100,
  "fields": {
    "question": 34,
    "key": "a",
    "text": "Ні, else не можна використовувати з циклами."
  }
},
{
  "model": "interview_app.option",
  "pk": 101,
  "fields": {
    "question": 34,
    "key": "b",
    "text": "else виконується після кожної ітерації циклу."
  }
},
{
  "model": "interview_app.option",
  "pk": 102,
  "fields": {
    "question": 34,
    "key": "c",
    "text": "Так, else виконується, якщо цикл завершився природнім шляхом без break."
  }
},
{
  "model": "interview_app.option",
  "pk": 103,
  "fields": {
    "question": 35,
    "key": "a",
    "text": "Функція для сортування списку."
  }
},
{
  "model": "interview_app.option",
  "pk": 104,
  "fields": {
    "question": 35,
    "key": "b",
    "text": "Це тип циклу, який працює швидше за for."
  }
},
{
  "model": "interview_app.option",
  "pk": 105,
  "fields": {
    "question": 35,
    "key": "c",
    "text": "Компактний та читабельний спосіб створення списків на основі існуючих даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 106,
  "fields": {
    "question": 36,
    "key": "a",
    "text": "Ні, list comprehensions не підтримують вкладеність."
  }
},
{
  "model": "interview_app.option",
  "pk": 107,
  "fields": {
    "question": 36,
    "key": "b",
    "text": "Так, можна створювати багатовимірні списки в одному виразі."
  }
},
{
  "model": "interview_app.option",
  "pk": 108,
  "fields": {
    "question": 36,
    "key": "c",
    "text": "Вкладені list comprehensions використовуються для сортування."
  }
},
{
  "model": "interview_app.option",
  "pk": 109,
  "fields": {
    "question": 37,
    "key": "a",
    "text": "Генератори — це ітератори, які використовують yield для створення елементів по одному, не зберігаючи весь список у пам'яті."
  }
},
{
  "model": "interview_app.option",
  "pk": 110,
  "fields": {
    "question": 37,
    "key": "b",
    "text": "Генератори — це спеціальні класи для роботи з файлами."
  }
},
{
  "model": "interview_app.option",
  "pk": 111,
  "fields": {
    "question": 37,
    "key": "c",
    "text": "Генератори — це функції, які повертають списки."
  }
},
{
  "model": "interview_app.option",
  "pk": 112,
  "fields": {
    "question": 38,
    "key": "a",
    "text": "Генератори — це функції, list comprehensions — це змінні."
  }
},
{
  "model": "interview_app.option",
  "pk": 113,
  "fields": {
    "question": 38,
    "key": "b",
    "text": "Генератори створюють елементи 'на льоту', list comprehensions створюють увесь список одразу в пам'яті."
  }
},
{
  "model": "interview_app.option",
  "pk": 114,
  "fields": {
    "question": 38,
    "key": "c",
    "text": "Генератори використовуються для сортування, list comprehensions — ні."
  }
},
{
  "model": "interview_app.option",
  "pk": 115,
  "fields": {
    "question": 39,
    "key": "a",
    "text": "Класи, які описують об'єкти."
  }
},
{
  "model": "interview_app.option",
  "pk": 116,
  "fields": {
    "question": 39,
    "key": "b",
    "text": "Блок коду, що виконує завдання і може бути викликаний з різних частин програми."
  }
},
{
  "model": "interview_app.option",
  "pk": 117,
  "fields": {
    "question": 39,
    "key": "c",
    "text": "Змінні, які зберігають числа."
  }
},
{
  "model": "interview_app.option",
  "pk": 118,
  "fields": {
    "question": 40,
    "key": "a",
    "text": "__init__ — це змінна класу."
  }
},
{
  "model": "interview_app.option",
  "pk": 119,
  "fields": {
    "question": 40,
    "key": "b",
    "text": "__init__ — це конструктор класу, який ініціалізує об'єкт при створенні."
  }
},
{
  "model": "interview_app.option",
  "pk": 120,
  "fields": {
    "question": 40,
    "key": "c",
    "text": "__init__ — це метод для видалення об'єктів."
  }
},
{
  "model": "interview_app.option",
  "pk": 121,
  "fields": {
    "question": 41,
    "key": "a",
    "text": "Конструктори реалізуються через функції outside класу."
  }
},
{
  "model": "interview_app.option",
  "pk": 122,
  "fields": {
    "question": 41,
    "key": "b",
    "text": "Використовують один __init__ і @classmethod або перевантаження з різною кількістю параметрів."
  }
},
{
  "model": "interview_app.option",
  "pk": 123,
  "fields": {
    "question": 41,
    "key": "c",
    "text": "Python підтримує кілька конструкторів за замовчуванням."
  }
},
{
  "model": "interview_app.option",
  "pk": 124,
  "fields": {
    "question": 42,
    "key": "a",
    "text": "Використовувати глобальні змінні."
  }
},
{
  "model": "interview_app.option",
  "pk": 125,
  "fields": {
    "question": 42,
    "key": "b",
    "text": "Змінювати об'єкт безпосередньо."
  }
},
{
  "model": "interview_app.option",
  "pk": 126,
  "fields": {
    "question": 42,
    "key": "c",
    "text": "Створювати копію об'єкта за допомогою copy або deepcopy."
  }
},
{
  "model": "interview_app.option",
  "pk": 127,
  "fields": {
    "question": 43,
    "key": "a",
    "text": "Немає жодних проблем із таким використанням."
  }
},
{
  "model": "interview_app.option",
  "pk": 128,
  "fields": {
    "question": 43,
    "key": "b",
    "text": "Може призвести до спільної зміни об'єкта між усіма викликами функції."
  }
},
{
  "model": "interview_app.option",
  "pk": 129,
  "fields": {
    "question": 43,
    "key": "c",
    "text": "Це викликає синтаксичну помилку."
  }
},
{
  "model": "interview_app.option",
  "pk": 130,
  "fields": {
    "question": 44,
    "key": "a",
    "text": "Методи для роботи з файлами."
  }
},
{
  "model": "interview_app.option",
  "pk": 131,
  "fields": {
    "question": 44,
    "key": "b",
    "text": "Змінні, які зберігають дані функції."
  }
},
{
  "model": "interview_app.option",
  "pk": 132,
  "fields": {
    "question": 44,
    "key": "c",
    "text": "Функції, які змінюють поведінку інших функцій, методів або класів без зміни їхнього коду."
  }
},
{
  "model": "interview_app.option",
  "pk": 133,
  "fields": {
    "question": 45,
    "key": "a",
    "text": "Проміжне представлення коду після компіляції, інструкції для віртуальної машини Python."
  }
},
{
  "model": "interview_app.option",
  "pk": 134,
  "fields": {
    "question": 45,
    "key": "b",
    "text": "Машинний код, який безпосередньо виконується процесором."
  }
},
{
  "model": "interview_app.option",
  "pk": 135,
  "fields": {
    "question": 45,
    "key": "c",
    "text": "Вихідний код у вигляді тексту, який ми пишемо."
  }
},
{
  "model": "interview_app.option",
  "pk": 136,
  "fields": {
    "question": 46,
    "key": "a",
    "text": "Синтаксичний аналіз, компіляція у байт-код, виконання байт-коду віртуальною машиною."
  }
},
{
  "model": "interview_app.option",
  "pk": 137,
  "fields": {
    "question": 46,
    "key": "b",
    "text": "Непосередньо машинний код виконується процесором."
  }
},
{
  "model": "interview_app.option",
  "pk": 138,
  "fields": {
    "question": 46,
    "key": "c",
    "text": "Файл запускається без попередньої компіляції."
  }
},
{
  "model": "interview_app.option",
  "pk": 139,
  "fields": {
    "question": 47,
    "key": "a",
    "text": "Відсутність документації і складність у використанні."
  }
},
{
  "model": "interview_app.option",
  "pk": 140,
  "fields": {
    "question": 47,
    "key": "b",
    "text": "Велика кількість готових компонентів, гарна документація, вбудована адміністративна панель."
  }
},
{
  "model": "interview_app.option",
  "pk": 141,
  "fields": {
    "question": 47,
    "key": "c",
    "text": "Використання виключно для наукових обчислень."
  }
},
{
  "model": "interview_app.option",
  "pk": 142,
  "fields": {
    "question": 48,
    "key": "a",
    "text": "Проблеми з асинхронністю, вищий поріг входження, громіздкість для простих проектів."
  }
},
{
  "model": "interview_app.option",
  "pk": 143,
  "fields": {
    "question": 48,
    "key": "b",
    "text": "Не підтримує роботу з формами."
  }
},
{
  "model": "interview_app.option",
  "pk": 144,
  "fields": {
    "question": 48,
    "key": "c",
    "text": "Немає підтримки баз даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 145,
  "fields": {
    "question": 49,
    "key": "a",
    "text": "Лише моделі та бази даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 146,
  "fields": {
    "question": 49,
    "key": "b",
    "text": "Система керування файлами і принтером."
  }
},
{
  "model": "interview_app.option",
  "pk": 147,
  "fields": {
    "question": 49,
    "key": "c",
    "text": "Моделі, ORM, представлення, URL-адреси, шаблони, адміністративна панель, міграції."
  }
},
{
  "model": "interview_app.option",
  "pk": 148,
  "fields": {
    "question": 50,
    "key": "a",
    "text": "Інструмент для роботи з графікою."
  }
},
{
  "model": "interview_app.option",
  "pk": 149,
  "fields": {
    "question": 50,
    "key": "b",
    "text": "Мова програмування, яка замінює Python."
  }
},
{
  "model": "interview_app.option",
  "pk": 150,
  "fields": {
    "question": 50,
    "key": "c",
    "text": "Об'єктно-реляційне відображення, що дозволяє працювати з БД через Python-код замість SQL."
  }
},
{
  "model": "interview_app.option",
  "pk": 151,
  "fields": {
    "question": 51,
    "key": "a",
    "text": "Python-класи, що описують структуру таблиць бази даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 152,
  "fields": {
    "question": 51,
    "key": "b",
    "text": "HTML-файли для відображення сторінок."
  }
},
{
  "model": "interview_app.option",
  "pk": 153,
  "fields": {
    "question": 51,
    "key": "c",
    "text": "Бібліотеки для роботи з мережею."
  }
},
{
  "model": "interview_app.option",
  "pk": 154,
  "fields": {
    "question": 52,
    "key": "a",
    "text": "copy() створює глибоку копію, deepcopy() — поверхневу."
  }
},
{
  "model": "interview_app.option",
  "pk": 155,
  "fields": {
    "question": 52,
    "key": "b",
    "text": "Обидві функції ідентичні."
  }
},
{
  "model": "interview_app.option",
  "pk": 156,
  "fields": {
    "question": 52,
    "key": "c",
    "text": "copy() створює поверхневу копію, deepcopy() — глибоку копію з новими об'єктами всередині."
  }
},
{
  "model": "interview_app.option",
  "pk": 157,
  "fields": {
    "question": 53,
    "key": "a",
    "text": "Типи даних, які існують лише під час виконання."
  }
},
{
  "model": "interview_app.option",
  "pk": 158,
  "fields": {
    "question": 53,
    "key": "b",
    "text": "Типи даних, що можна змінювати будь-коли."
  }
},
{
  "model": "interview_app.option",
  "pk": 159,
  "fields": {
    "question": 53,
    "key": "c",
    "text": "Типи даних, значення яких не можна змінювати після створення."
  }
},
{
  "model": "interview_app.option",
  "pk": 160,
  "fields": {
    "question": 54,
    "key": "a",
    "text": "Типи, які ніколи не змінюються."
  }
},
{
  "model": "interview_app.option",
  "pk": 161,
  "fields": {
    "question": 54,
    "key": "b",
    "text": "Типи, у яких можна змінювати вміст без створення нового об'єкта."
  }
},
{
  "model": "interview_app.option",
  "pk": 162,
  "fields": {
    "question": 54,
    "key": "c",
    "text": "Типи, які зберігаються тільки у стеку."
  }
},
{
  "model": "interview_app.option",
  "pk": 163,
  "fields": {
    "question": 55,
    "key": "a",
    "text": "Тип змінної."
  }
},
{
  "model": "interview_app.option",
  "pk": 164,
  "fields": {
    "question": 55,
    "key": "b",
    "text": "Інтерфейс командного рядка."
  }
},
{
  "model": "interview_app.option",
  "pk": 165,
  "fields": {
    "question": 55,
    "key": "c",
    "text": "Область пам'яті, де зберігаються всі об'єкти динамічно."
  }
},
{
  "model": "interview_app.option",
  "pk": 166,
  "fields": {
    "question": 56,
    "key": "a",
    "text": "Спеціальна функція для копіювання об'єктів."
  }
},
{
  "model": "interview_app.option",
  "pk": 167,
  "fields": {
    "question": 56,
    "key": "b",
    "text": "Простір імен, що містить відповідність імен об'єктам, створюється у стеку."
  }
},
{
  "model": "interview_app.option",
  "pk": 168,
  "fields": {
    "question": 56,
    "key": "c",
    "text": "Тип бази даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 169,
  "fields": {
    "question": 57,
    "key": "a",
    "text": "Об'єкт, що зберігає лише числа."
  }
},
{
  "model": "interview_app.option",
  "pk": 170,
  "fields": {
    "question": 57,
    "key": "b",
    "text": "Функція для виведення тексту."
  }
},
{
  "model": "interview_app.option",
  "pk": 171,
  "fields": {
    "question": 57,
    "key": "c",
    "text": "Структура даних, що містить інші об'єкти (списки, кортежі, словники, множини)."
  }
},
{
  "model": "interview_app.option",
  "pk": 172,
  "fields": {
    "question": 58,
    "key": "a",
    "text": "Factory — створює нові об'єкти при кожному виклику."
  }
},
{
  "model": "interview_app.option",
  "pk": 173,
  "fields": {
    "question": 58,
    "key": "b",
    "text": "Observer — слідкує за змінами об'єктів."
  }
},
{
  "model": "interview_app.option",
  "pk": 174,
  "fields": {
    "question": 58,
    "key": "c",
    "text": "Singleton — єдиний екземпляр класу, доступний глобально."
  }
},
{
  "model": "interview_app.option",
  "pk": 175,
  "fields": {
    "question": 59,
    "key": "a",
    "text": "Процес зміни типу даних одного об'єкта на інший тип."
  }
},
{
  "model": "interview_app.option",
  "pk": 176,
  "fields": {
    "question": 59,
    "key": "b",
    "text": "Спосіб створення нових функцій."
  }
},
{
  "model": "interview_app.option",
  "pk": 177,
  "fields": {
    "question": 59,
    "key": "c",
    "text": "Процес виконання коду без компіляції."
  }
},
{
  "model": "interview_app.option",
  "pk": 178,
  "fields": {
    "question": 60,
    "key": "a",
    "text": "Числовий тип із плаваючою крапкою."
  }
},
{
  "model": "interview_app.option",
  "pk": 179,
  "fields": {
    "question": 60,
    "key": "b",
    "text": "Функція для форматування рядків."
  }
},
{
  "model": "interview_app.option",
  "pk": 180,
  "fields": {
    "question": 60,
    "key": "c",
    "text": "Тип даних, що використовується для умовних виразів і логічних операцій."
  }
},
{
  "model": "interview_app.option",
  "pk": 181,
  "fields": {
    "question": 61,
    "key": "a",
    "text": "Для роботи з рядками та текстом."
  }
},
{
  "model": "interview_app.option",
  "pk": 182,
  "fields": {
    "question": 61,
    "key": "b",
    "text": "Для роботи з мережевими з'єднаннями."
  }
},
{
  "model": "interview_app.option",
  "pk": 183,
  "fields": {
    "question": 61,
    "key": "c",
    "text": "Для точних арифметичних операцій із числами з плаваючою комою, уникаючи похибок float."
  }
},
{
  "model": "interview_app.option",
  "pk": 184,
  "fields": {
    "question": 62,
    "key": "a",
    "text": "== перевіряє тип, is — виконує арифметичні операції, isinstance() порівнює значення."
  }
},
{
  "model": "interview_app.option",
  "pk": 185,
  "fields": {
    "question": 62,
    "key": "b",
    "text": "Всі три виконують однакові функції."
  }
},
{
  "model": "interview_app.option",
  "pk": 186,
  "fields": {
    "question": 62,
    "key": "c",
    "text": "== порівнює значення, is — ідентичність об'єктів, isinstance() перевіряє тип."
  }
},
{
  "model": "interview_app.option",
  "pk": 187,
  "fields": {
    "question": 63,
    "key": "a",
    "text": "Спосіб вказати очікувані типи аргументів і результатів функцій для кращої підтримки коду."
  }
},
{
  "model": "interview_app.option",
  "pk": 188,
  "fields": {
    "question": 63,
    "key": "b",
    "text": "Механізм автоматичного запуску тестів."
  }
},
{
  "model": "interview_app.option",
  "pk": 189,
  "fields": {
    "question": 63,
    "key": "c",
    "text": "Система керування пам’яттю."
  }
},
{
  "model": "interview_app.option",
  "pk": 190,
  "fields": {
    "question": 64,
    "key": "a",
    "text": "Бібліотека для роботи з базами даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 191,
  "fields": {
    "question": 64,
    "key": "b",
    "text": "Інструмент для статичної перевірки типів у Python."
  }
},
{
  "model": "interview_app.option",
  "pk": 192,
  "fields": {
    "question": 64,
    "key": "c",
    "text": "Фреймворк для розробки веб-додатків."
  }
},
{
  "model": "interview_app.option",
  "pk": 193,
  "fields": {
    "question": 65,
    "key": "a",
    "text": "Для роботи з файлами та введенням/виведенням."
  }
},
{
  "model": "interview_app.option",
  "pk": 194,
  "fields": {
    "question": 65,
    "key": "b",
    "text": "Для опису параметрів функцій як окремого типу, корисно для декораторів."
  }
},
{
  "model": "interview_app.option",
  "pk": 195,
  "fields": {
    "question": 65,
    "key": "c",
    "text": "Для керування пам’яттю."
  }
},
{
  "model": "interview_app.option",
  "pk": 196,
  "fields": {
    "question": 66,
    "key": "a",
    "text": "Тип контейнера для списків."
  }
},
{
  "model": "interview_app.option",
  "pk": 197,
  "fields": {
    "question": 66,
    "key": "b",
    "text": "Механізм для створення узагальнених класів і функцій із типобезпекою."
  }
},
{
  "model": "interview_app.option",
  "pk": 198,
  "fields": {
    "question": 66,
    "key": "c",
    "text": "Модуль для роботи з мережею."
  }
},
{
  "model": "interview_app.option",
  "pk": 199,
  "fields": {
    "question": 67,
    "key": "a",
    "text": "Для роботи з графікою."
  }
},
{
  "model": "interview_app.option",
  "pk": 200,
  "fields": {
    "question": 67,
    "key": "b",
    "text": "Для оголошення змінної типу в узагальнених класах і функціях."
  }
},
{
  "model": "interview_app.option",
  "pk": 201,
  "fields": {
    "question": 67,
    "key": "c",
    "text": "Для запуску асинхронних процесів."
  }
},
{
  "model": "interview_app.option",
  "pk": 202,
  "fields": {
    "question": 68,
    "key": "a",
    "text": "Для запуску Python-коду швидше за звичайний .py файл."
  }
},
{
  "model": "interview_app.option",
  "pk": 203,
  "fields": {
    "question": 68,
    "key": "b",
    "text": "Для надання анотацій типів і статичного аналізу без зміни основного коду."
  }
},
{
  "model": "interview_app.option",
  "pk": 204,
  "fields": {
    "question": 68,
    "key": "c",
    "text": "Для зберігання налаштувань IDE."
  }
},
{
  "model": "interview_app.option",
  "pk": 205,
  "fields": {
    "question": 69,
    "key": "a",
    "text": "Об'єкти для роботи з мережею."
  }
},
{
  "model": "interview_app.option",
  "pk": 206,
  "fields": {
    "question": 69,
    "key": "b",
    "text": "Ітерабельні об'єкти з підтримкою індексації і довжини."
  }
},
{
  "model": "interview_app.option",
  "pk": 207,
  "fields": {
    "question": 69,
    "key": "c",
    "text": "Типи, що не можна змінювати."
  }
},
{
  "model": "interview_app.option",
  "pk": 208,
  "fields": {
    "question": 70,
    "key": "a",
    "text": "Виконання арифметичних операцій."
  }
},
{
  "model": "interview_app.option",
  "pk": 209,
  "fields": {
    "question": 70,
    "key": "b",
    "text": "Запуск асинхронного коду."
  }
},
{
  "model": "interview_app.option",
  "pk": 210,
  "fields": {
    "question": 70,
    "key": "c",
    "text": "Перевірка наявності елемента (in, not in)."
  }
},
{
  "model": "interview_app.option",
  "pk": 211,
  "fields": {
    "question": 71,
    "key": "a",
    "text": "Механізм доступу до частин послідовностей через індекси."
  }
},
{
  "model": "interview_app.option",
  "pk": 212,
  "fields": {
    "question": 71,
    "key": "b",
    "text": "Інструмент для роботи з мережевими запитами."
  }
},
{
  "model": "interview_app.option",
  "pk": 213,
  "fields": {
    "question": 71,
    "key": "c",
    "text": "Функції для роботи з файлами."
  }
},
{
  "model": "interview_app.option",
  "pk": 214,
  "fields": {
    "question": 72,
    "key": "a",
    "text": "slice[start|stop|step], обов'язково з вертикальною рискою."
  }
},
{
  "model": "interview_app.option",
  "pk": 215,
  "fields": {
    "question": 72,
    "key": "b",
    "text": "sequence[start:stop:step], де step — необов’язковий крок."
  }
},
{
  "model": "interview_app.option",
  "pk": 216,
  "fields": {
    "question": 72,
    "key": "c",
    "text": "sequence(start, stop, step), де всі параметри обов’язкові."
  }
},
{
  "model": "interview_app.option",
  "pk": 217,
  "fields": {
    "question": 73,
    "key": "a",
    "text": "Так, через індексацію."
  }
},
{
  "model": "interview_app.option",
  "pk": 218,
  "fields": {
    "question": 73,
    "key": "b",
    "text": "Так, за допомогою .replace() напряму у рядку."
  }
},
{
  "model": "interview_app.option",
  "pk": 219,
  "fields": {
    "question": 73,
    "key": "c",
    "text": "Ні, рядки в Python незмінні (immutable)."
  }
},
{
  "model": "interview_app.option",
  "pk": 220,
  "fields": {
    "question": 74,
    "key": "a",
    "text": "Використати .decode()."
  }
},
{
  "model": "interview_app.option",
  "pk": 221,
  "fields": {
    "question": 74,
    "key": "b",
    "text": "Застосувати функцію bytes()."
  }
},
{
  "model": "interview_app.option",
  "pk": 222,
  "fields": {
    "question": 74,
    "key": "c",
    "text": "Викликати .encode() для перетворення в байти."
  }
},
{
  "model": "interview_app.option",
  "pk": 223,
  "fields": {
    "question": 75,
    "key": "a",
    "text": "Застосувати функцію chr()."
  }
},
{
  "model": "interview_app.option",
  "pk": 224,
  "fields": {
    "question": 75,
    "key": "b",
    "text": "Викликати .decode() на обʼєкті типу bytes."
  }
},
{
  "model": "interview_app.option",
  "pk": 225,
  "fields": {
    "question": 75,
    "key": "c",
    "text": "Викликати .encode() на рядку."
  }
},
{
  "model": "interview_app.option",
  "pk": 226,
  "fields": {
    "question": 76,
    "key": "a",
    "text": "Конкатенація через '+'."
  }
},
{
  "model": "interview_app.option",
  "pk": 227,
  "fields": {
    "question": 76,
    "key": "b",
    "text": "Тільки f-strings."
  }
},
{
  "model": "interview_app.option",
  "pk": 228,
  "fields": {
    "question": 76,
    "key": "c",
    "text": "Оператор %, метод format(), f-strings."
  }
},
{
  "model": "interview_app.option",
  "pk": 229,
  "fields": {
    "question": 77,
    "key": "a",
    "text": "Зміна значення рядка під час виконання."
  }
},
{
  "model": "interview_app.option",
  "pk": 230,
  "fields": {
    "question": 77,
    "key": "b",
    "text": "Оптимізація, коли однакові рядки мають спільну адресу в памʼяті."
  }
},
{
  "model": "interview_app.option",
  "pk": 231,
  "fields": {
    "question": 77,
    "key": "c",
    "text": "Кодування рядків у байти."
  }
},
{
  "model": "interview_app.option",
  "pk": 232,
  "fields": {
    "question": 78,
    "key": "a",
    "text": "Кортеж підтримує лише числа."
  }
},
{
  "model": "interview_app.option",
  "pk": 233,
  "fields": {
    "question": 78,
    "key": "b",
    "text": "Список змінний, кортеж — ні."
  }
},
{
  "model": "interview_app.option",
  "pk": 234,
  "fields": {
    "question": 78,
    "key": "c",
    "text": "Списки не можна ітерувати, кортежі — можна."
  }
},
{
  "model": "interview_app.option",
  "pk": 235,
  "fields": {
    "question": 79,
    "key": "a",
    "text": "Списки швидші за масиви."
  }
},
{
  "model": "interview_app.option",
  "pk": 236,
  "fields": {
    "question": 79,
    "key": "b",
    "text": "Масиви можуть містити лише один тип даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 237,
  "fields": {
    "question": 79,
    "key": "c",
    "text": "Списки зберігають елементи в памʼяті більш компактно."
  }
},
{
  "model": "interview_app.option",
  "pk": 238,
  "fields": {
    "question": 80,
    "key": "a",
    "text": "Використати list.sort()."
  }
},
{
  "model": "interview_app.option",
  "pk": 239,
  "fields": {
    "question": 80,
    "key": "b",
    "text": "Конвертувати список у множину через set()."
  }
},
{
  "model": "interview_app.option",
  "pk": 240,
  "fields": {
    "question": 80,
    "key": "c",
    "text": "Пройтись циклом і видалити дублі вручну."
  }
},
{
  "model": "interview_app.option",
  "pk": 241,
  "fields": {
    "question": 81,
    "key": "a",
    "text": "Функція для генерації випадкових чисел."
  }
},
{
  "model": "interview_app.option",
  "pk": 242,
  "fields": {
    "question": 81,
    "key": "b",
    "text": "Обʼєкт, що представляє послідовність чисел."
  }
},
{
  "model": "interview_app.option",
  "pk": 243,
  "fields": {
    "question": 81,
    "key": "c",
    "text": "Тип списку, який можна змінювати."
  }
},
{
  "model": "interview_app.option",
  "pk": 244,
  "fields": {
    "question": 82,
    "key": "a",
    "text": "Елемент за елементом, включно з типом і порядком."
  }
},
{
  "model": "interview_app.option",
  "pk": 245,
  "fields": {
    "question": 82,
    "key": "b",
    "text": "Лише за довжиною."
  }
},
{
  "model": "interview_app.option",
  "pk": 246,
  "fields": {
    "question": 82,
    "key": "c",
    "text": "Використовуючи хеш-функцію."
  }
},
{
  "model": "interview_app.option",
  "pk": 247,
  "fields": {
    "question": 83,
    "key": "a",
    "text": "any повертає False для будь-якого списку"
  }
},
{
  "model": "interview_app.option",
  "pk": 248,
  "fields": {
    "question": 83,
    "key": "b",
    "text": "Функції any та all перевіряють умови в ітерабельних обʼєктах. any повертає True, якщо хоча б один елемент істинний."
  }
},
{
  "model": "interview_app.option",
  "pk": 249,
  "fields": {
    "question": 83,
    "key": "c",
    "text": "all завжди повертає True"
  }
},
{
  "model": "interview_app.option",
  "pk": 250,
  "fields": {
    "question": 84,
    "key": "a",
    "text": "enumerate повертає просто список"
  }
},
{
  "model": "interview_app.option",
  "pk": 251,
  "fields": {
    "question": 84,
    "key": "b",
    "text": "enumerate повертає пари (індекс, елемент) для обʼєкта, що ітерується."
  }
},
{
  "model": "interview_app.option",
  "pk": 252,
  "fields": {
    "question": 84,
    "key": "c",
    "text": "enumerate повертає словник індексів"
  }
},
{
  "model": "interview_app.option",
  "pk": 253,
  "fields": {
    "question": 85,
    "key": "a",
    "text": "Обʼєкт має методи __hash__() та __eq__(), і його хеш не змінюється протягом життя."
  }
},
{
  "model": "interview_app.option",
  "pk": 254,
  "fields": {
    "question": 85,
    "key": "b",
    "text": "Обʼєкт має метод __str__()"
  }
},
{
  "model": "interview_app.option",
  "pk": 255,
  "fields": {
    "question": 85,
    "key": "c",
    "text": "Обʼєкт не має __init__()"
  }
},
{
  "model": "interview_app.option",
  "pk": 256,
  "fields": {
    "question": 86,
    "key": "a",
    "text": "Колекція з доступом за індексом"
  }
},
{
  "model": "interview_app.option",
  "pk": 257,
  "fields": {
    "question": 86,
    "key": "b",
    "text": "Список без повторень"
  }
},
{
  "model": "interview_app.option",
  "pk": 258,
  "fields": {
    "question": 86,
    "key": "c",
    "text": "Неупорядкована колекція хешованих обʼєктів без повторів."
  }
},
{
  "model": "interview_app.option",
  "pk": 259,
  "fields": {
    "question": 87,
    "key": "a",
    "text": "Невпорядкована множина елементів"
  }
},
{
  "model": "interview_app.option",
  "pk": 260,
  "fields": {
    "question": 87,
    "key": "b",
    "text": "Масив з двома колонками"
  }
},
{
  "model": "interview_app.option",
  "pk": 261,
  "fields": {
    "question": 87,
    "key": "c",
    "text": "Хеш-таблиця для зберігання пар ключ-значення з унікальними ключами."
  }
},
{
  "model": "interview_app.option",
  "pk": 262,
  "fields": {
    "question": 88,
    "key": "a",
    "text": "float швидші"
  }
},
{
  "model": "interview_app.option",
  "pk": 263,
  "fields": {
    "question": 88,
    "key": "b",
    "text": "int(1) і float(1.0) не можна використовувати"
  }
},
{
  "model": "interview_app.option",
  "pk": 264,
  "fields": {
    "question": 88,
    "key": "c",
    "text": "int(1) і float(1.0) вважаються однаковими ключами, float небажані через похибку."
  }
},
{
  "model": "interview_app.option",
  "pk": 265,
  "fields": {
    "question": 89,
    "key": "a",
    "text": "Підхід, де всі змінні є глобальними"
  }
},
{
  "model": "interview_app.option",
  "pk": 266,
  "fields": {
    "question": 89,
    "key": "b",
    "text": "Парадигма, яка організовує програму навколо обʼєктів із атрибутами та методами"
  }
},
{
  "model": "interview_app.option",
  "pk": 267,
  "fields": {
    "question": 89,
    "key": "c",
    "text": "Методологія модульного тестування"
  }
},
{
  "model": "interview_app.option",
  "pk": 268,
  "fields": {
    "question": 90,
    "key": "a",
    "text": "Повний доступ до всіх даних обʼєкта"
  }
},
{
  "model": "interview_app.option",
  "pk": 269,
  "fields": {
    "question": 90,
    "key": "b",
    "text": "Процес створення копій обʼєктів"
  }
},
{
  "model": "interview_app.option",
  "pk": 270,
  "fields": {
    "question": 90,
    "key": "c",
    "text": "Приховування складності реалізації та показ лише суттєвої інформації"
  }
},
{
  "model": "interview_app.option",
  "pk": 271,
  "fields": {
    "question": 91,
    "key": "a",
    "text": "Обмеження доступу до частин об'єкта та захист даних від прямої зміни"
  }
},
{
  "model": "interview_app.option",
  "pk": 272,
  "fields": {
    "question": 91,
    "key": "b",
    "text": "Здатність обʼєкта змінювати свій тип"
  }
},
{
  "model": "interview_app.option",
  "pk": 273,
  "fields": {
    "question": 91,
    "key": "c",
    "text": "Наслідування функціональності інших класів"
  }
},
{
  "model": "interview_app.option",
  "pk": 274,
  "fields": {
    "question": 92,
    "key": "a",
    "text": "Метод перевірки типу обʼєкта"
  }
},
{
  "model": "interview_app.option",
  "pk": 275,
  "fields": {
    "question": 92,
    "key": "b",
    "text": "Виконання коду кілька разів у циклі"
  }
},
{
  "model": "interview_app.option",
  "pk": 276,
  "fields": {
    "question": 92,
    "key": "c",
    "text": "Механізм, за якого один клас може отримувати атрибути й методи іншого"
  }
},
{
  "model": "interview_app.option",
  "pk": 277,
  "fields": {
    "question": 93,
    "key": "a",
    "text": "Розширення бази даних класів"
  }
},
{
  "model": "interview_app.option",
  "pk": 278,
  "fields": {
    "question": 93,
    "key": "b",
    "text": "Можливість виконувати один і той самий інтерфейс для різних типів об'єктів"
  }
},
{
  "model": "interview_app.option",
  "pk": 279,
  "fields": {
    "question": 93,
    "key": "c",
    "text": "Сховище типів даних"
  }
},
{
  "model": "interview_app.option",
  "pk": 280,
  "fields": {
    "question": 94,
    "key": "a",
    "text": "Клас — це приклад готового обʼєкта"
  }
},
{
  "model": "interview_app.option",
  "pk": 281,
  "fields": {
    "question": 94,
    "key": "b",
    "text": "Обʼєкт — це шаблон класу"
  }
},
{
  "model": "interview_app.option",
  "pk": 282,
  "fields": {
    "question": 94,
    "key": "c",
    "text": "Клас — це шаблон, а обʼєкт — це конкретна реалізація цього шаблону"
  }
},
{
  "model": "interview_app.option",
  "pk": 283,
  "fields": {
    "question": 95,
    "key": "a",
    "text": "Посилання на поточний обʼєкт класу"
  }
},
{
  "model": "interview_app.option",
  "pk": 284,
  "fields": {
    "question": 95,
    "key": "b",
    "text": "Це змінна для зберігання даних користувача"
  }
},
{
  "model": "interview_app.option",
  "pk": 285,
  "fields": {
    "question": 95,
    "key": "c",
    "text": "Це імʼя модуля"
  }
},
{
  "model": "interview_app.option",
  "pk": 286,
  "fields": {
    "question": 96,
    "key": "a",
    "text": "Конструктор, який викликається під час створення обʼєкта і ініціалізує його стан"
  }
},
{
  "model": "interview_app.option",
  "pk": 287,
  "fields": {
    "question": 96,
    "key": "b",
    "text": "Спеціальний метод для перевірки типу"
  }
},
{
  "model": "interview_app.option",
  "pk": 288,
  "fields": {
    "question": 96,
    "key": "c",
    "text": "Метод для видалення обʼєкта"
  }
},
{
  "model": "interview_app.option",
  "pk": 289,
  "fields": {
    "question": 97,
    "key": "a",
    "text": "__new__ ініціалізує обʼєкт, __init__ створює його; __init__ викликається першою"
  }
},
{
  "model": "interview_app.option",
  "pk": 290,
  "fields": {
    "question": 97,
    "key": "b",
    "text": "Обидва методи роблять те саме і викликаються одночасно"
  }
},
{
  "model": "interview_app.option",
  "pk": 291,
  "fields": {
    "question": 97,
    "key": "c",
    "text": "__new__ створює обʼєкт, __init__ ініціалізує його; __new__ викликається першою, потім __init__"
  }
},
{
  "model": "interview_app.option",
  "pk": 292,
  "fields": {
    "question": 98,
    "key": "a",
    "text": "Імʼя модуля"
  }
},
{
  "model": "interview_app.option",
  "pk": 293,
  "fields": {
    "question": 98,
    "key": "b",
    "text": "Ключове слово, яке посилається на поточний обʼєкт класу"
  }
},
{
  "model": "interview_app.option",
  "pk": 294,
  "fields": {
    "question": 98,
    "key": "c",
    "text": "Змінна для зберігання даних користувача"
  }
},
{
  "model": "interview_app.option",
  "pk": 295,
  "fields": {
    "question": 99,
    "key": "a",
    "text": "Використовуючи print() без параметрів"
  }
},
{
  "model": "interview_app.option",
  "pk": 296,
  "fields": {
    "question": 99,
    "key": "b",
    "text": "За допомогою функції dir() та поля __dict__; також можна використовувати hasattr(), getattr(), setattr(), delattr()"
  }
},
{
  "model": "interview_app.option",
  "pk": 297,
  "fields": {
    "question": 99,
    "key": "c",
    "text": "Тільки через __str__"
  }
},
{
  "model": "interview_app.option",
  "pk": 298,
  "fields": {
    "question": 100,
    "key": "a",
    "text": "Методи для роботи з базами даних"
  }
},
{
  "model": "interview_app.option",
  "pk": 299,
  "fields": {
    "question": 100,
    "key": "b",
    "text": "Методи, імена яких починаються і закінчуються подвійним підкресленням; дозволяють змінювати поведінку обʼєкта з операторами і вбудованими функціями"
  }
},
{
  "model": "interview_app.option",
  "pk": 300,
  "fields": {
    "question": 100,
    "key": "c",
    "text": "Просто звичайні методи класу"
  }
},
{
  "model": "interview_app.option",
  "pk": 301,
  "fields": {
    "question": 101,
    "key": "a",
    "text": "__str__ і __repr__ однакові"
  }
},
{
  "model": "interview_app.option",
  "pk": 302,
  "fields": {
    "question": 101,
    "key": "b",
    "text": "__repr__ повертає рядок для розробника, __str__ — для користувача; __str__ викликається функцією print()"
  }
},
{
  "model": "interview_app.option",
  "pk": 303,
  "fields": {
    "question": 101,
    "key": "c",
    "text": "__repr__ використовується для арифметичних операцій"
  }
},
{
  "model": "interview_app.option",
  "pk": 304,
  "fields": {
    "question": 102,
    "key": "a",
    "text": "__getattr__ викликається, коли атрибут відсутній; __getattribute__ викликається при будь-якому доступі до атрибуту"
  }
},
{
  "model": "interview_app.option",
  "pk": 305,
  "fields": {
    "question": 102,
    "key": "b",
    "text": "__getattr__ не існує в Python"
  }
},
{
  "model": "interview_app.option",
  "pk": 306,
  "fields": {
    "question": 102,
    "key": "c",
    "text": "Обидва викликаються одночасно"
  }
},
{
  "model": "interview_app.option",
  "pk": 307,
  "fields": {
    "question": 103,
    "key": "a",
    "text": "Повне імʼя обʼєкта з урахуванням вкладеності (класи, функції)"
  }
},
{
  "model": "interview_app.option",
  "pk": 308,
  "fields": {
    "question": 103,
    "key": "b",
    "text": "Назва модуля"
  }
},
{
  "model": "interview_app.option",
  "pk": 309,
  "fields": {
    "question": 103,
    "key": "c",
    "text": "Коротке імʼя функції"
  }
},
{
  "model": "interview_app.option",
  "pk": 310,
  "fields": {
    "question": 104,
    "key": "a",
    "text": "За допомогою функції super()"
  }
},
{
  "model": "interview_app.option",
  "pk": 311,
  "fields": {
    "question": 104,
    "key": "b",
    "text": "Через виклик __init__() напряму"
  }
},
{
  "model": "interview_app.option",
  "pk": 312,
  "fields": {
    "question": 104,
    "key": "c",
    "text": "Немає способу посилатися на батьківський клас"
  }
},
{
  "model": "interview_app.option",
  "pk": 313,
  "fields": {
    "question": 105,
    "key": "a",
    "text": "Ні, можна успадковувати лише від одного класу"
  }
},
{
  "model": "interview_app.option",
  "pk": 314,
  "fields": {
    "question": 105,
    "key": "b",
    "text": "Так, Python підтримує множинне наслідування"
  }
},
{
  "model": "interview_app.option",
  "pk": 315,
  "fields": {
    "question": 105,
    "key": "c",
    "text": "Тільки через зовнішні бібліотеки"
  }
},
{
  "model": "interview_app.option",
  "pk": 316,
  "fields": {
    "question": 106,
    "key": "a",
    "text": "Метод запуску класу"
  }
},
{
  "model": "interview_app.option",
  "pk": 317,
  "fields": {
    "question": 106,
    "key": "b",
    "text": "Порядок пошуку методу в ієрархії класів, який визначає, який метод буде викликано"
  }
},
{
  "model": "interview_app.option",
  "pk": 318,
  "fields": {
    "question": 106,
    "key": "c",
    "text": "Інструмент для автоматичного тестування"
  }
},
{
  "model": "interview_app.option",
  "pk": 319,
  "fields": {
    "question": 107,
    "key": "a",
    "text": "Помилка компіляції при наслідуванні від двох класів"
  }
},
{
  "model": "interview_app.option",
  "pk": 320,
  "fields": {
    "question": 107,
    "key": "b",
    "text": "Проблема, що виникає при циклічних посиланнях між обʼєктами"
  }
},
{
  "model": "interview_app.option",
  "pk": 321,
  "fields": {
    "question": 107,
    "key": "c",
    "text": "Проблема неоднозначності при ромбовидному успадкуванні, коли клас має два батьків, що успадковують від одного предка; у Python вирішується через MRO"
  }
},
{
  "model": "interview_app.option",
  "pk": 322,
  "fields": {
    "question": 108,
    "key": "a",
    "text": "Класи з великою кількістю методів"
  }
},
{
  "model": "interview_app.option",
  "pk": 323,
  "fields": {
    "question": 108,
    "key": "b",
    "text": "Головні базові класи в ієрархії"
  }
},
{
  "model": "interview_app.option",
  "pk": 324,
  "fields": {
    "question": 108,
    "key": "c",
    "text": "Допоміжні класи для додавання функціональності до інших класів, які не призначені для самостійного використання"
  }
},
{
  "model": "interview_app.option",
  "pk": 325,
  "fields": {
    "question": 109,
    "key": "a",
    "text": "Класи, які не можна інстанціювати безпосередньо, і методи, що не мають реалізації та мають бути реалізовані у нащадках"
  }
},
{
  "model": "interview_app.option",
  "pk": 326,
  "fields": {
    "question": 109,
    "key": "b",
    "text": "Класи з реалізованими всіма методами"
  }
},
{
  "model": "interview_app.option",
  "pk": 327,
  "fields": {
    "question": 109,
    "key": "c",
    "text": "Класи для збереження констант"
  }
},
{
  "model": "interview_app.option",
  "pk": 328,
  "fields": {
    "question": 110,
    "key": "a",
    "text": "True, бо object() має перевизначений __eq__"
  }
},
{
  "model": "interview_app.option",
  "pk": 329,
  "fields": {
    "question": 110,
    "key": "b",
    "text": "False, бо кожен object() створює унікальний обʼєкт з власним id"
  }
},
{
  "model": "interview_app.option",
  "pk": 330,
  "fields": {
    "question": 110,
    "key": "c",
    "text": "True, бо обʼєкти однакові за типом"
  }
},
{
  "model": "interview_app.option",
  "pk": 331,
  "fields": {
    "question": 111,
    "key": "a",
    "text": "Метод для створення слотів памʼяті"
  }
},
{
  "model": "interview_app.option",
  "pk": 332,
  "fields": {
    "question": 111,
    "key": "b",
    "text": "Функція для списку атрибутів"
  }
},
{
  "model": "interview_app.option",
  "pk": 333,
  "fields": {
    "question": 111,
    "key": "c",
    "text": "Атрибут класу, який фіксує набір полів екземпляра, економить памʼять і забороняє додавання нових атрибутів"
  }
},
{
  "model": "interview_app.option",
  "pk": 334,
  "fields": {
    "question": 112,
    "key": "a",
    "text": "Одне підкреслення — захищений атрибут (угода), два підкреслення — приватний (name mangling)"
  }
},
{
  "model": "interview_app.option",
  "pk": 335,
  "fields": {
    "question": 112,
    "key": "b",
    "text": "Публічні та захищені атрибути"
  }
},
{
  "model": "interview_app.option",
  "pk": 336,
  "fields": {
    "question": 112,
    "key": "c",
    "text": "Методи класу"
  }
},
{
  "model": "interview_app.option",
  "pk": 337,
  "fields": {
    "question": 113,
    "key": "a",
    "text": "Жорстка типізація в Python"
  }
},
{
  "model": "interview_app.option",
  "pk": 338,
  "fields": {
    "question": 113,
    "key": "b",
    "text": "Концепція, коли важливі не тип обʼєкта, а його поведінка (наявність потрібних методів)"
  }
},
{
  "model": "interview_app.option",
  "pk": 339,
  "fields": {
    "question": 113,
    "key": "c",
    "text": "Типізація за імʼям класу"
  }
},
{
  "model": "interview_app.option",
  "pk": 340,
  "fields": {
    "question": 114,
    "key": "a",
    "text": "Зміна поведінки стандартних операторів через реалізацію магічних методів (__add__, __eq__ тощо)"
  }
},
{
  "model": "interview_app.option",
  "pk": 341,
  "fields": {
    "question": 114,
    "key": "b",
    "text": "Створення нових операторів"
  }
},
{
  "model": "interview_app.option",
  "pk": 342,
  "fields": {
    "question": 114,
    "key": "c",
    "text": "Обмеження використання операторів"
  }
},
{
  "model": "interview_app.option",
  "pk": 343,
  "fields": {
    "question": 115,
    "key": "a",
    "text": "Викликати type('ІмʼяКласу', (базові_класи,), {'атрибут': значення})"
  }
},
{
  "model": "interview_app.option",
  "pk": 344,
  "fields": {
    "question": 115,
    "key": "b",
    "text": "Використати def class()"
  }
},
{
  "model": "interview_app.option",
  "pk": 345,
  "fields": {
    "question": 115,
    "key": "c",
    "text": "Через метаклас __metaclass__"
  }
},
{
  "model": "interview_app.option",
  "pk": 346,
  "fields": {
    "question": 116,
    "key": "a",
    "text": "Обидва працюють однаково"
  }
},
{
  "model": "interview_app.option",
  "pk": 347,
  "fields": {
    "question": 116,
    "key": "b",
    "text": "@classmethod приймає cls як перший аргумент, @staticmethod не приймає жодного неявного аргументу"
  }
},
{
  "model": "interview_app.option",
  "pk": 348,
  "fields": {
    "question": 116,
    "key": "c",
    "text": "@staticmethod приймає self"
  }
},
{
  "model": "interview_app.option",
  "pk": 349,
  "fields": {
    "question": 117,
    "key": "a",
    "text": "Налаштування поведінки issubclass() в абстрактних базових класах"
  }
},
{
  "model": "interview_app.option",
  "pk": 350,
  "fields": {
    "question": 117,
    "key": "b",
    "text": "Для зміни поведінки __init__"
  }
},
{
  "model": "interview_app.option",
  "pk": 351,
  "fields": {
    "question": 117,
    "key": "c",
    "text": "Для виклику суперкласу"
  }
},
{
  "model": "interview_app.option",
  "pk": 352,
  "fields": {
    "question": 118,
    "key": "a",
    "text": "Атрибут класу"
  }
},
{
  "model": "interview_app.option",
  "pk": 353,
  "fields": {
    "question": 118,
    "key": "b",
    "text": "Декоратор, що перетворює метод на керований атрибут із getter, setter, deleter"
  }
},
{
  "model": "interview_app.option",
  "pk": 354,
  "fields": {
    "question": 118,
    "key": "c",
    "text": "Метод класу"
  }
},
{
  "model": "interview_app.option",
  "pk": 355,
  "fields": {
    "question": 119,
    "key": "a",
    "text": "Обʼєкт із методами __get__(), __set__() або __delete__(), який керує доступом до атрибутів класу"
  }
},
{
  "model": "interview_app.option",
  "pk": 356,
  "fields": {
    "question": 119,
    "key": "b",
    "text": "Метод для створення властивостей"
  }
},
{
  "model": "interview_app.option",
  "pk": 357,
  "fields": {
    "question": 119,
    "key": "c",
    "text": "Тип даних"
  }
},
{
  "model": "interview_app.option",
  "pk": 358,
  "fields": {
    "question": 120,
    "key": "a",
    "text": "Для створення внутрішніх API у бібліотеках та фреймворках, де потрібно інкапсулювати логіку доступу до атрибутів та повторно її використовувати"
  }
},
{
  "model": "interview_app.option",
  "pk": 359,
  "fields": {
    "question": 120,
    "key": "b",
    "text": "Для одноразових рішень у бізнес-логіці"
  }
},
{
  "model": "interview_app.option",
  "pk": 360,
  "fields": {
    "question": 120,
    "key": "c",
    "text": "Для простого зберігання даних у класах"
  }
},
{
  "model": "interview_app.option",
  "pk": 361,
  "fields": {
    "question": 121,
    "key": "a",
    "text": "Дескриптори публічні та приватні"
  }
},
{
  "model": "interview_app.option",
  "pk": 362,
  "fields": {
    "question": 121,
    "key": "b",
    "text": "Дескриптори функціональні та нефункціональні"
  }
},
{
  "model": "interview_app.option",
  "pk": 363,
  "fields": {
    "question": 121,
    "key": "c",
    "text": "Дескриптори даних (мають __set__ або __delete__) та дескриптори не-даних (лише __get__)"
  }
},
{
  "model": "interview_app.option",
  "pk": 364,
  "fields": {
    "question": 122,
    "key": "a",
    "text": "__add__ та __sub__"
  }
},
{
  "model": "interview_app.option",
  "pk": 365,
  "fields": {
    "question": 122,
    "key": "b",
    "text": "__init__ та __call__"
  }
},
{
  "model": "interview_app.option",
  "pk": 366,
  "fields": {
    "question": 122,
    "key": "c",
    "text": "__get__(self, instance, owner), __set__(self, instance, value), __delete__(self, instance), __set_name__(self, owner, name)"
  }
},
{
  "model": "interview_app.option",
  "pk": 367,
  "fields": {
    "question": 123,
    "key": "a",
    "text": "Відсутність підтримки Python 3"
  }
},
{
  "model": "interview_app.option",
  "pk": 368,
  "fields": {
    "question": 123,
    "key": "b",
    "text": "Неможливість змінювати атрибути класу"
  }
},
{
  "model": "interview_app.option",
  "pk": 369,
  "fields": {
    "question": 123,
    "key": "c",
    "text": "Нескінченна рекурсія, спільний стан між екземплярами, циклічні посилання і витоки пам'яті"
  }
},
{
  "model": "interview_app.option",
  "pk": 370,
  "fields": {
    "question": 124,
    "key": "a",
    "text": "Класи для опису метаданих файлів"
  }
},
{
  "model": "interview_app.option",
  "pk": 371,
  "fields": {
    "question": 124,
    "key": "b",
    "text": "Звичайні класи з розширеною функціональністю"
  }
},
{
  "model": "interview_app.option",
  "pk": 372,
  "fields": {
    "question": 124,
    "key": "c",
    "text": "Класи, що визначають як створюються інші класи (клас класу), контролюючи їх створення і поведінку"
  }
},
{
  "model": "interview_app.option",
  "pk": 373,
  "fields": {
    "question": 125,
    "key": "a",
    "text": "type - це функція для перетворення типів"
  }
},
{
  "model": "interview_app.option",
  "pk": 374,
  "fields": {
    "question": 125,
    "key": "b",
    "text": "type - це змінна середовища Python"
  }
},
{
  "model": "interview_app.option",
  "pk": 375,
  "fields": {
    "question": 125,
    "key": "c",
    "text": "type(obj) повертає тип обʼєкта, type(name, bases, attrs) створює клас динамічно; пошук метакласу йде через __metaclass__ у класі, батьках, модулі, або за замовчуванням type"
  }
},
{
  "model": "interview_app.option",
  "pk": 376,
  "fields": {
    "question": 126,
    "key": "a",
    "text": "Для автоматизації створення класів у фреймворках і додавання спеціальної поведінки класам"
  }
},
{
  "model": "interview_app.option",
  "pk": 377,
  "fields": {
    "question": 126,
    "key": "b",
    "text": "Для реалізації інтерфейсів"
  }
},
{
  "model": "interview_app.option",
  "pk": 378,
  "fields": {
    "question": 126,
    "key": "c",
    "text": "Для створення екземплярів класів"
  }
},
{
  "model": "interview_app.option",
  "pk": 379,
  "fields": {
    "question": 127,
    "key": "a",
    "text": "Клас для обробки виключень"
  }
},
{
  "model": "interview_app.option",
  "pk": 380,
  "fields": {
    "question": 127,
    "key": "b",
    "text": "Тип даних для зберігання контексту виконання"
  }
},
{
  "model": "interview_app.option",
  "pk": 381,
  "fields": {
    "question": 127,
    "key": "c",
    "text": "Обʼєкт з методами __enter__ та __exit__, що керує виконанням коду у блоці with, гарантуючи дії перед та після нього"
  }
},
{
  "model": "interview_app.option",
  "pk": 382,
  "fields": {
    "question": 128,
    "key": "a",
    "text": "LEGB — порядок пошуку імен: Local, Enclosing, Global, Built-in; простори імен — словники імен обʼєктів для уникнення конфліктів"
  }
},
{
  "model": "interview_app.option",
  "pk": 383,
  "fields": {
    "question": 128,
    "key": "b",
    "text": "Простори імен — це класи в Python"
  }
},
{
  "model": "interview_app.option",
  "pk": 384,
  "fields": {
    "question": 128,
    "key": "c",
    "text": "LEGB — це набір типів даних"
  }
},
{
  "model": "interview_app.option",
  "pk": 385,
  "fields": {
    "question": 129,
    "key": "a",
    "text": "Обидва ключові слова заборонені в Python"
  }
},
{
  "model": "interview_app.option",
  "pk": 386,
  "fields": {
    "question": 129,
    "key": "b",
    "text": "global створює нову змінну, nonlocal — видаляє змінну"
  }
},
{
  "model": "interview_app.option",
  "pk": 387,
  "fields": {
    "question": 129,
    "key": "c",
    "text": "Локальні — всередині функції, глобальні — на рівні модуля; global дозволяє змінювати глобальні змінні у функції, nonlocal — змінювати змінні зовнішніх, але не глобальних областей"
  }
},
{
  "model": "interview_app.option",
  "pk": 388,
  "fields": {
    "question": 130,
    "key": "a",
    "text": "Файл .py з кодом Python, що містить функції, класи, змінні для структурування і повторного використання коду"
  }
},
{
  "model": "interview_app.option",
  "pk": 389,
  "fields": {
    "question": 130,
    "key": "b",
    "text": "Змінна середовища"
  }
},
{
  "model": "interview_app.option",
  "pk": 390,
  "fields": {
    "question": 130,
    "key": "c",
    "text": "Пакет бібліотек"
  }
},
{
  "model": "interview_app.option",
  "pk": 391,
  "fields": {
    "question": 131,
    "key": "a",
    "text": "Змінна __name__ модуля; __main__, якщо виконується як головний скрипт"
  }
},
{
  "model": "interview_app.option",
  "pk": 392,
  "fields": {
    "question": 131,
    "key": "b",
    "text": "Через глобальну змінну MODULE"
  }
},
{
  "model": "interview_app.option",
  "pk": 393,
  "fields": {
    "question": 131,
    "key": "c",
    "text": "Функція module_name()"
  }
},
{
  "model": "interview_app.option",
  "pk": 394,
  "fields": {
    "question": 132,
    "key": "a",
    "text": "Завантажує всі файли з директорії проекту"
  }
},
{
  "model": "interview_app.option",
  "pk": 395,
  "fields": {
    "question": 132,
    "key": "b",
    "text": "Шукає у sys.path: поточна директорія, PYTHONPATH, стандартні директорії бібліотек"
  }
},
{
  "model": "interview_app.option",
  "pk": 396,
  "fields": {
    "question": 132,
    "key": "c",
    "text": "Імпортує лише стандартні бібліотеки"
  }
},
{
  "model": "interview_app.option",
  "pk": 397,
  "fields": {
    "question": 133,
    "key": "a",
    "text": "Файл .py з декількома класами"
  }
},
{
  "model": "interview_app.option",
  "pk": 398,
  "fields": {
    "question": 133,
    "key": "b",
    "text": "Зовнішня бібліотека"
  }
},
{
  "model": "interview_app.option",
  "pk": 399,
  "fields": {
    "question": 133,
    "key": "c",
    "text": "Директорія з файлом __init__.py, що містить модулі та підпакети для організації коду"
  }
},
{
  "model": "interview_app.option",
  "pk": 400,
  "fields": {
    "question": 134,
    "key": "a",
    "text": "Функція для завантаження файлів"
  }
},
{
  "model": "interview_app.option",
  "pk": 401,
  "fields": {
    "question": 134,
    "key": "b",
    "text": "Оператор для визначення класів"
  }
},
{
  "model": "interview_app.option",
  "pk": 402,
  "fields": {
    "question": 134,
    "key": "c",
    "text": "Ключове слово для підключення модулів; import module, from module import name, import module as alias, from module import *"
  }
},
{
  "model": "interview_app.option",
  "pk": 403,
  "fields": {
    "question": 135,
    "key": "a",
    "text": "Вони заборонені"
  }
},
{
  "model": "interview_app.option",
  "pk": 404,
  "fields": {
    "question": 135,
    "key": "b",
    "text": "Немає різниці"
  }
},
{
  "model": "interview_app.option",
  "pk": 405,
  "fields": {
    "question": 135,
    "key": "c",
    "text": "import package.item імпортує модуль або підпакет; from package import item може імпортувати будь-яке імʼя, визначене в __init__.py"
  }
},
{
  "model": "interview_app.option",
  "pk": 406,
  "fields": {
    "question": 136,
    "key": "a",
    "text": "Подія, що порушує нормальний хід виконання програми, зазвичай помилка; представлена обʼєктами винятків"
  }
},
{
  "model": "interview_app.option",
  "pk": 407,
  "fields": {
    "question": 136,
    "key": "b",
    "text": "Спеціальний тип функції"
  }
},
{
  "model": "interview_app.option",
  "pk": 408,
  "fields": {
    "question": 136,
    "key": "c",
    "text": "Змінна для зберігання помилок"
  }
},
{
  "model": "interview_app.option",
  "pk": 409,
  "fields": {
    "question": 137,
    "key": "a",
    "text": "Конструкція try...except...else...finally для виконання коду та обробки помилок"
  }
},
{
  "model": "interview_app.option",
  "pk": 410,
  "fields": {
    "question": 137,
    "key": "b",
    "text": "Функція handle_exception()"
  }
},
{
  "model": "interview_app.option",
  "pk": 411,
  "fields": {
    "question": 137,
    "key": "c",
    "text": "Оператор catch"
  }
},
{
  "model": "interview_app.option",
  "pk": 412,
  "fields": {
    "question": 138,
    "key": "a",
    "text": "Виняток автоматично виправляється"
  }
},
{
  "model": "interview_app.option",
  "pk": 413,
  "fields": {
    "question": 138,
    "key": "b",
    "text": "Програма ігнорує помилку"
  }
},
{
  "model": "interview_app.option",
  "pk": 414,
  "fields": {
    "question": 138,
    "key": "c",
    "text": "Виняток підніметься в стеку викликів, і якщо не буде оброблений, програма припиниться з трасуванням стека"
  }
},
{
  "model": "interview_app.option",
  "pk": 415,
  "fields": {
    "question": 139,
    "key": "a",
    "text": "Використати return"
  }
},
{
  "model": "interview_app.option",
  "pk": 416,
  "fields": {
    "question": 139,
    "key": "b",
    "text": "Викликати exit()"
  }
},
{
  "model": "interview_app.option",
  "pk": 417,
  "fields": {
    "question": 139,
    "key": "c",
    "text": "У блоці except виконати дії, потім викликати raise без аргументів"
  }
},
{
  "model": "interview_app.option",
  "pk": 418,
  "fields": {
    "question": 140,
    "key": "a",
    "text": "Для гарантованого виконання коду очищення, незалежно від винятків, які передаються далі"
  }
},
{
  "model": "interview_app.option",
  "pk": 419,
  "fields": {
    "question": 140,
    "key": "b",
    "text": "Для перезапуску програми"
  }
},
{
  "model": "interview_app.option",
  "pk": 420,
  "fields": {
    "question": 140,
    "key": "c",
    "text": "Для ігнорування помилок"
  }
},
{
  "model": "interview_app.option",
  "pk": 421,
  "fields": {
    "question": 141,
    "key": "a",
    "text": "Цикл виклику функцій"
  }
},
{
  "model": "interview_app.option",
  "pk": 422,
  "fields": {
    "question": 141,
    "key": "b",
    "text": "Набір винятків"
  }
},
{
  "model": "interview_app.option",
  "pk": 423,
  "fields": {
    "question": 141,
    "key": "c",
    "text": "Звʼязок винятків, коли новий виникає під час обробки іншого, збереження контексту (__context__ та __cause__)"
  }
},
{
  "model": "interview_app.option",
  "pk": 424,
  "fields": {
    "question": 142,
    "key": "a",
    "text": "Виконується перед try"
  }
},
{
  "model": "interview_app.option",
  "pk": 425,
  "fields": {
    "question": 142,
    "key": "b",
    "text": "Виконується завжди"
  }
},
{
  "model": "interview_app.option",
  "pk": 426,
  "fields": {
    "question": 142,
    "key": "c",
    "text": "Виконується, якщо у try не виникло винятків, щоб відокремити код успішного виконання"
  }
},
{
  "model": "interview_app.option",
  "pk": 427,
  "fields": {
    "question": 143,
    "key": "a",
    "text": "Викидає виняток"
  }
},
{
  "model": "interview_app.option",
  "pk": 428,
  "fields": {
    "question": 143,
    "key": "b",
    "text": "Перевіряє тип винятку"
  }
},
{
  "model": "interview_app.option",
  "pk": 429,
  "fields": {
    "question": 143,
    "key": "c",
    "text": "Ігнорує вказані винятки всередині блоку with, як альтернатива try...except...pass"
  }
},
{
  "model": "interview_app.option",
  "pk": 430,
  "fields": {
    "question": 144,
    "key": "a",
    "text": "Нічого"
  }
},
{
  "model": "interview_app.option",
  "pk": 431,
  "fields": {
    "question": 144,
    "key": "b",
    "text": "Лише рядок з повідомленням"
  }
},
{
  "model": "interview_app.option",
  "pk": 432,
  "fields": {
    "question": 144,
    "key": "c",
    "text": "Будь-яку кількість позиційних аргументів, зберігаються у .args як кортеж"
  }
},
{
  "model": "interview_app.option",
  "pk": 433,
  "fields": {
    "question": 145,
    "key": "a",
    "text": "Error, Warning, Exception"
  }
},
{
  "model": "interview_app.option",
  "pk": 434,
  "fields": {
    "question": 145,
    "key": "b",
    "text": "SystemError, UserError"
  }
},
{
  "model": "interview_app.option",
  "pk": 435,
  "fields": {
    "question": 145,
    "key": "c",
    "text": "BaseException, SystemExit, KeyboardInterrupt, Exception, ArithmeticError, LookupError, AttributeError, NameError, TypeError, ValueError, ImportError, RuntimeError"
  }
},
{
  "model": "interview_app.option",
  "pk": 436,
  "fields": {
    "question": 146,
    "key": "a",
    "text": "Ніколи не можна обробити"
  }
},
{
  "model": "interview_app.option",
  "pk": 437,
  "fields": {
    "question": 146,
    "key": "b",
    "text": "Завжди можна обробити у головному файлі"
  }
},
{
  "model": "interview_app.option",
  "pk": 438,
  "fields": {
    "question": 146,
    "key": "c",
    "text": "При імпорті модуля з синтаксичною помилкою або виконанні коду через eval() чи exec()"
  }
},
{
  "model": "interview_app.option",
  "pk": 439,
  "fields": {
    "question": 147,
    "key": "a",
    "text": "Так, успадковуючи від Exception або його нащадків; імена зазвичай закінчуються на Error"
  }
},
{
  "model": "interview_app.option",
  "pk": 440,
  "fields": {
    "question": 147,
    "key": "b",
    "text": "Ні, можна використовувати лише вбудовані"
  }
},
{
  "model": "interview_app.option",
  "pk": 441,
  "fields": {
    "question": 147,
    "key": "c",
    "text": "Так, але лише для системних помилок"
  }
},
{
  "model": "interview_app.option",
  "pk": 442,
  "fields": {
    "question": 148,
    "key": "a",
    "text": "Для сповіщення про не критичні проблеми; власне створюється успадкуванням від UserWarning"
  }
},
{
  "model": "interview_app.option",
  "pk": 443,
  "fields": {
    "question": 148,
    "key": "b",
    "text": "Для зупинки програми"
  }
},
{
  "model": "interview_app.option",
  "pk": 444,
  "fields": {
    "question": 148,
    "key": "c",
    "text": "Для обробки виключень"
  }
},
{
  "model": "interview_app.option",
  "pk": 445,
  "fields": {
    "question": 149,
    "key": "a",
    "text": "Для роботи з файлами"
  }
},
{
  "model": "interview_app.option",
  "pk": 446,
  "fields": {
    "question": 149,
    "key": "b",
    "text": "Для обробки винятків"
  }
},
{
  "model": "interview_app.option",
  "pk": 447,
  "fields": {
    "question": 149,
    "key": "c",
    "text": "Надає функції для генерації та обробки попереджень, які не є помилками, але корисні для повідомлення користувача (наприклад, застарілі функції)"
  }
},
{
  "model": "interview_app.option",
  "pk": 448,
  "fields": {
    "question": 150,
    "key": "a",
    "text": "Текстовий рядок"
  }
},
{
  "model": "interview_app.option",
  "pk": 449,
  "fields": {
    "question": 150,
    "key": "b",
    "text": "Об'єкт, який надає стандартизований API (read, write) для доступу до ресурсу, наприклад, файлу, сокету або буфера"
  }
},
{
  "model": "interview_app.option",
  "pk": 450,
  "fields": {
    "question": 150,
    "key": "c",
    "text": "Файл на диску"
  }
},
{
  "model": "interview_app.option",
  "pk": 451,
  "fields": {
    "question": 151,
    "key": "a",
    "text": "Текстові файли, буферизовані бінарні файли, небуферизовані (raw) бінарні файли"
  }
},
{
  "model": "interview_app.option",
  "pk": 452,
  "fields": {
    "question": 151,
    "key": "b",
    "text": "Файли і каталоги"
  }
},
{
  "model": "interview_app.option",
  "pk": 453,
  "fields": {
    "question": 151,
    "key": "c",
    "text": "Бінарні і текстові"
  }
},
{
  "model": "interview_app.option",
  "pk": 454,
  "fields": {
    "question": 152,
    "key": "a",
    "text": "Текстові працюють з рядками і автоматично кодують/декодують, бінарні працюють з байтами без перетворень"
  }
},
{
  "model": "interview_app.option",
  "pk": 455,
  "fields": {
    "question": 152,
    "key": "b",
    "text": "Текстові можна читати, бінарні — ні"
  }
},
{
  "model": "interview_app.option",
  "pk": 456,
  "fields": {
    "question": 152,
    "key": "c",
    "text": "Текстові завжди більші за бінарні"
  }
},
{
  "model": "interview_app.option",
  "pk": 457,
  "fields": {
    "question": 153,
    "key": "a",
    "text": "open() працює лише з текстовими файлами"
  }
},
{
  "model": "interview_app.option",
  "pk": 458,
  "fields": {
    "question": 153,
    "key": "b",
    "text": "open(file, mode='r', encoding=None) відкриває файл у заданому режимі (читання, запис, дозапис, бінарний чи текстовий)"
  }
},
{
  "model": "interview_app.option",
  "pk": 459,
  "fields": {
    "question": 153,
    "key": "c",
    "text": "open() створює новий файл завжди"
  }
},
{
  "model": "interview_app.option",
  "pk": 460,
  "fields": {
    "question": 154,
    "key": "a",
    "text": "Виклик методу close(), що зберігає буфер і звільняє ресурси; with автоматично закриває файл"
  }
},
{
  "model": "interview_app.option",
  "pk": 461,
  "fields": {
    "question": 154,
    "key": "b",
    "text": "Видалення файлу з диску"
  }
},
{
  "model": "interview_app.option",
  "pk": 462,
  "fields": {
    "question": 154,
    "key": "c",
    "text": "Перезапуск файлової системи"
  }
},
{
  "model": "interview_app.option",
  "pk": 463,
  "fields": {
    "question": 155,
    "key": "a",
    "text": "tell() читає файл, seek() записує"
  }
},
{
  "model": "interview_app.option",
  "pk": 464,
  "fields": {
    "question": 155,
    "key": "b",
    "text": "tell() повертає поточну позицію курсора, seek(offset, whence) змінює позицію курсора у файлі"
  }
},
{
  "model": "interview_app.option",
  "pk": 465,
  "fields": {
    "question": 155,
    "key": "c",
    "text": "Вони не використовуються у Python"
  }
},
{
  "model": "interview_app.option",
  "pk": 466,
  "fields": {
    "question": 156,
    "key": "a",
    "text": "Це класи для роботи з мережею"
  }
},
{
  "model": "interview_app.option",
  "pk": 467,
  "fields": {
    "question": 156,
    "key": "b",
    "text": "Це типи файлів на диску"
  }
},
{
  "model": "interview_app.option",
  "pk": 468,
  "fields": {
    "question": 156,
    "key": "c",
    "text": "Дають можливість працювати з рядками або байтами у пам'яті як з файловими об'єктами"
  }
},
{
  "model": "interview_app.option",
  "pk": 469,
  "fields": {
    "question": 157,
    "key": "a",
    "text": "Ні, треба викликати close вручну"
  }
},
{
  "model": "interview_app.option",
  "pk": 470,
  "fields": {
    "question": 157,
    "key": "b",
    "text": "Тільки для текстових файлів"
  }
},
{
  "model": "interview_app.option",
  "pk": 471,
  "fields": {
    "question": 157,
    "key": "c",
    "text": "Так, їх можна використовувати з конструкцією with, що автоматично закриває файл"
  }
},
{
  "model": "interview_app.option",
  "pk": 472,
  "fields": {
    "question": 158,
    "key": "a",
    "text": "Відновлення об'єкта з файлу"
  }
},
{
  "model": "interview_app.option",
  "pk": 473,
  "fields": {
    "question": 158,
    "key": "b",
    "text": "Перетворення об'єкта Python у формат для збереження або передачі (рядок, байти)"
  }
},
{
  "model": "interview_app.option",
  "pk": 474,
  "fields": {
    "question": 158,
    "key": "c",
    "text": "Створення нового об'єкта"
  }
},
{
  "model": "interview_app.option",
  "pk": 475,
  "fields": {
    "question": 159,
    "key": "a",
    "text": "dumps і loads працюють зі рядками, dump і load — з файловими об'єктами"
  }
},
{
  "model": "interview_app.option",
  "pk": 476,
  "fields": {
    "question": 159,
    "key": "b",
    "text": "load і loads серіалізують об'єкти"
  }
},
{
  "model": "interview_app.option",
  "pk": 477,
  "fields": {
    "question": 159,
    "key": "c",
    "text": "dumps створює файл, dump — рядок"
  }
},
{
  "model": "interview_app.option",
  "pk": 478,
  "fields": {
    "question": 160,
    "key": "a",
    "text": "Викидати помилку"
  }
},
{
  "model": "interview_app.option",
  "pk": 479,
  "fields": {
    "question": 160,
    "key": "b",
    "text": "Використовувати pickle або розширювати JSONEncoder/Decoder"
  }
},
{
  "model": "interview_app.option",
  "pk": 480,
  "fields": {
    "question": 160,
    "key": "c",
    "text": "Перетворити все у рядки вручну"
  }
},
{
  "model": "interview_app.option",
  "pk": 481,
  "fields": {
    "question": 161,
    "key": "a",
    "text": "Для роботи з JSON"
  }
},
{
  "model": "interview_app.option",
  "pk": 482,
  "fields": {
    "question": 161,
    "key": "b",
    "text": "Для роботи з файлами CSV"
  }
},
{
  "model": "interview_app.option",
  "pk": 483,
  "fields": {
    "question": 161,
    "key": "c",
    "text": "Для серіалізації та десеріалізації об'єктів Python у бінарному форматі"
  }
},
{
  "model": "interview_app.option",
  "pk": 484,
  "fields": {
    "question": 162,
    "key": "a",
    "text": "Послідовне виконання коду"
  }
},
{
  "model": "interview_app.option",
  "pk": 485,
  "fields": {
    "question": 162,
    "key": "b",
    "text": "Підхід, що дозволяє не блокувати програму під час довгих операцій, виконуючи інші завдання"
  }
},
{
  "model": "interview_app.option",
  "pk": 486,
  "fields": {
    "question": 162,
    "key": "c",
    "text": "Паралельне виконання на кількох ядрах"
  }
},
{
  "model": "interview_app.option",
  "pk": 487,
  "fields": {
    "question": 163,
    "key": "a",
    "text": "Потоки"
  }
},
{
  "model": "interview_app.option",
  "pk": 488,
  "fields": {
    "question": 163,
    "key": "b",
    "text": "Функції async def, які можуть призупиняти виконання та відновлювати його пізніше"
  }
},
{
  "model": "interview_app.option",
  "pk": 489,
  "fields": {
    "question": 163,
    "key": "c",
    "text": "Звичайні функції"
  }
},
{
  "model": "interview_app.option",
  "pk": 490,
  "fields": {
    "question": 164,
    "key": "a",
    "text": "За допомогою ключових слів async та await і бібліотеки asyncio"
  }
},
{
  "model": "interview_app.option",
  "pk": 491,
  "fields": {
    "question": 164,
    "key": "b",
    "text": "Через multiprocessing"
  }
},
{
  "model": "interview_app.option",
  "pk": 492,
  "fields": {
    "question": 164,
    "key": "c",
    "text": "Через багатопоточність"
  }
},
{
  "model": "interview_app.option",
  "pk": 493,
  "fields": {
    "question": 165,
    "key": "a",
    "text": "Інструмент для роботи з мережею"
  }
},
{
  "model": "interview_app.option",
  "pk": 494,
  "fields": {
    "question": 165,
    "key": "b",
    "text": "Стандартна бібліотека Python для асинхронного програмування з циклом подій"
  }
},
{
  "model": "interview_app.option",
  "pk": 495,
  "fields": {
    "question": 165,
    "key": "c",
    "text": "Модуль для роботи з файлами"
  }
},
{
  "model": "interview_app.option",
  "pk": 496,
  "fields": {
    "question": 166,
    "key": "a",
    "text": "async — для оголошення корутин, await — для очікування результату асинхронної операції"
  }
},
{
  "model": "interview_app.option",
  "pk": 497,
  "fields": {
    "question": 166,
    "key": "b",
    "text": "Синтаксис для створення класів"
  }
},
{
  "model": "interview_app.option",
  "pk": 498,
  "fields": {
    "question": 166,
    "key": "c",
    "text": "Ключові слова для багатопоточності"
  }
},
{
  "model": "interview_app.option",
  "pk": 499,
  "fields": {
    "question": 167,
    "key": "a",
    "text": "Процес ОС"
  }
},
{
  "model": "interview_app.option",
  "pk": 500,
  "fields": {
    "question": 167,
    "key": "b",
    "text": "Потік, що виконує код"
  }
},
{
  "model": "interview_app.option",
  "pk": 501,
  "fields": {
    "question": 167,
    "key": "c",
    "text": "Центральний механізм, що керує виконанням корутин, переключаючи контекст між ними"
  }
},
{
  "model": "interview_app.option",
  "pk": 502,
  "fields": {
    "question": 168,
    "key": "a",
    "text": "Засіб запису даних у файл"
  }
},
{
  "model": "interview_app.option",
  "pk": 503,
  "fields": {
    "question": 168,
    "key": "b",
    "text": "Механізм, що дозволяє одному потоку моніторити багато каналів вводу/виводу одночасно"
  }
},
{
  "model": "interview_app.option",
  "pk": 504,
  "fields": {
    "question": 168,
    "key": "c",
    "text": "Тип файлу"
  }
},
{
  "model": "interview_app.option",
  "pk": 505,
  "fields": {
    "question": 169,
    "key": "a",
    "text": "await виконує код у фоновому режимі"
  }
},
{
  "model": "interview_app.option",
  "pk": 506,
  "fields": {
    "question": 169,
    "key": "b",
    "text": "await запускає паралельні потоки"
  }
},
{
  "model": "interview_app.option",
  "pk": 507,
  "fields": {
    "question": 169,
    "key": "c",
    "text": "await призупиняє корутину, але якщо виклики послідовні, вони виконуються один за одним"
  }
},
{
  "model": "interview_app.option",
  "pk": 508,
  "fields": {
    "question": 170,
    "key": "a",
    "text": "asyncio.create_task, asyncio.gather, asyncio.TaskGroup"
  }
},
{
  "model": "interview_app.option",
  "pk": 509,
  "fields": {
    "question": 170,
    "key": "b",
    "text": "Запускати через multiprocessing"
  }
},
{
  "model": "interview_app.option",
  "pk": 510,
  "fields": {
    "question": 170,
    "key": "c",
    "text": "Через threading"
  }
},
{
  "model": "interview_app.option",
  "pk": 511,
  "fields": {
    "question": 171,
    "key": "a",
    "text": "Для створення потоків"
  }
},
{
  "model": "interview_app.option",
  "pk": 512,
  "fields": {
    "question": 171,
    "key": "b",
    "text": "Для синхронного виконання"
  }
},
{
  "model": "interview_app.option",
  "pk": 513,
  "fields": {
    "question": 171,
    "key": "c",
    "text": "Для запуску корутини як фонового завдання"
  }
},
{
  "model": "interview_app.option",
  "pk": 514,
  "fields": {
    "question": 172,
    "key": "a",
    "text": "Модуль для роботи з потоками"
  }
},
{
  "model": "interview_app.option",
  "pk": 515,
  "fields": {
    "question": 172,
    "key": "b",
    "text": "Модуль для роботи з процесами"
  }
},
{
  "model": "interview_app.option",
  "pk": 516,
  "fields": {
    "question": 172,
    "key": "c",
    "text": "Контекстний менеджер для керування групою конкурентних завдань"
  }
},
{
  "model": "interview_app.option",
  "pk": 517,
  "fields": {
    "question": 173,
    "key": "a",
    "text": "Запускає кілька корутин одночасно і чекає на їх завершення"
  }
},
{
  "model": "interview_app.option",
  "pk": 518,
  "fields": {
    "question": 173,
    "key": "b",
    "text": "Зупиняє виконання програми"
  }
},
{
  "model": "interview_app.option",
  "pk": 519,
  "fields": {
    "question": 173,
    "key": "c",
    "text": "Обробляє виключення"
  }
},
{
  "model": "interview_app.option",
  "pk": 520,
  "fields": {
    "question": 174,
    "key": "a",
    "text": "Для запису у файл"
  }
},
{
  "model": "interview_app.option",
  "pk": 521,
  "fields": {
    "question": 174,
    "key": "b",
    "text": "wait_for — таймаут для задачі; as_completed — ітератор результатів; wait — очікування набору задач"
  }
},
{
  "model": "interview_app.option",
  "pk": 522,
  "fields": {
    "question": 174,
    "key": "c",
    "text": "Для запуску процесів"
  }
},
{
  "model": "interview_app.option",
  "pk": 523,
  "fields": {
    "question": 175,
    "key": "a",
    "text": "Для запуску асинхронної функції"
  }
},
{
  "model": "interview_app.option",
  "pk": 524,
  "fields": {
    "question": 175,
    "key": "b",
    "text": "Для створення нових процесів"
  }
},
{
  "model": "interview_app.option",
  "pk": 525,
  "fields": {
    "question": 175,
    "key": "c",
    "text": "Для запуску блокуючої функції в окремому потоці без блокування циклу подій"
  }
},
{
  "model": "interview_app.option",
  "pk": 526,
  "fields": {
    "question": 176,
    "key": "a",
    "text": "Асинхронна бібліотека для створення HTTP-клієнтів і серверів на базі asyncio"
  }
},
{
  "model": "interview_app.option",
  "pk": 527,
  "fields": {
    "question": 176,
    "key": "b",
    "text": "Модуль для роботи з файлами"
  }
},
{
  "model": "interview_app.option",
  "pk": 528,
  "fields": {
    "question": 176,
    "key": "c",
    "text": "Модуль для роботи з базами даних"
  }
},
{
  "model": "interview_app.option",
  "pk": 529,
  "fields": {
    "question": 177,
    "key": "a",
    "text": "Використання багатопотоковості"
  }
},
{
  "model": "interview_app.option",
  "pk": 530,
  "fields": {
    "question": 177,
    "key": "b",
    "text": "Відсутність import asyncio"
  }
},
{
  "model": "interview_app.option",
  "pk": 531,
  "fields": {
    "question": 177,
    "key": "c",
    "text": "Виклик корутини без await, блокуючі функції, стан гонитви, взаємні блокування"
  }
},
{
  "model": "interview_app.option",
  "pk": 532,
  "fields": {
    "question": 178,
    "key": "a",
    "text": "Зазвичай один процес і один головний потік, конкурентність через переключення завдань"
  }
},
{
  "model": "interview_app.option",
  "pk": 533,
  "fields": {
    "question": 178,
    "key": "b",
    "text": "Кілька потоків і процесів одночасно"
  }
},
{
  "model": "interview_app.option",
  "pk": 534,
  "fields": {
    "question": 178,
    "key": "c",
    "text": "Тільки один потік без процесів"
  }
},
{
  "model": "interview_app.option",
  "pk": 535,
  "fields": {
    "question": 179,
    "key": "a",
    "text": "Процес — ізольована програма з власною пам'яттю, потік — легкий підпроцес у межах процесу, що ділить пам'ять"
  }
},
{
  "model": "interview_app.option",
  "pk": 536,
  "fields": {
    "question": 179,
    "key": "b",
    "text": "Процес і потік — синоніми"
  }
},
{
  "model": "interview_app.option",
  "pk": 537,
  "fields": {
    "question": 179,
    "key": "c",
    "text": "Потік — ізольована програма, процес — підпроцес"
  }
},
{
  "model": "interview_app.option",
  "pk": 538,
  "fields": {
    "question": 180,
    "key": "a",
    "text": "Потоки ізольовані, процеси ділять пам'ять"
  }
},
{
  "model": "interview_app.option",
  "pk": 539,
  "fields": {
    "question": 180,
    "key": "b",
    "text": "Немає відмінностей"
  }
},
{
  "model": "interview_app.option",
  "pk": 540,
  "fields": {
    "question": 180,
    "key": "c",
    "text": "Процеси ізольовані, потоки ділять пам'ять, потоки легші за процеси, але потребують синхронізації"
  }
},
{
  "model": "interview_app.option",
  "pk": 541,
  "fields": {
    "question": 181,
    "key": "a",
    "text": "Вони не підтримуються у Python"
  }
},
{
  "model": "interview_app.option",
  "pk": 542,
  "fields": {
    "question": 181,
    "key": "b",
    "text": "Потоки повільніші за процеси"
  }
},
{
  "model": "interview_app.option",
  "pk": 543,
  "fields": {
    "question": 181,
    "key": "c",
    "text": "Складність відлагодження, ресурсні затрати, GIL обмежує паралелізм для CPU-bound задач"
  }
},
{
  "model": "interview_app.option",
  "pk": 544,
  "fields": {
    "question": 182,
    "key": "a",
    "text": "Функції open і close"
  }
},
{
  "model": "interview_app.option",
  "pk": 545,
  "fields": {
    "question": 182,
    "key": "b",
    "text": "Модулі json і pickle"
  }
},
{
  "model": "interview_app.option",
  "pk": 546,
  "fields": {
    "question": 182,
    "key": "c",
    "text": "Lock, RLock, Semaphore, Event з модулів threading і multiprocessing"
  }
},
{
  "model": "interview_app.option",
  "pk": 547,
  "fields": {
    "question": 183,
    "key": "a",
    "text": "Черги — це тип файлів для збереження тимчасових даних"
  }
},
{
  "model": "interview_app.option",
  "pk": 548,
  "fields": {
    "question": 183,
    "key": "b",
    "text": "Черги (queue.Queue для потоків та multiprocessing.Queue для процесів) дозволяють безпечно обмінюватися даними за принципом FIFO, реалізуючи патерн \"виробник-споживач\"; автоматично керують блокуваннями, забезпечуючи потокобезпечність"
  }
},
{
  "model": "interview_app.option",
  "pk": 549,
  "fields": {
    "question": 183,
    "key": "c",
    "text": "Черги не підтримують багатопотокову синхронізацію"
  }
},
{
  "model": "interview_app.option",
  "pk": 550,
  "fields": {
    "question": 184,
    "key": "a",
    "text": "Бар'єри — це буфери для збереження даних"
  }
},
{
  "model": "interview_app.option",
  "pk": 551,
  "fields": {
    "question": 184,
    "key": "b",
    "text": "Бар'єри синхронізують процеси на рівні ОС"
  }
},
{
  "model": "interview_app.option",
  "pk": 552,
  "fields": {
    "question": 184,
    "key": "c",
    "text": "Бар'єри (threading.Barrier) змушують групу потоків чекати, доки всі досягнуть певної точки (бар'єру), після чого всі одночасно продовжують роботу"
  }
},
{
  "model": "interview_app.option",
  "pk": 553,
  "fields": {
    "question": 185,
    "key": "a",
    "text": "Через multiprocessing.Queue (безпечний FIFO-обмін, об'єкти серіалізуються), multiprocessing.Pipe (прямий двосторонній канал), спільну пам'ять (multiprocessing.Value, Array) для швидкого доступу з ручною синхронізацією, або менеджери multiprocessing.Manager для складних об'єктів"
  }
},
{
  "model": "interview_app.option",
  "pk": 554,
  "fields": {
    "question": 185,
    "key": "b",
    "text": "Використовуючи threading.Lock"
  }
},
{
  "model": "interview_app.option",
  "pk": 555,
  "fields": {
    "question": 185,
    "key": "c",
    "text": "Використовуючи глобальні змінні"
  }
},
{
  "model": "interview_app.option",
  "pk": 556,
  "fields": {
    "question": 186,
    "key": "a",
    "text": "Гонка — це тип виключення"
  }
},
{
  "model": "interview_app.option",
  "pk": 557,
  "fields": {
    "question": 186,
    "key": "b",
    "text": "Гонка — помилка, що виникає через непередбачуваний порядок доступу кількох потоків до спільного ресурсу, що призводить до некоректних результатів. Боротися можна через блокування (Lock), атомарні операції, потокобезпечні структури даних (черги), або унікнення спільних змінних"
  }
},
{
  "model": "interview_app.option",
  "pk": 558,
  "fields": {
    "question": 186,
    "key": "c",
    "text": "Гонка — це процес запуску декількох потоків"
  }
},
{
  "model": "interview_app.option",
  "pk": 559,
  "fields": {
    "question": 187,
    "key": "a",
    "text": "GIL — це тип процесу в ОС"
  }
},
{
  "model": "interview_app.option",
  "pk": 560,
  "fields": {
    "question": 187,
    "key": "b",
    "text": "GIL (Global Interpreter Lock) — механізм CPython, що дозволяє одночасно виконувати байт-код Python лише одному потоку, спрощуючи керування пам'яттю, але обмежуючи паралелізм CPU-bound задач і уповільнюючи багатопотокове виконання на багатоядерних системах"
  }
},
{
  "model": "interview_app.option",
  "pk": 561,
  "fields": {
    "question": 187,
    "key": "c",
    "text": "GIL — бібліотека для роботи з потоками"
  }
},
{
  "model": "interview_app.option",
  "pk": 562,
  "fields": {
    "question": 188,
    "key": "a",
    "text": "GIL забезпечує атомарність операцій підрахунку посилань (об_refcnt), що є основним механізмом керування пам'яттю в CPython; без GIL можливі гонки при зміні лічильника посилань"
  }
},
{
  "model": "interview_app.option",
  "pk": 563,
  "fields": {
    "question": 188,
    "key": "b",
    "text": "GC не пов'язаний з GIL"
  }
},
{
  "model": "interview_app.option",
  "pk": 564,
  "fields": {
    "question": 188,
    "key": "c",
    "text": "GIL запускає збирач сміття"
  }
},
{
  "model": "interview_app.option",
  "pk": 565,
  "fields": {
    "question": 189,
    "key": "a",
    "text": "Через модуль threading, який надає доступ до нативних потоків ОС, що ділять спільний простір пам'яті, вимагаючи синхронізації"
  }
},
{
  "model": "interview_app.option",
  "pk": 566,
  "fields": {
    "question": 189,
    "key": "b",
    "text": "Через модуль multiprocessing"
  }
},
{
  "model": "interview_app.option",
  "pk": 567,
  "fields": {
    "question": 189,
    "key": "c",
    "text": "Через async/await"
  }
},
{
  "model": "interview_app.option",
  "pk": 568,
  "fields": {
    "question": 190,
    "key": "a",
    "text": "Запуск і завершення"
  }
},
{
  "model": "interview_app.option",
  "pk": 569,
  "fields": {
    "question": 190,
    "key": "b",
    "text": "Створення, виклик функції, завершення"
  }
},
{
  "model": "interview_app.option",
  "pk": 570,
  "fields": {
    "question": 190,
    "key": "c",
    "text": "Створення (екземпляр класу threading.Thread), запуск (start()), виконання (run()), очікування/блокування (sleep, join), завершення (закінчення run())"
  }
},
{
  "model": "interview_app.option",
  "pk": 571,
  "fields": {
    "question": 191,
    "key": "a",
    "text": "ThreadPoolExecutor управляє фіксованою кількістю потоків для повторного використання, уникнення накладних витрат на створення/знищення, обмежує кількість одночасних потоків; потоки беруть завдання з черги, виконують і повертаються в пул"
  }
},
{
  "model": "interview_app.option",
  "pk": 572,
  "fields": {
    "question": 191,
    "key": "b",
    "text": "Для створення окремого процесу"
  }
},
{
  "model": "interview_app.option",
  "pk": 573,
  "fields": {
    "question": 191,
    "key": "c",
    "text": "Для запуску асинхронного коду"
  }
},
{
  "model": "interview_app.option",
  "pk": 574,
  "fields": {
    "question": 192,
    "key": "a",
    "text": "Переадресовує дані між потоками"
  }
},
{
  "model": "interview_app.option",
  "pk": 575,
  "fields": {
    "question": 192,
    "key": "b",
    "text": "Зберігає глобальні змінні"
  }
},
{
  "model": "interview_app.option",
  "pk": 576,
  "fields": {
    "question": 192,
    "key": "c",
    "text": "Створює локальний простір зберігання для кожного потоку, де дані ізольовані від інших потоків і доступні лише поточному"
  }
},
{
  "model": "interview_app.option",
  "pk": 577,
  "fields": {
    "question": 193,
    "key": "a",
    "text": "Добре: CPU-bound; Погано: I/O-bound"
  }
},
{
  "model": "interview_app.option",
  "pk": 578,
  "fields": {
    "question": 193,
    "key": "b",
    "text": "Усі однаково добре"
  }
},
{
  "model": "interview_app.option",
  "pk": 579,
  "fields": {
    "question": 193,
    "key": "c",
    "text": "Добре: I/O-bound (очікування мережі, диску); Погано: CPU-bound (інтенсивні обчислення через GIL)"
  }
},
{
  "model": "interview_app.option",
  "pk": 580,
  "fields": {
    "question": 194,
    "key": "a",
    "text": "Ні, це CPU-bound задача, для якої потоки не дадуть приросту продуктивності через GIL; краще використовувати multiprocessing або спеціалізовані бібліотеки"
  }
},
{
  "model": "interview_app.option",
  "pk": 581,
  "fields": {
    "question": 194,
    "key": "b",
    "text": "Краще зробити це асинхронно"
  }
},
{
  "model": "interview_app.option",
  "pk": 582,
  "fields": {
    "question": 194,
    "key": "c",
    "text": "Так, краще використовувати потоки"
  }
},
{
  "model": "interview_app.option",
  "pk": 583,
  "fields": {
    "question": 195,
    "key": "a",
    "text": "Легкі потоки, керовані програмою (не ОС), з кооперативним перемиканням; швидші та менш ресурсоємні за нативні потоки; приклади — бібліотеки greenlet, gevent"
  }
},
{
  "model": "interview_app.option",
  "pk": 584,
  "fields": {
    "question": 195,
    "key": "b",
    "text": "Потоки, що використовують multiprocessing"
  }
},
{
  "model": "interview_app.option",
  "pk": 585,
  "fields": {
    "question": 195,
    "key": "c",
    "text": "Нативні потоки ОС"
  }
},
{
  "model": "interview_app.option",
  "pk": 586,
  "fields": {
    "question": 196,
    "key": "a",
    "text": "Сигнали не використовуються в Python"
  }
},
{
  "model": "interview_app.option",
  "pk": 587,
  "fields": {
    "question": 196,
    "key": "b",
    "text": "Сигнали — асинхронні повідомлення ОС, обробники яких виконуються лише в головному потоці; якщо головний потік заблокований, сигнал може не обробитись, що ускладнює планування потоків"
  }
},
{
  "model": "interview_app.option",
  "pk": 588,
  "fields": {
    "question": 196,
    "key": "c",
    "text": "Сигнали — це потоки в Python"
  }
},
{
  "model": "interview_app.option",
  "pk": 589,
  "fields": {
    "question": 197,
    "key": "a",
    "text": "Unix-системний виклик для створення нового процесу шляхом копіювання батьківського процесу (Copy-on-Write оптимізація); у Windows аналога немає"
  }
},
{
  "model": "interview_app.option",
  "pk": 590,
  "fields": {
    "question": 197,
    "key": "b",
    "text": "Метод запуску асинхронних задач"
  }
},
{
  "model": "interview_app.option",
  "pk": 591,
  "fields": {
    "question": 197,
    "key": "c",
    "text": "Функція створення потоку"
  }
},
{
  "model": "interview_app.option",
  "pk": 592,
  "fields": {
    "question": 198,
    "key": "a",
    "text": "Процеси — CPU-bound; Потоки — I/O-bound з помірною кількістю з'єднань; Асинхронність — I/O-bound з великою кількістю з'єднань (тисячі і більше)"
  }
},
{
  "model": "interview_app.option",
  "pk": 593,
  "fields": {
    "question": 198,
    "key": "b",
    "text": "Асинхронність — CPU-bound"
  }
},
{
  "model": "interview_app.option",
  "pk": 594,
  "fields": {
    "question": 198,
    "key": "c",
    "text": "Потоки — CPU-bound; процеси — I/O-bound"
  }
},
{
  "model": "interview_app.option",
  "pk": 595,
  "fields": {
    "question": 199,
    "key": "a",
    "text": "Програма для компіляції у машинний код"
  }
},
{
  "model": "interview_app.option",
  "pk": 596,
  "fields": {
    "question": 199,
    "key": "b",
    "text": "Програма, що виконує вихідний код. CPython компілює .py у байт-код, а потім виконує його у віртуальній машині Python (PVM)"
  }
},
{
  "model": "interview_app.option",
  "pk": 597,
  "fields": {
    "question": 199,
    "key": "c",
    "text": "Середовище розробки"
  }
},
{
  "model": "interview_app.option",
  "pk": 598,
  "fields": {
    "question": 200,
    "key": "a",
    "text": "Linux, Windows, MacOS"
  }
},
{
  "model": "interview_app.option",
  "pk": 599,
  "fields": {
    "question": 200,
    "key": "b",
    "text": "JavaScript, Ruby, Perl"
  }
},
{
  "model": "interview_app.option",
  "pk": 600,
  "fields": {
    "question": 200,
    "key": "c",
    "text": "CPython (стандартний), Jython (на JVM), IronPython (.NET), PyPy (JIT-компілятор)"
  }
},
{
  "model": "interview_app.option",
  "pk": 601,
  "fields": {
    "question": 201,
    "key": "a",
    "text": "Мова-проросток Python з статичною типізацією, що компілюється у C/C++ для підвищення продуктивності"
  }
},
{
  "model": "interview_app.option",
  "pk": 602,
  "fields": {
    "question": 201,
    "key": "b",
    "text": "Інша версія Python"
  }
},
{
  "model": "interview_app.option",
  "pk": 603,
  "fields": {
    "question": 201,
    "key": "c",
    "text": "Інструмент для асинхронного програмування"
  }
},
{
  "model": "interview_app.option",
  "pk": 604,
  "fields": {
    "question": 202,
    "key": "a",
    "text": "Підрахунок посилань (Reference Counting) і збирач сміття (Garbage Collector) для циклічних посилань"
  }
},
{
  "model": "interview_app.option",
  "pk": 605,
  "fields": {
    "question": 202,
    "key": "b",
    "text": "Видалення вручну"
  }
},
{
  "model": "interview_app.option",
  "pk": 606,
  "fields": {
    "question": 202,
    "key": "c",
    "text": "Тільки збирач сміття"
  }
},
{
  "model": "interview_app.option",
  "pk": 607,
  "fields": {
    "question": 203,
    "key": "a",
    "text": "Механізм для виявлення та видалення циклічних посилань, що періодично перевіряє об'єкти за поколіннями"
  }
},
{
  "model": "interview_app.option",
  "pk": 608,
  "fields": {
    "question": 203,
    "key": "b",
    "text": "Модуль для збирання сміття в файлах"
  }
},
{
  "model": "interview_app.option",
  "pk": 609,
  "fields": {
    "question": 203,
    "key": "c",
    "text": "Система для видалення тимчасових файлів"
  }
},
{
  "model": "interview_app.option",
  "pk": 610,
  "fields": {
    "question": 204,
    "key": "a",
    "text": "Об'єкти мають лічильник посилань, що збільшується при створенні посилань і зменшується при їх видаленні; при 0 лічильнику об'єкт видаляється"
  }
},
{
  "model": "interview_app.option",
  "pk": 611,
  "fields": {
    "question": 204,
    "key": "b",
    "text": "Об'єкти видаляються після 1 хвилини"
  }
},
{
  "model": "interview_app.option",
  "pk": 612,
  "fields": {
    "question": 204,
    "key": "c",
    "text": "Об'єкти зберігаються у спеціальному масиві"
  }
},
{
  "model": "interview_app.option",
  "pk": 613,
  "fields": {
    "question": 205,
    "key": "a",
    "text": "Тільки блокування (Locks) та семафори."
  }
},
{
  "model": "interview_app.option",
  "pk": 614,
  "fields": {
    "question": 205,
    "key": "b",
    "text": "Використання глобальних змінних без синхронізації."
  }
},
{
  "model": "interview_app.option",
  "pk": 615,
  "fields": {
    "question": 205,
    "key": "c",
    "text": "Блокування (Locks), RLocks, Семафори, Події, Черги, Бар'єри; для процесів: multiprocessing.Queue, Pipe, спільна пам'ять, менеджери."
  }
},
{
  "model": "interview_app.option",
  "pk": 616,
  "fields": {
    "question": 206,
    "key": "a",
    "text": "Помилка, що виникає при неконтрольованому одночасному доступі до ресурсу; боротися блокуваннями, атомарними операціями, потокобезпечними структурами, зміною архітектури."
  }
},
{
  "model": "interview_app.option",
  "pk": 617,
  "fields": {
    "question": 206,
    "key": "b",
    "text": "Ситуація, коли програма не завершується; боротися через перезапуск."
  }
},
{
  "model": "interview_app.option",
  "pk": 618,
  "fields": {
    "question": 206,
    "key": "c",
    "text": "Проблема з недостатньою пам'яттю; боротися оптимізацією коду."
  }
},
{
  "model": "interview_app.option",
  "pk": 619,
  "fields": {
    "question": 207,
    "key": "a",
    "text": "Механізм для розподілу пам'яті між процесами."
  }
},
{
  "model": "interview_app.option",
  "pk": 620,
  "fields": {
    "question": 207,
    "key": "b",
    "text": "Система управління пам'яттю в Python."
  }
},
{
  "model": "interview_app.option",
  "pk": 621,
  "fields": {
    "question": 207,
    "key": "c",
    "text": "Global Interpreter Lock — механізм, що дозволяє лише одному потоку виконувати байт-код Python одночасно; уповільнює CPU-bound багатопотоковість."
  }
},
{
  "model": "interview_app.option",
  "pk": 622,
  "fields": {
    "question": 208,
    "key": "a",
    "text": "Через модуль threading, який використовує нативні потоки ОС, де потоки ділять пам'ять процесу і потребують синхронізації."
  }
},
{
  "model": "interview_app.option",
  "pk": 623,
  "fields": {
    "question": 208,
    "key": "b",
    "text": "Кожен потік має власний процес з ізольованою пам'яттю."
  }
},
{
  "model": "interview_app.option",
  "pk": 624,
  "fields": {
    "question": 208,
    "key": "c",
    "text": "Python не підтримує багатопотоковість."
  }
},
{
  "model": "interview_app.option",
  "pk": 625,
  "fields": {
    "question": 209,
    "key": "a",
    "text": "Для створення необмеженої кількості нових потоків під кожне завдання."
  }
},
{
  "model": "interview_app.option",
  "pk": 626,
  "fields": {
    "question": 209,
    "key": "b",
    "text": "Для ефективного керування групою потоків, повторного використання та обмеження їх кількості; завдання ставляться в чергу і виконуються вільними потоками."
  }
},
{
  "model": "interview_app.option",
  "pk": 627,
  "fields": {
    "question": 209,
    "key": "c",
    "text": "Для обробки даних у одному потоці послідовно."
  }
},
{
  "model": "interview_app.option",
  "pk": 628,
  "fields": {
    "question": 210,
    "key": "a",
    "text": "Глобальна змінна, доступна для всіх потоків."
  }
},
{
  "model": "interview_app.option",
  "pk": 629,
  "fields": {
    "question": 210,
    "key": "b",
    "text": "Об'єкт локального сховища даних для кожного потоку, ізольований від інших потоків."
  }
},
{
  "model": "interview_app.option",
  "pk": 630,
  "fields": {
    "question": 210,
    "key": "c",
    "text": "Бібліотека для синхронізації потоків."
  }
},
{
  "model": "interview_app.option",
  "pk": 631,
  "fields": {
    "question": 211,
    "key": "a",
    "text": "Добре — I/O-bound (ввід/вивід), погано — CPU-bound (інтенсивні обчислення) через GIL."
  }
},
{
  "model": "interview_app.option",
  "pk": 632,
  "fields": {
    "question": 211,
    "key": "b",
    "text": "Добре — CPU-bound, погано — I/O-bound."
  }
},
{
  "model": "interview_app.option",
  "pk": 633,
  "fields": {
    "question": 211,
    "key": "c",
    "text": "Всі завдання паралеляться однаково."
  }
},
{
  "model": "interview_app.option",
  "pk": 634,
  "fields": {
    "question": 212,
    "key": "a",
    "text": "Операції, які виконуються миттєво."
  }
},
{
  "model": "interview_app.option",
  "pk": 635,
  "fields": {
    "question": 212,
    "key": "b",
    "text": "Операції, що працюють асинхронно."
  }
},
{
  "model": "interview_app.option",
  "pk": 636,
  "fields": {
    "question": 212,
    "key": "c",
    "text": "Операції, що зупиняють виконання потоку до завершення (наприклад, time.sleep, читання файлів)."
  }
},
{
  "model": "interview_app.option",
  "pk": 637,
  "fields": {
    "question": 213,
    "key": "a",
    "text": "Обчислювати у головному потоці без паралелізму."
  }
},
{
  "model": "interview_app.option",
  "pk": 638,
  "fields": {
    "question": 213,
    "key": "b",
    "text": "Так, краще за допомогою потоків."
  }
},
{
  "model": "interview_app.option",
  "pk": 639,
  "fields": {
    "question": 213,
    "key": "c",
    "text": "Ні, це CPU-bound задача; краще використовувати багатопроцесорність."
  }
},
{
  "model": "interview_app.option",
  "pk": 640,
  "fields": {
    "question": 214,
    "key": "a",
    "text": "Фізичні потоки ОС."
  }
},
{
  "model": "interview_app.option",
  "pk": 641,
  "fields": {
    "question": 214,
    "key": "b",
    "text": "Легковагові псевдо-потоки, керовані програмою; приклади: greenlet, gevent, asyncio корутини."
  }
},
{
  "model": "interview_app.option",
  "pk": 642,
  "fields": {
    "question": 214,
    "key": "c",
    "text": "Процеси з власною пам'яттю."
  }
},
{
  "model": "interview_app.option",
  "pk": 643,
  "fields": {
    "question": 215,
    "key": "a",
    "text": "Повнофункціональний та високорівневий веб-фреймворк, що надає всі необхідні компоненти \"з коробки\", такі як ORM, система аутентифікації та адміністрування."
  }
},
{
  "model": "interview_app.option",
  "pk": 644,
  "fields": {
    "question": 215,
    "key": "b",
    "text": "Мінімалістичний веб-фреймворк без вбудованих компонентів."
  }
},
{
  "model": "interview_app.option",
  "pk": 645,
  "fields": {
    "question": 215,
    "key": "c",
    "text": "Інструмент для тестування коду."
  }
},
{
  "model": "interview_app.option",
  "pk": 646,
  "fields": {
    "question": 216,
    "key": "a",
    "text": "Бібліотека для роботи з базами даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 647,
  "fields": {
    "question": 216,
    "key": "b",
    "text": "Мінімалістичний веб-фреймворк, що надає базовий набір інструментів і велику гнучкість."
  }
},
{
  "model": "interview_app.option",
  "pk": 648,
  "fields": {
    "question": 216,
    "key": "c",
    "text": "Великофункціональний фреймворк для API з автоматичною документацією."
  }
},
{
  "model": "interview_app.option",
  "pk": 649,
  "fields": {
    "question": 217,
    "key": "a",
    "text": "Інструмент для перевірки стилю коду."
  }
},
{
  "model": "interview_app.option",
  "pk": 650,
  "fields": {
    "question": 217,
    "key": "b",
    "text": "Легкий веб-фреймворк для створення веб-сторінок."
  }
},
{
  "model": "interview_app.option",
  "pk": 651,
  "fields": {
    "question": 217,
    "key": "c",
    "text": "Сучасний високопродуктивний фреймворк для створення API з автоматичною генерацією документації."
  }
},
{
  "model": "interview_app.option",
  "pk": 652,
  "fields": {
    "question": 218,
    "key": "a",
    "text": "Фреймворк для створення API."
  }
},
{
  "model": "interview_app.option",
  "pk": 653,
  "fields": {
    "question": 218,
    "key": "b",
    "text": "Інструмент для автоматичного форматування коду."
  }
},
{
  "model": "interview_app.option",
  "pk": 654,
  "fields": {
    "question": 218,
    "key": "c",
    "text": "Популярна бібліотека для тестування коду в Python."
  }
},
{
  "model": "interview_app.option",
  "pk": 655,
  "fields": {
    "question": 219,
    "key": "a",
    "text": "Високорівнева частина, що дозволяє працювати з базою даних через Python-об'єкти."
  }
},
{
  "model": "interview_app.option",
  "pk": 656,
  "fields": {
    "question": 219,
    "key": "b",
    "text": "Низькорівнева частина бібліотеки для побудови SQL-запитів програмно."
  }
},
{
  "model": "interview_app.option",
  "pk": 657,
  "fields": {
    "question": 219,
    "key": "c",
    "text": "Інструмент для створення асинхронних задач."
  }
},
{
  "model": "interview_app.option",
  "pk": 658,
  "fields": {
    "question": 220,
    "key": "a",
    "text": "Розподілена система черг завдань для Python для асинхронного виконання задач."
  }
},
{
  "model": "interview_app.option",
  "pk": 659,
  "fields": {
    "question": 220,
    "key": "b",
    "text": "Бібліотека для роботи з базами даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 660,
  "fields": {
    "question": 220,
    "key": "c",
    "text": "Фреймворк для тестування."
  }
},
{
  "model": "interview_app.option",
  "pk": 661,
  "fields": {
    "question": 221,
    "key": "a",
    "text": "Повертає x, якщо x хибне, інакше y."
  }
},
{
  "model": "interview_app.option",
  "pk": 662,
  "fields": {
    "question": 221,
    "key": "b",
    "text": "Завжди повертає True."
  }
},
{
  "model": "interview_app.option",
  "pk": 663,
  "fields": {
    "question": 221,
    "key": "c",
    "text": "Повертає y, якщо x істинне, інакше x."
  }
},
{
  "model": "interview_app.option",
  "pk": 664,
  "fields": {
    "question": 222,
    "key": "a",
    "text": "Алгоритм сортування."
  }
},
{
  "model": "interview_app.option",
  "pk": 665,
  "fields": {
    "question": 222,
    "key": "b",
    "text": "Метод тестування коду."
  }
},
{
  "model": "interview_app.option",
  "pk": 666,
  "fields": {
    "question": 222,
    "key": "c",
    "text": "Задача, де числа, що діляться на 3 замінюють на 'fizz', на 5 — на 'buzz', а на обидва — на 'fizzbuzz'."
  }
},
{
  "model": "interview_app.option",
  "pk": 667,
  "fields": {
    "question": 223,
    "key": "a",
    "text": "Порівняти рядок з його перевернутою версією: string == string[::-1]."
  }
},
{
  "model": "interview_app.option",
  "pk": 668,
  "fields": {
    "question": 223,
    "key": "b",
    "text": "Використати регулярні вирази."
  }
},
{
  "model": "interview_app.option",
  "pk": 669,
  "fields": {
    "question": 223,
    "key": "c",
    "text": "Перевірити наявність цифр у рядку."
  }
},
{
  "model": "interview_app.option",
  "pk": 670,
  "fields": {
    "question": 224,
    "key": "a",
    "text": "Фреймворк для створення API."
  }
},
{
  "model": "interview_app.option",
  "pk": 671,
  "fields": {
    "question": 224,
    "key": "b",
    "text": "Акронім п’яти принципів об’єктно-орієнтованого дизайну."
  }
},
{
  "model": "interview_app.option",
  "pk": 672,
  "fields": {
    "question": 224,
    "key": "c",
    "text": "Інструмент для тестування."
  }
},
{
  "model": "interview_app.option",
  "pk": 673,
  "fields": {
    "question": 225,
    "key": "a",
    "text": "Це єдина точка входу для всіх клієнтських запитів, яка маршрутизує їх до відповідних мікросервісів, забезпечуючи аутентифікацію, моніторинг та кешування."
  }
},
{
  "model": "interview_app.option",
  "pk": 674,
  "fields": {
    "question": 225,
    "key": "b",
    "text": "Це база даних, яка зберігає інформацію про всі доступні мікросервіси в системі."
  }
},
{
  "model": "interview_app.option",
  "pk": 675,
  "fields": {
    "question": 225,
    "key": "c",
    "text": "Це інструмент для автоматичного розгортання мікросервісів у хмарному середовищі."
  }
},
{
  "model": "interview_app.option",
  "pk": 676,
  "fields": {
    "question": 226,
    "key": "a",
    "text": "Теорема стверджує, що розподілена система може гарантувати лише дві з трьох властивостей: узгодженість (Consistency), доступність (Availability) та стійкість до розділення (Partition tolerance). Більшість систем обирають AP (доступність і стійкість)."
  }
},
{
  "model": "interview_app.option",
  "pk": 677,
  "fields": {
    "question": 226,
    "key": "b",
    "text": "Це теорема про максимальну кількість одночасних підключень до бази даних, де системи обирають узгодженість і продуктивність."
  }
},
{
  "model": "interview_app.option",
  "pk": 678,
  "fields": {
    "question": 226,
    "key": "c",
    "text": "Теорема CAP описує правила кешування даних: кеш, доступність, продуктивність. Системи зазвичай обирають кеш і продуктивність."
  }
},
{
  "model": "interview_app.option",
  "pk": 679,
  "fields": {
    "question": 227,
    "key": "a",
    "text": "`rebase` переписує історію комітів, переносячи їх на нову базу і створюючи лінійну історію, тоді як `merge` створює новий \"merge commit\", зберігаючи обидві гілки історії."
  }
},
{
  "model": "interview_app.option",
  "pk": 680,
  "fields": {
    "question": 227,
    "key": "b",
    "text": "`rebase` використовується для завантаження змін на віддалений репозиторій, а `merge` — для їх отримання."
  }
},
{
  "model": "interview_app.option",
  "pk": 681,
  "fields": {
    "question": 227,
    "key": "c",
    "text": "`merge` завжди безпечніший і ніколи не викликає конфліктів, на відміну від `rebase`."
  }
},
{
  "model": "interview_app.option",
  "pk": 682,
  "fields": {
    "question": 228,
    "key": "a",
    "text": "Для відміни останнього коміту та повернення змін у робочу директорію."
  }
},
{
  "model": "interview_app.option",
  "pk": 683,
  "fields": {
    "question": 228,
    "key": "b",
    "text": "Для вибіркового застосування одного або кількох комітів з однієї гілки в іншу."
  }
},
{
  "model": "interview_app.option",
  "pk": 684,
  "fields": {
    "question": 228,
    "key": "c",
    "text": "Для створення нової гілки з певного коміту."
  }
},
{
  "model": "interview_app.option",
  "pk": 685,
  "fields": {
    "question": 229,
    "key": "a",
    "text": "Це техніка, що дозволяє використовувати кілька образів в одному Dockerfile для компіляції/збірки коду, а потім копіювати артефакти в кінцевий, менший образ, що значно зменшує його розмір."
  }
},
{
  "model": "interview_app.option",
  "pk": 686,
  "fields": {
    "question": 229,
    "key": "b",
    "text": "Це спосіб запустити кілька контейнерів з одного Dockerfile одночасно."
  }
},
{
  "model": "interview_app.option",
  "pk": 687,
  "fields": {
    "question": 229,
    "key": "c",
    "text": "Це процес створення Docker-образів, які можуть працювати на різних операційних системах."
  }
},
{
  "model": "interview_app.option",
  "pk": 688,
  "fields": {
    "question": 230,
    "key": "a",
    "text": "`volume` керується Docker і зберігається в спеціальній директорії на хості, тоді як `bind mount` прив'язує будь-яку директорію хоста до контейнера, що дає менше портативності."
  }
},
{
  "model": "interview_app.option",
  "pk": 689,
  "fields": {
    "question": 230,
    "key": "b",
    "text": "`bind mount` швидший за `volume`, оскільки він не використовує файлову систему Docker."
  }
},
{
  "model": "interview_app.option",
  "pk": 690,
  "fields": {
    "question": 230,
    "key": "c",
    "text": "Різниці немає, це синоніми для одного й того ж механізму зберігання даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 691,
  "fields": {
    "question": 231,
    "key": "a",
    "text": "Це ситуація, коли ORM виконує один запит для отримання списку об'єктів, а потім по одному додатковому запиту для кожного пов'язаного об'єкта. Вирішується за допомогою `select_related` (для ForeignKey) та `prefetch_related` (для ManyToMany/Reverse FK)."
  }
},
{
  "model": "interview_app.option",
  "pk": 692,
  "fields": {
    "question": 231,
    "key": "b",
    "text": "Це проблема, коли один запит виконується N+1 разів через неправильну конфігурацію кешу."
  }
},
{
  "model": "interview_app.option",
  "pk": 693,
  "fields": {
    "question": 231,
    "key": "c",
    "text": "Це помилка, коли база даних повертає на один запис більше, ніж очікувалося. Вирішується за допомогою `LIMIT 1`."
  }
},
{
  "model": "interview_app.option",
  "pk": 694,
  "fields": {
    "question": 232,
    "key": "a",
    "text": "Це рівні доступу користувачів до бази даних: адміністратор, редактор, читач."
  }
},
{
  "model": "interview_app.option",
  "pk": 695,
  "fields": {
    "question": 232,
    "key": "b",
    "text": "Це механізми, що контролюють видимість змін, зроблених паралельними транзакціями (Read Uncommitted, Read Committed, Repeatable Read, Serializable), балансуючи між продуктивністю та узгодженістю даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 696,
  "fields": {
    "question": 232,
    "key": "c",
    "text": "Це спосіб шифрування даних на різних рівнях: на рівні таблиці, колонки або запису."
  }
},
{
  "model": "interview_app.option",
  "pk": 697,
  "fields": {
    "question": 233,
    "key": "a",
    "text": "Індекси використовуються тільки для повнотекстового пошуку і не підтримують числові дані."
  }
},
{
  "model": "interview_app.option",
  "pk": 698,
  "fields": {
    "question": 233,
    "key": "b",
    "text": "Індекси — це тимчасові таблиці, які створюються для кожного запиту."
  }
},
{
  "model": "interview_app.option",
  "pk": 699,
  "fields": {
    "question": 233,
    "key": "c",
    "text": "Індекси — це спеціальні структури даних, що прискорюють пошук. B-Tree індекс організовує дані у вигляді збалансованого дерева, що дозволяє швидко знаходити записи за логарифмічний час."
  }
},
{
  "model": "interview_app.option",
  "pk": 700,
  "fields": {
    "question": 234,
    "key": "a",
    "text": "FastAPI вимагає вручну створювати всі залежні об'єкти в кожній функції."
  }
},
{
  "model": "interview_app.option",
  "pk": 701,
  "fields": {
    "question": 234,
    "key": "b",
    "text": "Dependency Injection — це патерн, який використовується лише для тестування і не працює в продакшені."
  }
},
{
  "model": "interview_app.option",
  "pk": 702,
  "fields": {
    "question": 234,
    "key": "c",
    "text": "За допомогою `Depends`, FastAPI автоматично створює та передає в `path operation function` залежності (наприклад, сесію БД або об'єкт користувача), керуючи їх життєвим циклом."
  }
},
{
  "model": "interview_app.option",
  "pk": 703,
  "fields": {
    "question": 235,
    "key": "a",
    "text": "Це вбудований ORM для FastAPI, який замінює SQLAlchemy."
  }
},
{
  "model": "interview_app.option",
  "pk": 704,
  "fields": {
    "question": 235,
    "key": "b",
    "text": "Це шаблонізатор для генерації HTML-сторінок у FastAPI."
  }
},
{
  "model": "interview_app.option",
  "pk": 705,
  "fields": {
    "question": 235,
    "key": "c",
    "text": "Це бібліотека для валідації та серіалізації даних на основі анотацій типів Python, яка використовується FastAPI для автоматичної валідації запитів, серіалізації відповідей та генерації OpenAPI документації."
  }
},
{
  "model": "interview_app.option",
  "pk": 706,
  "fields": {
    "question": 236,
    "key": "a",
    "text": "Це механізм для керування потоками (threads) в асинхронних запитах Django."
  }
},
{
  "model": "interview_app.option",
  "pk": 707,
  "fields": {
    "question": 236,
    "key": "b",
    "text": "Сигнали використовуються для надсилання HTTP-запитів на зовнішні сервіси."
  }
},
{
  "model": "interview_app.option",
  "pk": 708,
  "fields": {
    "question": 236,
    "key": "c",
    "text": "Сигнали дозволяють певним відправникам сповіщати набір приймачів про подію. Наприклад, сигнал `post_save` може викликати функцію для очищення кешу після оновлення моделі."
  }
},
{
  "model": "interview_app.option",
  "pk": 709,
  "fields": {
    "question": 237,
    "key": "a",
    "text": "Всі три класи роблять одне й те саме, але мають різні назви для сумісності."
  }
},
{
  "model": "interview_app.option",
  "pk": 710,
  "fields": {
    "question": 237,
    "key": "b",
    "text": "`ModelSerializer` працює тільки з базами даних SQL, а `HyperlinkedModelSerializer` — з NoSQL."
  }
},
{
  "model": "interview_app.option",
  "pk": 711,
  "fields": {
    "question": 237,
    "key": "c",
    "text": "`Serializer` — базовий клас. `ModelSerializer` автоматично створює поля та валідатори на основі моделі Django. `HyperlinkedModelSerializer` представляє зв'язки не через ID, а через URL."
  }
},
{
  "model": "interview_app.option",
  "pk": 712,
  "fields": {
    "question": 238,
    "key": "a",
    "text": "Це токен, що складається лише з ID користувача та терміну дії, без підпису."
  }
},
{
  "model": "interview_app.option",
  "pk": 713,
  "fields": {
    "question": 238,
    "key": "b",
    "text": "Це відкритий стандарт для створення токенів доступу. Складається з трьох частин, розділених крапками: заголовок (Header), корисне навантаження (Payload) та підпис (Signature)."
  }
},
{
  "model": "interview_app.option",
  "pk": 714,
  "fields": {
    "question": 238,
    "key": "c",
    "text": "Це зашифрований XML-файл, який зберігається в сесії користувача."
  }
},
{
  "model": "interview_app.option",
  "pk": 715,
  "fields": {
    "question": 239,
    "key": "a",
    "text": "Це спосіб захисту від SQL-ін'єкцій шляхом валідації походження запиту."
  }
},
{
  "model": "interview_app.option",
  "pk": 716,
  "fields": {
    "question": 239,
    "key": "b",
    "text": "Це техніка шифрування даних, що передаються між клієнтом і сервером."
  }
},
{
  "model": "interview_app.option",
  "pk": 717,
  "fields": {
    "question": 239,
    "key": "c",
    "text": "Це механізм, який дозволяє веб-сторінці, завантаженій з одного домену, робити запити до ресурсів на іншому домені, що є необхідним для сучасних фронтенд-додатків."
  }
},
{
  "model": "interview_app.option",
  "pk": 718,
  "fields": {
    "question": 240,
    "key": "a",
    "text": "Це техніка заміни частин системи (наприклад, об'єктів або функцій) на фіктивні реалізації. У Python для цього використовується `unittest.mock`."
  }
},
{
  "model": "interview_app.option",
  "pk": 719,
  "fields": {
    "question": 240,
    "key": "b",
    "text": "Це синоніми для інтеграційного тестування, де перевіряється взаємодія компонентів."
  }
},
{
  "model": "interview_app.option",
  "pk": 720,
  "fields": {
    "question": 240,
    "key": "c",
    "text": "Це процес написання тестів, які покривають 100% коду."
  }
},
{
  "model": "interview_app.option",
  "pk": 721,
  "fields": {
    "question": 241,
    "key": "a",
    "text": "Скоупи в `pytest` визначають рівень доступу до тестових даних: публічний або приватний."
  }
},
{
  "model": "interview_app.option",
  "pk": 722,
  "fields": {
    "question": 241,
    "key": "b",
    "text": "Фікстури надають тестовим функціям початкові дані або об'єкти. Скоупи (`function`, `class`, `module`, `session`) визначають, як часто фікстура буде створюватися і знищуватися."
  }
},
{
  "model": "interview_app.option",
  "pk": 723,
  "fields": {
    "question": 241,
    "key": "c",
    "text": "Фікстури — це інструмент для вимірювання швидкості виконання тестів."
  }
},
{
  "model": "interview_app.option",
  "pk": 724,
  "fields": {
    "question": 242,
    "key": "a",
    "text": "Це механізм, який автоматично перезапускає сервіс, якщо він перестав працювати."
  }
},
{
  "model": "interview_app.option",
  "pk": 725,
  "fields": {
    "question": 242,
    "key": "b",
    "text": "Це спосіб примусово завершити роботу програми у разі критичної помилки."
  }
},
{
  "model": "interview_app.option",
  "pk": 726,
  "fields": {
    "question": 242,
    "key": "c",
    "text": "Це патерн, який запобігає повторним викликам сервісу, що не відповідає, обертаючи виклики в об'єкт, який відстежує збої і 'розмикає' ланцюг на певний час після порогу помилок."
  }
},
{
  "model": "interview_app.option",
  "pk": 727,
  "fields": {
    "question": 243,
    "key": "a",
    "text": "Це властивість операції, при якій повторне її виконання призводить до того ж результату, що й перше. Методи `GET`, `PUT`, `DELETE` мають бути ідемпотентними, а `POST` — ні."
  }
},
{
  "model": "interview_app.option",
  "pk": 728,
  "fields": {
    "question": 243,
    "key": "b",
    "text": "Це вимога, щоб усі відповіді сервера були у форматі JSON."
  }
},
{
  "model": "interview_app.option",
  "pk": 729,
  "fields": {
    "question": 243,
    "key": "c",
    "text": "Це означає, що API має підтримувати кешування на боці клієнта."
  }
},
{
  "model": "interview_app.option",
  "pk": 730,
  "fields": {
    "question": 244,
    "key": "a",
    "text": "gRPC і REST — це два різних формати даних, як JSON і XML."
  }
},
{
  "model": "interview_app.option",
  "pk": 731,
  "fields": {
    "question": 244,
    "key": "b",
    "text": "gRPC — це фреймворк від Google для віддаленого виклику процедур, що використовує HTTP/2 та Protocol Buffers для серіалізації, забезпечуючи вищу продуктивність та строгу типізацію порівняно з REST."
  }
},
{
  "model": "interview_app.option",
  "pk": 732,
  "fields": {
    "question": 244,
    "key": "c",
    "text": "gRPC — це стара версія REST, яка працює через протокол TCP."
  }
},
{
  "model": "interview_app.option",
  "pk": 733,
  "fields": {
    "question": 245,
    "key": "a",
    "text": "Middleware — це система 'хуків' у процес обробки запитів/відповідей. Порядок важливий, оскільки запит проходить через них послідовно зверху вниз, а відповідь — у зворотному порядку, знизу вгору."
  }
},
{
  "model": "interview_app.option",
  "pk": 734,
  "fields": {
    "question": 245,
    "key": "b",
    "text": "Middleware — це бібліотеки, які можна підключати до Django для розширення функціоналу, їх порядок не має значення."
  }
},
{
  "model": "interview_app.option",
  "pk": 735,
  "fields": {
    "question": 245,
    "key": "c",
    "text": "Middleware виконуються паралельно для прискорення обробки запиту."
  }
},
{
  "model": "interview_app.option",
  "pk": 736,
  "fields": {
    "question": 246,
    "key": "a",
    "text": "Для перегляду журналу всіх змін, що відбувалися з `HEAD` та іншими посиланнями в локальному репозиторії, що дозволяє відновити втрачені коміти або гілки."
  }
},
{
  "model": "interview_app.option",
  "pk": 737,
  "fields": {
    "question": 246,
    "key": "b",
    "text": "Це команда для форматування логу `git log` у більш читабельний вигляд."
  }
},
{
  "model": "interview_app.option",
  "pk": 738,
  "fields": {
    "question": 246,
    "key": "c",
    "text": "Для логування всіх віддалених (remote) операцій, таких як `push` та `fetch`."
  }
},
{
  "model": "interview_app.option",
  "pk": 739,
  "fields": {
    "question": 247,
    "key": "a",
    "text": "Helm — це система моніторингу та логування для кластерів Kubernetes."
  }
},
{
  "model": "interview_app.option",
  "pk": 740,
  "fields": {
    "question": 247,
    "key": "b",
    "text": "Helm — це інструмент командного рядка для прямого керування подами (pods) в Kubernetes."
  }
},
{
  "model": "interview_app.option",
  "pk": 741,
  "fields": {
    "question": 247,
    "key": "c",
    "text": "Helm — це менеджер пакетів для Kubernetes, який дозволяє описувати, встановлювати та оновлювати складні додатки за допомогою шаблонів, що називаються 'чартами' (charts)."
  }
},
{
  "model": "interview_app.option",
  "pk": 742,
  "fields": {
    "question": 248,
    "key": "a",
    "text": "Blue-Green — це розгортання вдень, а Canary — вночі."
  }
},
{
  "model": "interview_app.option",
  "pk": 743,
  "fields": {
    "question": 248,
    "key": "b",
    "text": "Blue-Green: створюються два ідентичні оточення, і трафік миттєво переключається на нову версію. Canary: нова версія розгортається для невеликої частини користувачів, і її частка поступово збільшується."
  }
},
{
  "model": "interview_app.option",
  "pk": 744,
  "fields": {
    "question": 248,
    "key": "c",
    "text": "Canary deployment використовує Docker, а Blue-Green — віртуальні машини."
  }
},
{
  "model": "interview_app.option",
  "pk": 745,
  "fields": {
    "question": 249,
    "key": "a",
    "text": "Це метод, який блокує вибрані рядки в базі даних до кінця поточної транзакції, щоб уникнути гонки даних (race condition) при одночасному оновленні цих рядків."
  }
},
{
  "model": "interview_app.option",
  "pk": 746,
  "fields": {
    "question": 249,
    "key": "b",
    "text": "Це метод для вибору лише тих полів, які потрібно оновити, для оптимізації."
  }
},
{
  "model": "interview_app.option",
  "pk": 747,
  "fields": {
    "question": 249,
    "key": "c",
    "text": "Це функція, яка перевіряє, чи є нові оновлення для моделі, перед тим як її зберігати."
  }
},
{
  "model": "interview_app.option",
  "pk": 748,
  "fields": {
    "question": 250,
    "key": "a",
    "text": "Це розширення Django, що додає підтримку довготривалих з'єднань, таких як WebSockets, дозволяючи створювати додатки, які виходять за межі парадигми 'запит-відповідь' (наприклад, чати)."
  }
},
{
  "model": "interview_app.option",
  "pk": 749,
  "fields": {
    "question": 250,
    "key": "b",
    "text": "Це система для паралельного виконання HTTP-запитів у Django."
  }
},
{
  "model": "interview_app.option",
  "pk": 750,
  "fields": {
    "question": 250,
    "key": "c",
    "text": "Це інструмент для керування різними каналами розповсюдження контенту (соціальні мережі, email)."
  }
},
{
  "model": "interview_app.option",
  "pk": 751,
  "fields": {
    "question": 251,
    "key": "a",
    "text": "Фонові задачі у FastAPI виконуються в окремих процесах, ізольованих від основного додатку."
  }
},
{
  "model": "interview_app.option",
  "pk": 752,
  "fields": {
    "question": 251,
    "key": "b",
    "text": "FastAPI дозволяє запускати фонові задачі, які виконуються після відправки відповіді клієнту, що корисно для операцій, які не повинні блокувати відповідь (наприклад, відправка email)."
  }
},
{
  "model": "interview_app.option",
  "pk": 753,
  "fields": {
    "question": 251,
    "key": "c",
    "text": "Це механізм, який виконує задачі за розкладом, як cron."
  }
},
{
  "model": "interview_app.option",
  "pk": 754,
  "fields": {
    "question": 252,
    "key": "a",
    "text": "Сіль — це секретний ключ, однаковий для всіх паролів у системі, який додається для шифрування."
  }
},
{
  "model": "interview_app.option",
  "pk": 755,
  "fields": {
    "question": 252,
    "key": "b",
    "text": "Сортування паролів — це процес їх упорядкування в базі даних для швидкого пошуку."
  }
},
{
  "model": "interview_app.option",
  "pk": 756,
  "fields": {
    "question": 252,
    "key": "c",
    "text": "Сіль (salt) — це випадкові дані, що додаються до пароля перед хешуванням, щоб зробити атаки за допомогою райдужних таблиць (rainbow tables) неефективними. Замість простого хешування слід використовувати адаптивні функції, як-от `bcrypt`."
  }
},
{
  "model": "interview_app.option",
  "pk": 757,
  "fields": {
    "question": 253,
    "key": "a",
    "text": "Це техніка створення та підтримки пулу відкритих з'єднань з базою даних, які можна перевикористовувати, щоб уникнути високих накладних витрат на встановлення нового з'єднання для кожного запиту."
  }
},
{
  "model": "interview_app.option",
  "pk": 758,
  "fields": {
    "question": 253,
    "key": "b",
    "text": "Це спосіб об'єднати кілька баз даних в одну віртуальну."
  }
},
{
  "model": "interview_app.option",
  "pk": 759,
  "fields": {
    "question": 253,
    "key": "c",
    "text": "Це механізм для розподілу запитів між кількома серверами баз даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 760,
  "fields": {
    "question": 254,
    "key": "a",
    "text": "Це практика керування та налаштування інфраструктури (серверів, мереж) за допомогою конфігураційних файлів, що робить процес автоматизованим та відтворюваним. Приклади: Terraform, Ansible, CloudFormation."
  }
},
{
  "model": "interview_app.option",
  "pk": 761,
  "fields": {
    "question": 254,
    "key": "b",
    "text": "Це процес документування наявної інфраструктури за допомогою коду."
  }
},
{
  "model": "interview_app.option",
  "pk": 762,
  "fields": {
    "question": 254,
    "key": "c",
    "text": "Це написання коду для додатків, який не залежить від конкретної інфраструктури."
  }
},
{
  "model": "interview_app.option",
  "pk": 763,
  "fields": {
    "question": 255,
    "key": "a",
    "text": "Це файл з Python-кодом, який скомпільовано в байт-код для прискорення виконання."
  }
},
{
  "model": "interview_app.option",
  "pk": 764,
  "fields": {
    "question": 255,
    "key": "b",
    "text": "Це файл, що містить лише анотації типів для існуючого Python-модуля. Він дозволяє статичним аналізаторам, як-от `mypy`, перевіряти код, написаний без type hints, або код із C-розширень."
  }
},
{
  "model": "interview_app.option",
  "pk": 765,
  "fields": {
    "question": 255,
    "key": "c",
    "text": "Це файл конфігурації для інтерпретатора Python, який визначає шляхи пошуку модулів."
  }
},
{
  "model": "interview_app.option",
  "pk": 766,
  "fields": {
    "question": 256,
    "key": "a",
    "text": "SQL бази даних використовують структуровану схему та таблиці зі зв'язками (JOINs), тоді як NoSQL пропонують гнучкі моделі даних (документи, ключ-значення) та кращу горизонтальну масштабованість."
  }
},
{
  "model": "interview_app.option",
  "pk": 767,
  "fields": {
    "question": 256,
    "key": "b",
    "text": "SQL бази даних безкоштовні, а NoSQL завжди платні."
  }
},
{
  "model": "interview_app.option",
  "pk": 768,
  "fields": {
    "question": 256,
    "key": "c",
    "text": "NoSQL бази даних швидші за SQL у всіх без винятку випадках."
  }
},
{
  "model": "interview_app.option",
  "pk": 769,
  "fields": {
    "question": 257,
    "key": "a",
    "text": "Це два синоніми для однієї і тієї ж стратегії кешування, де дані записуються лише в кеш."
  }
},
{
  "model": "interview_app.option",
  "pk": 770,
  "fields": {
    "question": 257,
    "key": "b",
    "text": "Write-through: кеш оновлюється тільки після запису в базу. Cache-aside: кеш і база даних не синхронізуються."
  }
},
{
  "model": "interview_app.option",
  "pk": 771,
  "fields": {
    "question": 257,
    "key": "c",
    "text": "Write-through: дані записуються одночасно і в кеш, і в базу. Cache-aside: додаток спочатку шукає дані в кеші; якщо їх немає, читає з бази, а потім записує в кеш."
  }
},
{
  "model": "interview_app.option",
  "pk": 772,
  "fields": {
    "question": 258,
    "key": "a",
    "text": "Це оптимізація запитів шляхом створення додаткових індексів."
  }
},
{
  "model": "interview_app.option",
  "pk": 773,
  "fields": {
    "question": 258,
    "key": "b",
    "text": "Це процес створення повної копії бази даних (репліки) для підвищення доступності."
  }
},
{
  "model": "interview_app.option",
  "pk": 774,
  "fields": {
    "question": 258,
    "key": "c",
    "text": "Це техніка горизонтального масштабування, при якій велика таблиця розбивається на менші частини (шарди) і розподіляється між кількома серверами."
  }
},
{
  "model": "interview_app.option",
  "pk": 775,
  "fields": {
    "question": 259,
    "key": "a",
    "text": "Він використовується для визначення методів, які можуть бути викликані лише зсередини класу."
  }
},
{
  "model": "interview_app.option",
  "pk": 776,
  "fields": {
    "question": 259,
    "key": "b",
    "text": "`__slots__` автоматично створює getter і setter для кожного атрибута, але уповільнює доступ до них."
  }
},
{
  "model": "interview_app.option",
  "pk": 777,
  "fields": {
    "question": 259,
    "key": "c",
    "text": "Він фіксує набір атрибутів екземпляра, що зменшує споживання пам'яті. Недоліком є те, що екземпляри не матимуть `__dict__` і не зможуть мати динамічних атрибутів."
  }
},
{
  "model": "interview_app.option",
  "pk": 778,
  "fields": {
    "question": 260,
    "key": "a",
    "text": "Це процес написання тестів після того, як весь функціонал програми вже реалізовано."
  }
},
{
  "model": "interview_app.option",
  "pk": 779,
  "fields": {
    "question": 260,
    "key": "b",
    "text": "Це методологія розробки, за якої спочатку пишеться тест, що не проходить, потім пишеться мінімальний код для його проходження, і наостанок код рефакториться."
  }
},
{
  "model": "interview_app.option",
  "pk": 780,
  "fields": {
    "question": 260,
    "key": "c",
    "text": "Це підхід, при якому тестуванням займається окрема команда, а не розробники."
  }
},
{
  "model": "interview_app.option",
  "pk": 781,
  "fields": {
    "question": 261,
    "key": "a",
    "text": "Це атака, яка змушує автентифікованого користувача виконувати небажані дії на сайті. Django захищає за допомогою CSRF-токена, який генерується для кожної сесії і має бути присутнім у POST-запитах."
  }
},
{
  "model": "interview_app.option",
  "pk": 782,
  "fields": {
    "question": 261,
    "key": "b",
    "text": "Це атака, при якій зловмисник впроваджує шкідливий JavaScript-код на сторінку. Django захищає, екрануючи всі змінні в шаблонах."
  }
},
{
  "model": "interview_app.option",
  "pk": 783,
  "fields": {
    "question": 261,
    "key": "c",
    "text": "Це спроба підібрати пароль користувача шляхом перебору. Django захищає, обмежуючи кількість спроб входу."
  }
},
{
  "model": "interview_app.option",
  "pk": 784,
  "fields": {
    "question": 262,
    "key": "a",
    "text": "Це база даних, оптимізована для зберігання текстових повідомлень з чатів."
  }
},
{
  "model": "interview_app.option",
  "pk": 785,
  "fields": {
    "question": 262,
    "key": "b",
    "text": "Це проміжне програмне забезпечення, яке дозволяє сервісам асинхронно обмінюватися повідомленнями, забезпечуючи слабку зв'язаність, масштабованість та надійність системи."
  }
},
{
  "model": "interview_app.option",
  "pk": 786,
  "fields": {
    "question": 262,
    "key": "c",
    "text": "Це вбудована функція Python для створення черг у багатопотокових програмах."
  }
},
{
  "model": "interview_app.option",
  "pk": 787,
  "fields": {
    "question": 263,
    "key": "a",
    "text": "Stateful-додатки завжди працюють швидше, оскільки їм не потрібно передавати дані в кожному запиті."
  }
},
{
  "model": "interview_app.option",
  "pk": 788,
  "fields": {
    "question": 263,
    "key": "b",
    "text": "Stateless-сервер не зберігає жодної інформації про клієнтські сесії; кожен запит містить усі необхідні дані. Stateful-сервер зберігає стан клієнта між запитами."
  }
},
{
  "model": "interview_app.option",
  "pk": 789,
  "fields": {
    "question": 263,
    "key": "c",
    "text": "Stateless-архітектура можлива лише при використанні NoSQL баз даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 790,
  "fields": {
    "question": 264,
    "key": "a",
    "text": "`ThreadPoolExecutor` використовує потоки (threads) і обмежений GIL, що добре для I/O-задач. `ProcessPoolExecutor` використовує процеси, обходячи GIL, і є ефективним для CPU-bound задач."
  }
},
{
  "model": "interview_app.option",
  "pk": 791,
  "fields": {
    "question": 264,
    "key": "b",
    "text": "`ProcessPoolExecutor` легший та швидший, оскільки процеси використовують менше пам'яті, ніж потоки."
  }
},
{
  "model": "interview_app.option",
  "pk": 792,
  "fields": {
    "question": 264,
    "key": "c",
    "text": "Різниці немає, вибір залежить лише від операційної системи."
  }
},
{
  "model": "interview_app.option",
  "pk": 793,
  "fields": {
    "question": 265,
    "key": "a",
    "text": "Це спосіб зберігання всіх логів з різних мікросервісів в одному місці для аналізу."
  }
},
{
  "model": "interview_app.option",
  "pk": 794,
  "fields": {
    "question": 265,
    "key": "b",
    "text": "Це патерн для керування розподіленими транзакціями, що складається з послідовності локальних транзакцій, де кожна наступна дія запускається після успіху попередньої, і для кожної дії є компенсуюча транзакція для відкату."
  }
},
{
  "model": "interview_app.option",
  "pk": 795,
  "fields": {
    "question": 265,
    "key": "c",
    "text": "Це архітектурний патерн, де один великий сервіс відповідає за координацію всіх інших."
  }
},
{
  "model": "interview_app.option",
  "pk": 796,
  "fields": {
    "question": 266,
    "key": "a",
    "text": "Це правило, згідно з яким кожен запит повинен містити команду, яку потрібно виконати."
  }
},
{
  "model": "interview_app.option",
  "pk": 797,
  "fields": {
    "question": 266,
    "key": "b",
    "text": "Це патерн, який розділяє моделі для читання даних (Query) і для їх зміни (Command), що дозволяє оптимізувати кожну частину окремо."
  }
},
{
  "model": "interview_app.option",
  "pk": 798,
  "fields": {
    "question": 266,
    "key": "c",
    "text": "Це техніка, при якій всі запити до бази даних кешуються для прискорення читання."
  }
},
{
  "model": "interview_app.option",
  "pk": 799,
  "fields": {
    "question": 267,
    "key": "a",
    "text": "Це споживач (consumer), який може безпечно обробляти одне й те саме повідомлення кілька разів без побічних ефектів, що гарантує коректність при повторних доставках."
  }
},
{
  "model": "interview_app.option",
  "pk": 800,
  "fields": {
    "question": 267,
    "key": "b",
    "text": "Це споживач, який споживає повідомлення лише один раз і ніколи не отримує дублікатів."
  }
},
{
  "model": "interview_app.option",
  "pk": 801,
  "fields": {
    "question": 267,
    "key": "c",
    "text": "Це тип споживача, який ігнорує всі повідомлення, що надходять до нього."
  }
},
{
  "model": "interview_app.option",
  "pk": 802,
  "fields": {
    "question": 268,
    "key": "a",
    "text": "Для створення резервної копії репозиторію перед виконанням небезпечних операцій."
  }
},
{
  "model": "interview_app.option",
  "pk": 803,
  "fields": {
    "question": 268,
    "key": "b",
    "text": "Для автоматичного пошуку коміту, який вніс помилку, за допомогою бінарного пошуку по історії комітів."
  }
},
{
  "model": "interview_app.option",
  "pk": 804,
  "fields": {
    "question": 268,
    "key": "c",
    "text": "Для розбиття одного великого коміту на кілька менших."
  }
},
{
  "model": "interview_app.option",
  "pk": 805,
  "fields": {
    "question": 269,
    "key": "a",
    "text": "Це інструмент для оптимізації розміру `.git` директорії шляхом стиснення старих об'єктів."
  }
},
{
  "model": "interview_app.option",
  "pk": 806,
  "fields": {
    "question": 269,
    "key": "b",
    "text": "Це візуалізація дерева комітів у репозиторії."
  }
},
{
  "model": "interview_app.option",
  "pk": 807,
  "fields": {
    "question": 269,
    "key": "c",
    "text": "Це команда, що дозволяє працювати з кількома гілками одночасно, маючи для кожної окрему робочу директорію, пов'язану з одним репозиторієм. Корисно для роботи над багом у старій версії, не перериваючи розробку в основній гілці."
  }
},
{
  "model": "interview_app.option",
  "pk": 808,
  "fields": {
    "question": 270,
    "key": "a",
    "text": "StatefulSet — це застаріла версія Deployment, яку не рекомендується використовувати."
  }
},
{
  "model": "interview_app.option",
  "pk": 809,
  "fields": {
    "question": 270,
    "key": "b",
    "text": "StatefulSet використовується для керування додатками, що потребують стабільної ідентичності (наприклад, ім'я поду) та постійного сховища. На відміну від Deployment, поди у StatefulSet мають унікальні та постійні імена."
  }
},
{
  "model": "interview_app.option",
  "pk": 810,
  "fields": {
    "question": 270,
    "key": "c",
    "text": "Deployment може керувати лише одним подом, тоді як StatefulSet керує багатьма."
  }
},
{
  "model": "interview_app.option",
  "pk": 811,
  "fields": {
    "question": 271,
    "key": "a",
    "text": "Це об'єкт API, який керує зовнішнім доступом до сервісів у кластері, зазвичай через HTTP/HTTPS, надаючи маршрутизацію на основі хоста або шляху та термінацію SSL."
  }
},
{
  "model": "interview_app.option",
  "pk": 812,
  "fields": {
    "question": 271,
    "key": "b",
    "text": "Це політика безпеки, що обмежує вхідний трафік до подів."
  }
},
{
  "model": "interview_app.option",
  "pk": 813,
  "fields": {
    "question": 271,
    "key": "c",
    "text": "Це внутрішня мережа Kubernetes, яка дозволяє подам спілкуватися між собою."
  }
},
{
  "model": "interview_app.option",
  "pk": 814,
  "fields": {
    "question": 272,
    "key": "a",
    "text": "Це функції для створення спливаючих вікон в інтерфейсі користувача бази даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 815,
  "fields": {
    "question": 272,
    "key": "b",
    "text": "Вони виконують обчислення на наборі рядків, пов'язаних з поточним рядком, не 'згортаючи' їх в один. Приклад: `ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC)` для нумерації співробітників у межах відділу."
  }
},
{
  "model": "interview_app.option",
  "pk": 816,
  "fields": {
    "question": 272,
    "key": "c",
    "text": "Це спеціальні функції, які працюють лише з даними, що знаходяться у певному часовому 'вікні'."
  }
},
{
  "model": "interview_app.option",
  "pk": 817,
  "fields": {
    "question": 273,
    "key": "a",
    "text": "CTE (використовуючи `WITH ... AS ...`) створюють тимчасовий іменований набір результатів, який можна використовувати в основному запиті, що покращує читабельність складних запитів та дозволяє рекурсивні запити."
  }
},
{
  "model": "interview_app.option",
  "pk": 818,
  "fields": {
    "question": 273,
    "key": "b",
    "text": "Це таблиці, які є спільними для всіх користувачів бази даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 819,
  "fields": {
    "question": 273,
    "key": "c",
    "text": "Це спосіб стиснення таблиць для економії місця на диску."
  }
},
{
  "model": "interview_app.option",
  "pk": 820,
  "fields": {
    "question": 274,
    "key": "a",
    "text": "Це структура, яка дозволяє сортувати ключі, а не значення, в Redis."
  }
},
{
  "model": "interview_app.option",
  "pk": 821,
  "fields": {
    "question": 274,
    "key": "b",
    "text": "Для зберігання множин, які автоматично сортуються в алфавітному порядку."
  }
},
{
  "model": "interview_app.option",
  "pk": 822,
  "fields": {
    "question": 274,
    "key": "c",
    "text": "Для зберігання унікальних елементів, де кожен елемент має пов'язаний з ним числовий 'score', що дозволяє швидко отримувати елементи, відсортовані за цим score. Використовується для рейтингів, лідербордів."
  }
},
{
  "model": "interview_app.option",
  "pk": 823,
  "fields": {
    "question": 275,
    "key": "a",
    "text": "Це посилання на об'єкт, яке не перешкоджає його видаленню збирачем сміття. `weakref` корисний для реалізації кешів або для уникнення циклічних посилань."
  }
},
{
  "model": "interview_app.option",
  "pk": 824,
  "fields": {
    "question": 275,
    "key": "b",
    "text": "Це тип посилання, який не можна змінити після створення."
  }
},
{
  "model": "interview_app.option",
  "pk": 825,
  "fields": {
    "question": 275,
    "key": "c",
    "text": "Це посилання, яке працює повільніше за звичайне, але є більш безпечним."
  }
},
{
  "model": "interview_app.option",
  "pk": 826,
  "fields": {
    "question": 276,
    "key": "a",
    "text": "Це декоратор, який кешує результати викликів функції. Коли кеш заповнюється, він видаляє результат, який використовувався найдавніше (Least Recently Used), щоб звільнити місце для нового."
  }
},
{
  "model": "interview_app.option",
  "pk": 827,
  "fields": {
    "question": 276,
    "key": "b",
    "text": "Він кешує абсолютно всі результати функції, що може призвести до витоку пам'яті."
  }
},
{
  "model": "interview_app.option",
  "pk": 828,
  "fields": {
    "question": 276,
    "key": "c",
    "text": "Він видаляє з кешу результат, який використовувався найчастіше, щоб уникнути застарілих даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 829,
  "fields": {
    "question": 277,
    "key": "a",
    "text": "Конкурентність — це здатність системи обробляти кілька задач, керуючи їх виконанням (можливо, в одному потоці). Паралелізм — це одночасне виконання кількох задач (наприклад, на кількох ядрах CPU)."
  }
},
{
  "model": "interview_app.option",
  "pk": 830,
  "fields": {
    "question": 277,
    "key": "b",
    "text": "Це синоніми, які описують багатозадачність."
  }
},
{
  "model": "interview_app.option",
  "pk": 831,
  "fields": {
    "question": 277,
    "key": "c",
    "text": "Паралелізм можливий лише за допомогою `asyncio`, а конкурентність — за допомогою `multiprocessing`."
  }
},
{
  "model": "interview_app.option",
  "pk": 832,
  "fields": {
    "question": 278,
    "key": "a",
    "text": "Це помилка, коли база даних не може знайти запис через відсутність індексу."
  }
},
{
  "model": "interview_app.option",
  "pk": 833,
  "fields": {
    "question": 278,
    "key": "b",
    "text": "Це стан, коли сервер бази даних перестає відповідати через надмірне навантаження."
  }
},
{
  "model": "interview_app.option",
  "pk": 834,
  "fields": {
    "question": 278,
    "key": "c",
    "text": "Це ситуація, коли дві або більше транзакцій взаємно блокують одна одну, очікуючи на ресурси, які захоплені іншою. Уникнути можна, встановлюючи однаковий порядок блокування ресурсів та використовуючи короткі транзакції."
  }
},
{
  "model": "interview_app.option",
  "pk": 835,
  "fields": {
    "question": 279,
    "key": "a",
    "text": "Це тестування, яке перевіряє лише властивості об'єктів, а не їхню поведінку."
  }
},
{
  "model": "interview_app.option",
  "pk": 836,
  "fields": {
    "question": 279,
    "key": "b",
    "text": "На відміну від тестування на конкретних прикладах, property-based testing (напр., з бібліотекою `Hypothesis`) генерує безліч випадкових даних, що відповідають певним властивостям, для пошуку крайніх випадків (edge cases)."
  }
},
{
  "model": "interview_app.option",
  "pk": 837,
  "fields": {
    "question": 279,
    "key": "c",
    "text": "Це ручне тестування, де тестувальник перевіряє властивості програми згідно зі специфікацією."
  }
},
{
  "model": "interview_app.option",
  "pk": 838,
  "fields": {
    "question": 280,
    "key": "a",
    "text": "Для керування процесом міграцій бази даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 839,
  "fields": {
    "question": 280,
    "key": "b",
    "text": "Для додавання методів, що працюють на рівні таблиці (наприклад, `Post.objects.published()`), або для зміни початкового QuerySet (наприклад, для виключення неактивних записів за замовчуванням)."
  }
},
{
  "model": "interview_app.option",
  "pk": 840,
  "fields": {
    "question": 280,
    "key": "c",
    "text": "Для створення нових користувачів з особливими правами доступу."
  }
},
{
  "model": "interview_app.option",
  "pk": 841,
  "fields": {
    "question": 281,
    "key": "a",
    "text": "Це процес стиснення відповідей сервера для зменшення трафіку."
  }
},
{
  "model": "interview_app.option",
  "pk": 842,
  "fields": {
    "question": 281,
    "key": "b",
    "text": "Це механізм для обмеження частоти запитів до API від одного користувача або IP-адреси для запобігання зловживанням."
  }
},
{
  "model": "interview_app.option",
  "pk": 843,
  "fields": {
    "question": 281,
    "key": "c",
    "text": "Це спосіб оптимізації запитів до бази даних шляхом зменшення їх кількості."
  }
},
{
  "model": "interview_app.option",
  "pk": 844,
  "fields": {
    "question": 282,
    "key": "a",
    "text": "Це асинхронні функції, які виконуються один раз при старті (`startup`) та зупинці (`shutdown`) додатку, що корисно для ініціалізації пулів з'єднань або фонових задач."
  }
},
{
  "model": "interview_app.option",
  "pk": 845,
  "fields": {
    "question": 282,
    "key": "b",
    "text": "Це механізм для керування тривалістю життя JWT-токенів."
  }
},
{
  "model": "interview_app.option",
  "pk": 846,
  "fields": {
    "question": 282,
    "key": "c",
    "text": "Це події, які відстежують життєвий цикл кожного окремого HTTP-запиту."
  }
},
{
  "model": "interview_app.option",
  "pk": 847,
  "fields": {
    "question": 283,
    "key": "a",
    "text": "Це потік, де додаток отримує токен доступу безпосередньо, передавши логін і пароль користувача."
  }
},
{
  "model": "interview_app.option",
  "pk": 848,
  "fields": {
    "question": 283,
    "key": "b",
    "text": "Це потік, де користувач перенаправляється на сервер авторизації, надає згоду, отримує код авторизації, який додаток потім обмінює на токен доступу. Це найбезпечніший потік для веб-додатків."
  }
},
{
  "model": "interview_app.option",
  "pk": 849,
  "fields": {
    "question": 283,
    "key": "c",
    "text": "Це спрощений потік, де токен доступу передається клієнту відразу в URL після авторизації."
  }
},
{
  "model": "interview_app.option",
  "pk": 850,
  "fields": {
    "question": 284,
    "key": "a",
    "text": "Це процес приховування секретів у коді за допомогою обфускації."
  }
},
{
  "model": "interview_app.option",
  "pk": 851,
  "fields": {
    "question": 284,
    "key": "b",
    "text": "Secrets management — це політика, яка дозволяє зберігати секрети в Git, але лише в приватних репозиторіях."
  }
},
{
  "model": "interview_app.option",
  "pk": 852,
  "fields": {
    "question": 284,
    "key": "c",
    "text": "Це практика безпечного зберігання та доступу до чутливих даних (паролі, ключі API). Зберігання в Git небезпечне, оскільки історія комітів робить їх видимими, навіть якщо їх видалити. Слід використовувати інструменти, як-от HashiCorp Vault або AWS Secrets Manager."
  }
},
{
  "model": "interview_app.option",
  "pk": 853,
  "fields": {
    "question": 285,
    "key": "a",
    "text": "Це практика запису логів у форматі, що легко парситься машиною (напр., JSON), замість простого тексту. Це значно спрощує пошук, фільтрацію та аналіз логів у системах, як-от Elasticsearch."
  }
},
{
  "model": "interview_app.option",
  "pk": 854,
  "fields": {
    "question": 285,
    "key": "b",
    "text": "Це логування, яке включає повний stack trace для кожної помилки."
  }
},
{
  "model": "interview_app.option",
  "pk": 855,
  "fields": {
    "question": 285,
    "key": "c",
    "text": "Це створення структури директорій для зберігання лог-файлів."
  }
},
{
  "model": "interview_app.option",
  "pk": 856,
  "fields": {
    "question": 286,
    "key": "a",
    "text": "Для повної зупинки всіх корутин в циклі подій."
  }
},
{
  "model": "interview_app.option",
  "pk": 857,
  "fields": {
    "question": 286,
    "key": "b",
    "text": "Для обмеження кількості одночасних корутин, які можуть отримати доступ до певного ресурсу, що допомагає уникнути перевантаження зовнішніх сервісів."
  }
},
{
  "model": "interview_app.option",
  "pk": 858,
  "fields": {
    "question": 286,
    "key": "c",
    "text": "Для передачі сигналу від однієї корутини до іншої про завершення операції."
  }
},
{
  "model": "interview_app.option",
  "pk": 859,
  "fields": {
    "question": 287,
    "key": "a",
    "text": "`contextvars` — це застарілий модуль, замінений на `thread.local`."
  }
},
{
  "model": "interview_app.option",
  "pk": 860,
  "fields": {
    "question": 287,
    "key": "b",
    "text": "`contextvars` дозволяють зберігати контекстно-локальні дані, що є ключовим для асинхронного коду, де одна і та ж змінна може мати різні значення для різних задач, що виконуються в одному потоці. `thread.local` працює лише на рівні потоку."
  }
},
{
  "model": "interview_app.option",
  "pk": 861,
  "fields": {
    "question": 287,
    "key": "c",
    "text": "Різниці немає, `contextvars` — це псевдонім для `thread.local` для `asyncio`."
  }
},
{
  "model": "interview_app.option",
  "pk": 862,
  "fields": {
    "question": 288,
    "key": "a",
    "text": "Це техніка перевірки якості тестів, при якій у вихідний код вносяться невеликі зміни ('мутації'). Якщо тести не падають, це означає, що вони недостатньо надійні."
  }
},
{
  "model": "interview_app.option",
  "pk": 863,
  "fields": {
    "question": 288,
    "key": "b",
    "text": "Це процес автоматичної генерації тестів на основі аналізу коду."
  }
},
{
  "model": "interview_app.option",
  "pk": 864,
  "fields": {
    "question": 288,
    "key": "c",
    "text": "Це тестування, яке перевіряє, чи можна змінювати (мутувати) об'єкти в програмі."
  }
},
{
  "model": "interview_app.option",
  "pk": 865,
  "fields": {
    "question": 289,
    "key": "a",
    "text": "Єдина стратегія — це зберігати кожну версію API в окремій гілці Git."
  }
},
{
  "model": "interview_app.option",
  "pk": 866,
  "fields": {
    "question": 289,
    "key": "b",
    "text": "Версіонування в URL (v1/users), через заголовок запиту (Accept: application/vnd.myapi.v1+json), або через параметр запиту (?version=1)."
  }
},
{
  "model": "interview_app.option",
  "pk": 867,
  "fields": {
    "question": 289,
    "key": "c",
    "text": "Версіонування не потрібне, якщо API має зворотну сумісність."
  }
},
{
  "model": "interview_app.option",
  "pk": 868,
  "fields": {
    "question": 290,
    "key": "a",
    "text": "Це алгоритм, який мінімізує кількість ключів, що потребують перерозподілу при додаванні або видаленні одного вузла (сервера) у розподіленому хешуванні. Часто використовується в кешуванні та розподілених базах даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 869,
  "fields": {
    "question": 290,
    "key": "b",
    "text": "Це техніка, при якій хеш-функція завжди повертає однаковий результат для будь-яких вхідних даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 870,
  "fields": {
    "question": 290,
    "key": "c",
    "text": "Це спосіб хешування, який гарантує відсутність колізій."
  }
},
{
  "model": "interview_app.option",
  "pk": 871,
  "fields": {
    "question": 291,
    "key": "a",
    "text": "Це ймовірнісна структура даних, що дозволяє дуже ефективно за пам'яттю перевіряти, чи є елемент членом множини. Може давати хибнопозитивні відповіді (false positives), але ніколи хибнонегативні. Використовується для уникнення дорогих дискових або мережевих операцій."
  }
},
{
  "model": "interview_app.option",
  "pk": 872,
  "fields": {
    "question": 291,
    "key": "b",
    "text": "Це фільтр для очищення зображень від шумів."
  }
},
{
  "model": "interview_app.option",
  "pk": 873,
  "fields": {
    "question": 291,
    "key": "c",
    "text": "Це структура даних, яка гарантує 100% точність при перевірці належності до множини."
  }
},
{
  "model": "interview_app.option",
  "pk": 874,
  "fields": {
    "question": 292,
    "key": "a",
    "text": "Це тестування, яке виконується в окремих підпроцесах для паралелізму."
  }
},
{
  "model": "interview_app.option",
  "pk": 875,
  "fields": {
    "question": 292,
    "key": "b",
    "text": "Це спосіб запустити лише частину тестів з усього набору."
  }
},
{
  "model": "interview_app.option",
  "pk": 876,
  "fields": {
    "question": 292,
    "key": "c",
    "text": "Він дозволяє виконувати кілька перевірок всередині одного тестового методу, і при цьому тест не зупиняється після першого ж збою, а повідомляє про всі невдалі перевірки в кінці."
  }
},
{
  "model": "interview_app.option",
  "pk": 877,
  "fields": {
    "question": 293,
    "key": "a",
    "text": "`chain` — для коротких задач, `group` — для середніх, `chord` — для дуже довгих."
  }
},
{
  "model": "interview_app.option",
  "pk": 878,
  "fields": {
    "question": 293,
    "key": "b",
    "text": "Це три різні назви для одного й того ж механізму паралельного запуску задач."
  }
},
{
  "model": "interview_app.option",
  "pk": 879,
  "fields": {
    "question": 293,
    "key": "c",
    "text": "`chain` — послідовне виконання задач. `group` — паралельне виконання. `chord` — паралельне виконання групи задач з подальшим викликом однієї callback-задачі після завершення всіх."
  }
},
{
  "model": "interview_app.option",
  "pk": 880,
  "fields": {
    "question": 294,
    "key": "a",
    "text": "Це механізм, який дозволяє сервісам автоматично знаходити один одного в динамічному середовищі, де IP-адреси та порти можуть змінюватися. Приклади: Consul, Eureka."
  }
},
{
  "model": "interview_app.option",
  "pk": 881,
  "fields": {
    "question": 294,
    "key": "b",
    "text": "Це документація, яка описує, як знайти кожен сервіс у системі."
  }
},
{
  "model": "interview_app.option",
  "pk": 882,
  "fields": {
    "question": 294,
    "key": "c",
    "text": "Це процес ручного прописування адрес сервісів у конфігураційних файлах."
  }
},
{
  "model": "interview_app.option",
  "pk": 883,
  "fields": {
    "question": 295,
    "key": "a",
    "text": "Це процес спостереження за користувачами для покращення UX."
  }
},
{
  "model": "interview_app.option",
  "pk": 884,
  "fields": {
    "question": 295,
    "key": "b",
    "text": "Це здатність розуміти внутрішній стан системи, аналізуючи її зовнішні виходи. Складається з логів (Logs), метрик (Metrics) та трейсів (Traces)."
  }
},
{
  "model": "interview_app.option",
  "pk": 885,
  "fields": {
    "question": 295,
    "key": "c",
    "text": "Це синонім моніторингу, який складається з перевірки CPU, пам'яті та диска."
  }
},
{
  "model": "interview_app.option",
  "pk": 886,
  "fields": {
    "question": 296,
    "key": "a",
    "text": "Для отримання детального плану виконання SQL-запиту, включаючи реальний час виконання кожної операції, що допомагає знаходити вузькі місця та оптимізувати запити."
  }
},
{
  "model": "interview_app.option",
  "pk": 887,
  "fields": {
    "question": 296,
    "key": "b",
    "text": "Для аналізу використання дискового простору таблицями та індексами."
  }
},
{
  "model": "interview_app.option",
  "pk": 888,
  "fields": {
    "question": 296,
    "key": "c",
    "text": "Для пояснення синтаксису будь-якої SQL-команди."
  }
},
{
  "model": "interview_app.option",
  "pk": 889,
  "fields": {
    "question": 297,
    "key": "a",
    "text": "Це курсори, які отримують дані з бази даних не всі одразу, а порціями, що дозволяє обробляти дуже великі набори результатів, не завантажуючи їх повністю в пам'ять клієнта."
  }
},
{
  "model": "interview_app.option",
  "pk": 890,
  "fields": {
    "question": 297,
    "key": "b",
    "text": "Це спосіб керувати курсором миші на сервері через клієнтський додаток."
  }
},
{
  "model": "interview_app.option",
  "pk": 891,
  "fields": {
    "question": 297,
    "key": "c",
    "text": "Це курсори, які виконуються безпосередньо на сервері без участі клієнта."
  }
},
{
  "model": "interview_app.option",
  "pk": 892,
  "fields": {
    "question": 298,
    "key": "a",
    "text": "Створити клас, що успадковується від `BaseAuthentication`, і реалізувати в ньому метод `authenticate`, який повертає кортеж `(user, auth)` або `None`."
  }
},
{
  "model": "interview_app.option",
  "pk": 893,
  "fields": {
    "question": 298,
    "key": "b",
    "text": "Змінити вихідний код Django для додавання нового способу аутентифікації."
  }
},
{
  "model": "interview_app.option",
  "pk": 894,
  "fields": {
    "question": 298,
    "key": "c",
    "text": "Використовувати сигнали `user_logged_in` та `user_logged_out` для перевірки токенів."
  }
},
{
  "model": "interview_app.option",
  "pk": 895,
  "fields": {
    "question": 299,
    "key": "a",
    "text": "Це вимога писати код, який складається максимум з 12 файлів."
  }
},
{
  "model": "interview_app.option",
  "pk": 896,
  "fields": {
    "question": 299,
    "key": "b",
    "text": "Це набір дванадцяти найкращих практик для створення програм-сервісів (SaaS), які забезпечують портативність, масштабованість та легкість розгортання в хмарних середовищах."
  }
},
{
  "model": "interview_app.option",
  "pk": 897,
  "fields": {
    "question": 299,
    "key": "c",
    "text": "Це методологія тестування, що включає 12 етапів перевірки якості."
  }
},
{
  "model": "interview_app.option",
  "pk": 898,
  "fields": {
    "question": 300,
    "key": "a",
    "text": "CFFI — це частина стандартної бібліотеки Python, а Cython — сторонній фреймворк."
  }
},
{
  "model": "interview_app.option",
  "pk": 899,
  "fields": {
    "question": 300,
    "key": "b",
    "text": "Cython — це компілятор, який перетворює Python-подібний код з анотаціями типів у C, що вимагає компіляції. CFFI (C Foreign Function Interface) дозволяє викликати скомпільований C-код безпосередньо з Python, що простіше для інтеграції з існуючими бібліотеками."
  }
},
{
  "model": "interview_app.option",
  "pk": 900,
  "fields": {
    "question": 300,
    "key": "c",
    "text": "Cython працює тільки на Linux, а CFFI — на Windows."
  }
},
{
  "model": "interview_app.option",
  "pk": 901,
  "fields": {
    "question": 301,
    "key": "a",
    "text": "Це логування всіх мережевих пакетів, які проходять між сервісами."
  }
},
{
  "model": "interview_app.option",
  "pk": 902,
  "fields": {
    "question": 301,
    "key": "b",
    "text": "Це трасування викликів функцій всередині одного сервісу."
  }
},
{
  "model": "interview_app.option",
  "pk": 903,
  "fields": {
    "question": 301,
    "key": "c",
    "text": "Це процес відстеження повного шляху запиту, який проходить через кілька мікросервісів. Кожному запиту присвоюється унікальний ID, що дозволяє візуалізувати затримки на кожному етапі та швидко знаходити проблеми. Приклади: Jaeger, OpenTelemetry."
  }
},
{
  "model": "interview_app.option",
  "pk": 904,
  "fields": {
    "question": 302,
    "key": "a",
    "text": "Broker і backend — це два компоненти, що відповідають за моніторинг стану воркерів."
  }
},
{
  "model": "interview_app.option",
  "pk": 905,
  "fields": {
    "question": 302,
    "key": "b",
    "text": "Broker (напр., RabbitMQ, Redis) — це черга повідомлень, куди 'producer' відправляє задачі. Backend (напр., Redis, база даних) — це сховище, де зберігаються результати виконання задач."
  }
},
{
  "model": "interview_app.option",
  "pk": 906,
  "fields": {
    "question": 302,
    "key": "c",
    "text": "Broker виконує задачі, а backend їх розподіляє між воркерами."
  }
},
{
  "model": "interview_app.option",
  "pk": 907,
  "fields": {
    "question": 303,
    "key": "a",
    "text": "Prometheus призначений виключно для моніторингу Kubernetes і не може використовуватися для інших систем."
  }
},
{
  "model": "interview_app.option",
  "pk": 908,
  "fields": {
    "question": 303,
    "key": "b",
    "text": "Prometheus використовує 'pull' модель, де він сам періодично збирає метрики з сервісів по HTTP, на відміну від 'push' моделі, де сервіси самі відправляють дані. Це робить його більш стійким до відмов."
  }
},
{
  "model": "interview_app.option",
  "pk": 909,
  "fields": {
    "question": 303,
    "key": "c",
    "text": "Prometheus може зберігати лише текстові логи, а не числові метрики."
  }
},
{
  "model": "interview_app.option",
  "pk": 910,
  "fields": {
    "question": 304,
    "key": "a",
    "text": "Це деревоподібна структура даних для ефективного зберігання та пошуку рядків за префіксами. Часто використовується для реалізації автодоповнення (autocomplete) у пошукових системах."
  }
},
{
  "model": "interview_app.option",
  "pk": 911,
  "fields": {
    "question": 304,
    "key": "b",
    "text": "Це спосіб стиснення даних, заснований на повторюваних префіксах."
  }
},
{
  "model": "interview_app.option",
  "pk": 912,
  "fields": {
    "question": 304,
    "key": "c",
    "text": "Це алгоритм сортування, оптимізований для коротких рядків."
  }
},
{
  "model": "interview_app.option",
  "pk": 913,
  "fields": {
    "question": 305,
    "key": "a",
    "text": "Клас повинен мати лише одну причину для змін. Порушення призводить до створення класів, які важко підтримувати."
  }
},
{
  "model": "interview_app.option",
  "pk": 914,
  "fields": {
    "question": 305,
    "key": "b",
    "text": "Об'єкти дочірніх класів повинні мати можливість замінювати об'єкти батьківського класу без зміни коректності програми. Порушення призводить до необхідності перевірок типу (`isinstance`) та порушення поліморфізму."
  }
},
{
  "model": "interview_app.option",
  "pk": 915,
  "fields": {
    "question": 305,
    "key": "c",
    "text": "Програмні сутності повинні бути відкриті для розширення, але закриті для модифікації."
  }
},
{
  "model": "interview_app.option",
  "pk": 916,
  "fields": {
    "question": 306,
    "key": "a",
    "text": "Це принцип, який вимагає, щоб усі залежності були вказані в одному конфігураційному файлі."
  }
},
{
  "model": "interview_app.option",
  "pk": 917,
  "fields": {
    "question": 306,
    "key": "b",
    "text": "DIP стверджує, що модулі вищого рівня не повинні залежати від модулів нижчого рівня; обидва повинні залежати від абстракцій. Dependency Injection є одним зі способів реалізації цього принципу."
  }
},
{
  "model": "interview_app.option",
  "pk": 918,
  "fields": {
    "question": 306,
    "key": "c",
    "text": "DIP — це процес інвертування порядку виконання коду для оптимізації."
  }
},
{
  "model": "interview_app.option",
  "pk": 919,
  "fields": {
    "question": 307,
    "key": "a",
    "text": "Це об'єкт, що представляє описову характеристику і визначається своїми атрибутами, а не ідентичністю. Він є незмінним (immutable). Приклад: об'єкт грошей (сума, валюта)."
  }
},
{
  "model": "interview_app.option",
  "pk": 920,
  "fields": {
    "question": 307,
    "key": "b",
    "text": "Це спеціальний об'єкт, який використовується для передачі даних між сервісами."
  }
},
{
  "model": "interview_app.option",
  "pk": 921,
  "fields": {
    "question": 307,
    "key": "c",
    "text": "Це об'єкт, який завжди має унікальний ідентифікатор і може змінювати свій стан."
  }
},
{
  "model": "interview_app.option",
  "pk": 922,
  "fields": {
    "question": 308,
    "key": "a",
    "text": "GraphQL — це мова запитів для API, яка дозволяє клієнту запитувати точно ті дані, які йому потрібні, в одному запиті, на відміну від REST, де клієнт отримує фіксований набір даних з кількох ендпоінтів."
  }
},
{
  "model": "interview_app.option",
  "pk": 923,
  "fields": {
    "question": 308,
    "key": "b",
    "text": "GraphQL працює лише з графовими базами даних, тоді як REST працює з реляційними."
  }
},
{
  "model": "interview_app.option",
  "pk": 924,
  "fields": {
    "question": 308,
    "key": "c",
    "text": "GraphQL — це нова версія REST, яка використовує протокол UDP для швидшої передачі даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 925,
  "fields": {
    "question": 309,
    "key": "a",
    "text": "Це декоратор, який автоматично оптимізує використання пам'яті функцією."
  }
},
{
  "model": "interview_app.option",
  "pk": 926,
  "fields": {
    "question": 309,
    "key": "b",
    "text": "`memoryview` створює об'єкт, що надає доступ до внутрішніх даних іншого об'єкта (наприклад, `bytes`) без копіювання. Це ефективно при роботі з великими об'єктами, де потрібно робити зрізи або змінювати дані 'на місці'."
  }
},
{
  "model": "interview_app.option",
  "pk": 927,
  "fields": {
    "question": 309,
    "key": "c",
    "text": "Це функція, яка показує, скільки пам'яті використовує кожен об'єкт у програмі."
  }
},
{
  "model": "interview_app.option",
  "pk": 928,
  "fields": {
    "question": 310,
    "key": "a",
    "text": "Це пакети, які можуть бути розділені на кілька директорій, дозволяючи різним бібліотекам доповнювати один і той же простір імен. На відміну від звичайних пакетів, їм не потрібен файл `__init__.py` (у Python 3.3+)."
  }
},
{
  "model": "interview_app.option",
  "pk": 929,
  "fields": {
    "question": 310,
    "key": "b",
    "text": "Це пакети, які автоматично імпортуються при запуску Python."
  }
},
{
  "model": "interview_app.option",
  "pk": 930,
  "fields": {
    "question": 310,
    "key": "c",
    "text": "Це спеціальні пакети для роботи з просторами імен у Kubernetes."
  }
},
{
  "model": "interview_app.option",
  "pk": 931,
  "fields": {
    "question": 311,
    "key": "a",
    "text": "Це тип індексу, який використовується для шифрування даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 932,
  "fields": {
    "question": 311,
    "key": "b",
    "text": "Це індекс, який покриває абсолютно всі колонки в таблиці."
  }
},
{
  "model": "interview_app.option",
  "pk": 933,
  "fields": {
    "question": 311,
    "key": "c",
    "text": "Це індекс, який містить усі поля, необхідні для виконання запиту. Це дозволяє базі даних отримати всі дані безпосередньо з індексу, не звертаючись до самої таблиці, що значно прискорює запит."
  }
},
{
  "model": "interview_app.option",
  "pk": 934,
  "fields": {
    "question": 312,
    "key": "a",
    "text": "Синхронна реплікація швидша, оскільки дані передаються негайно."
  }
},
{
  "model": "interview_app.option",
  "pk": 935,
  "fields": {
    "question": 312,
    "key": "b",
    "text": "Асинхронна реплікація використовується лише для резервного копіювання, а не для високої доступності."
  }
},
{
  "model": "interview_app.option",
  "pk": 936,
  "fields": {
    "question": 312,
    "key": "c",
    "text": "При синхронній реплікації основна транзакція не завершується, доки зміни не будуть записані на репліку. При асинхронній — транзакція завершується відразу, а зміни передаються на репліку у фоновому режимі."
  }
},
{
  "model": "interview_app.option",
  "pk": 937,
  "fields": {
    "question": 313,
    "key": "a",
    "text": "Це розширення PostgreSQL для виконання Python-коду всередині бази даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 938,
  "fields": {
    "question": 313,
    "key": "b",
    "text": "Це легкий пулер з'єднань для PostgreSQL, який зменшує навантаження на базу даних, керуючи великою кількістю клієнтських підключень через невеликий пул реальних з'єднань до БД."
  }
},
{
  "model": "interview_app.option",
  "pk": 939,
  "fields": {
    "question": 313,
    "key": "c",
    "text": "Це інструмент для автоматичного відкату невдалих транзакцій у PostgreSQL."
  }
},
{
  "model": "interview_app.option",
  "pk": 940,
  "fields": {
    "question": 314,
    "key": "a",
    "text": "Це функції для форматування рядків у відповідях сервера."
  }
},
{
  "model": "interview_app.option",
  "pk": 941,
  "fields": {
    "question": 314,
    "key": "b",
    "text": "Це спосіб викликати довільні функції бази даних з Django."
  }
},
{
  "model": "interview_app.option",
  "pk": 942,
  "fields": {
    "question": 314,
    "key": "c",
    "text": "Вони дозволяють посилатися на значення полів моделі безпосередньо в запитах до бази даних, уникаючи завантаження даних в пам'ять Python. Це корисно для атомарних оновлень (`product.price = F('price') + 1`)."
  }
},
{
  "model": "interview_app.option",
  "pk": 943,
  "fields": {
    "question": 315,
    "key": "a",
    "text": "Вони використовуються для побудови складних запитів з логічними операторами `AND` (`&`) та `OR` (`|`), які неможливо виразити через послідовні виклики `.filter()`."
  }
},
{
  "model": "interview_app.option",
  "pk": 944,
  "fields": {
    "question": 315,
    "key": "b",
    "text": "Це об'єкти для створення черг асинхронних задач."
  }
},
{
  "model": "interview_app.option",
  "pk": 945,
  "fields": {
    "question": 315,
    "key": "c",
    "text": "Це спеціальні об'єкти для роботи з JSON-полями в базі даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 946,
  "fields": {
    "question": 316,
    "key": "a",
    "text": "`APIView` працює швидше, оскільки не має додаткових абстракцій."
  }
},
{
  "model": "interview_app.option",
  "pk": 947,
  "fields": {
    "question": 316,
    "key": "b",
    "text": "`APIView` є базовим класом для обробки HTTP-методів. `ViewSet` об'єднує логіку для набору пов'язаних представлень в один клас і зазвичай використовується з роутерами для автоматичної генерації URL."
  }
},
{
  "model": "interview_app.option",
  "pk": 948,
  "fields": {
    "question": 316,
    "key": "c",
    "text": "`ViewSet` призначений тільки для читання даних, а `APIView` — для їх зміни."
  }
},
{
  "model": "interview_app.option",
  "pk": 949,
  "fields": {
    "question": 317,
    "key": "a",
    "text": "`Future` використовується для синхронного коду, а `Task` — для асинхронного."
  }
},
{
  "model": "interview_app.option",
  "pk": 950,
  "fields": {
    "question": 317,
    "key": "b",
    "text": "`Task` створює новий потік для виконання корутини, а `Future` — ні."
  }
},
{
  "model": "interview_app.option",
  "pk": 951,
  "fields": {
    "question": 317,
    "key": "c",
    "text": "`Future` — це об'єкт-заповнювач, що представляє майбутній результат асинхронної операції. `Task` — це підклас `Future`, який обгортає і керує виконанням корутини в циклі подій."
  }
},
{
  "model": "interview_app.option",
  "pk": 952,
  "fields": {
    "question": 318,
    "key": "a",
    "text": "Це виділений інфраструктурний шар для керування комунікацією між сервісами, який надає такі функції, як моніторинг, трасування, балансування навантаження та безпека, без змін у коді додатків."
  }
},
{
  "model": "interview_app.option",
  "pk": 953,
  "fields": {
    "question": 318,
    "key": "b",
    "text": "Це бібліотека Python, яка додається до кожного сервісу для спілкування з іншими."
  }
},
{
  "model": "interview_app.option",
  "pk": 954,
  "fields": {
    "question": 318,
    "key": "c",
    "text": "Це фізична мережа, оптимізована для роботи мікросервісів."
  }
},
{
  "model": "interview_app.option",
  "pk": 955,
  "fields": {
    "question": 319,
    "key": "a",
    "text": "Gunicorn створює новий потік для кожного вхідного запиту, що дозволяє обробляти тисячі з'єднань одночасно."
  }
},
{
  "model": "interview_app.option",
  "pk": 956,
  "fields": {
    "question": 319,
    "key": "b",
    "text": "Gunicorn — це WSGI-сервер. Він створює головний процес, який перед початком обробки запитів 'форкає' (створює копії) кілька дочірніх процесів (воркерів). Кожен воркер обробляє запити послідовно."
  }
},
{
  "model": "interview_app.option",
  "pk": 957,
  "fields": {
    "question": 319,
    "key": "c",
    "text": "Gunicorn — це ASGI-сервер, який використовує один процес для обробки всіх запитів асинхронно."
  }
},
{
  "model": "interview_app.option",
  "pk": 958,
  "fields": {
    "question": 320,
    "key": "a",
    "text": "Це спроба отримати доступ до файлів на сервері через URL."
  }
},
{
  "model": "interview_app.option",
  "pk": 959,
  "fields": {
    "question": 320,
    "key": "b",
    "text": "Це атака, при якій зловмисник впроваджує шкідливий скрипт на сторінку, що переглядається іншими користувачами. Захист полягає в екрануванні (escaping) всього користувацького контенту перед відображенням."
  }
},
{
  "model": "interview_app.option",
  "pk": 960,
  "fields": {
    "question": 320,
    "key": "c",
    "text": "Це атака, що змушує браузер користувача виконати запит на інший сайт. Захист — використання CSRF-токенів."
  }
},
{
  "model": "interview_app.option",
  "pk": 961,
  "fields": {
    "question": 321,
    "key": "a",
    "text": "Це помилка, коли дані серіалізуються у неправильному форматі."
  }
},
{
  "model": "interview_app.option",
  "pk": 962,
  "fields": {
    "question": 321,
    "key": "b",
    "text": "Це вразливість, що виникає при десеріалізації даних з ненадійного джерела (наприклад, `pickle`), що може призвести до виконання довільного коду на сервері."
  }
},
{
  "model": "interview_app.option",
  "pk": 963,
  "fields": {
    "question": 321,
    "key": "c",
    "text": "Це процес десеріалізації, який відбувається дуже повільно і блокує додаток."
  }
},
{
  "model": "interview_app.option",
  "pk": 964,
  "fields": {
    "question": 322,
    "key": "a",
    "text": "WAF — це фільтр, що знаходиться між клієнтом та веб-додатком і аналізує HTTP-трафік для блокування поширених атак, таких як XSS та SQL-ін'єкції."
  }
},
{
  "model": "interview_app.option",
  "pk": 965,
  "fields": {
    "question": 322,
    "key": "b",
    "text": "Це брандмауер, вбудований безпосередньо в код веб-фреймворку."
  }
},
{
  "model": "interview_app.option",
  "pk": 966,
  "fields": {
    "question": 322,
    "key": "c",
    "text": "Це антивірус, встановлений на веб-сервері."
  }
},
{
  "model": "interview_app.option",
  "pk": 967,
  "fields": {
    "question": 323,
    "key": "a",
    "text": "Для трасування шляху виконання HTTP-запитів через мікросервіси."
  }
},
{
  "model": "interview_app.option",
  "pk": 968,
  "fields": {
    "question": 323,
    "key": "b",
    "text": "Для відстеження блоків пам'яті, виділених Python, що дозволяє знайти місця в коді, які призводять до витоків пам'яті."
  }
},
{
  "model": "interview_app.option",
  "pk": 969,
  "fields": {
    "question": 323,
    "key": "c",
    "text": "Для візуалізації стеку викликів під час виникнення винятку."
  }
},
{
  "model": "interview_app.option",
  "pk": 970,
  "fields": {
    "question": 324,
    "key": "a",
    "text": "Він збирає статистику про те, скільки разів і як довго виконувалася кожна функція в програмі, що допомагає визначити 'гарячі' місця, які споживають найбільше часу CPU."
  }
},
{
  "model": "interview_app.option",
  "pk": 971,
  "fields": {
    "question": 324,
    "key": "b",
    "text": "Він вимірює використання пам'яті кожною функцією."
  }
},
{
  "model": "interview_app.option",
  "pk": 972,
  "fields": {
    "question": 324,
    "key": "c",
    "text": "Він перевіряє код на відповідність стандартам PEP 8."
  }
},
{
  "model": "interview_app.option",
  "pk": 973,
  "fields": {
    "question": 325,
    "key": "a",
    "text": "Це тиск, який створюється в базі даних при великій кількості запитів на запис."
  }
},
{
  "model": "interview_app.option",
  "pk": 974,
  "fields": {
    "question": 325,
    "key": "b",
    "text": "Це процес стиснення даних перед їх відправкою по мережі."
  }
},
{
  "model": "interview_app.option",
  "pk": 975,
  "fields": {
    "question": 325,
    "key": "c",
    "text": "Це механізм, за допомогою якого споживач (consumer), що не встигає обробляти дані, може повідомити про це виробника (producer), щоб той уповільнив або припинив надсилання даних, запобігаючи переповненню буферів."
  }
},
{
  "model": "interview_app.option",
  "pk": 976,
  "fields": {
    "question": 326,
    "key": "a",
    "text": "Це тип тесту, який перевіряє лише базову працездатність системи."
  }
},
{
  "model": "interview_app.option",
  "pk": 977,
  "fields": {
    "question": 326,
    "key": "b",
    "text": "Це тестування, яке виконується на спеціальному 'канарковому' сервері, ізольованому від продакшену."
  }
},
{
  "model": "interview_app.option",
  "pk": 978,
  "fields": {
    "question": 326,
    "key": "c",
    "text": "Це техніка розгортання, при якій нова версія коду випускається для невеликої підмножини користувачів ('канарок') для моніторингу її поведінки перед повним розгортанням."
  }
},
{
  "model": "interview_app.option",
  "pk": 979,
  "fields": {
    "question": 327,
    "key": "a",
    "text": "Це дисципліна експериментів над розподіленою системою з метою побудови впевненості в її здатності витримувати турбулентні умови в продакшені (наприклад, шляхом навмисного відключення сервісів)."
  }
},
{
  "model": "interview_app.option",
  "pk": 980,
  "fields": {
    "question": 327,
    "key": "b",
    "text": "Це техніка тестування, яка генерує випадкові вхідні дані для пошуку збоїв."
  }
},
{
  "model": "interview_app.option",
  "pk": 981,
  "fields": {
    "question": 327,
    "key": "c",
    "text": "Це розробка програмного забезпечення без будь-якого планування чи архітектури."
  }
},
{
  "model": "interview_app.option",
  "pk": 982,
  "fields": {
    "question": 328,
    "key": "a",
    "text": "Це атрибут, що містить кортеж класів у порядку розв'язання методів (Method Resolution Order), який Python використовує для пошуку методів та атрибутів в ієрархії класів."
  }
},
{
  "model": "interview_app.option",
  "pk": 983,
  "fields": {
    "question": 328,
    "key": "b",
    "text": "Це спеціальний атрибут, який зберігає метадані про клас."
  }
},
{
  "model": "interview_app.option",
  "pk": 984,
  "fields": {
    "question": 328,
    "key": "c",
    "text": "Це метод, який повертає всі методи, реалізовані в класі."
  }
},
{
  "model": "interview_app.option",
  "pk": 985,
  "fields": {
    "question": 329,
    "key": "a",
    "text": "Це інструмент для маршрутизації HTTP-запитів до різних баз даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 986,
  "fields": {
    "question": 329,
    "key": "b",
    "text": "Це клас, який дозволяє динамічно визначати, яку базу даних використовувати для операцій читання, запису або міграцій для конкретної моделі. Корисно при роботі з кількома базами даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 987,
  "fields": {
    "question": 329,
    "key": "c",
    "text": "Це зовнішній сервіс, який балансує навантаження між репліками бази даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 988,
  "fields": {
    "question": 330,
    "key": "a",
    "text": "Avro — це рядково-орієнтований формат, який зберігає схему разом з даними, що добре для еволюції схеми. Parquet — це колонково-орієнтований формат, оптимізований для аналітичних запитів, які читають лише певні колонки."
  }
},
{
  "model": "interview_app.option",
  "pk": 989,
  "fields": {
    "question": 330,
    "key": "b",
    "text": "Parquet використовується для реляційних баз даних, а Avro — для NoSQL."
  }
},
{
  "model": "interview_app.option",
  "pk": 990,
  "fields": {
    "question": 330,
    "key": "c",
    "text": "Avro — це текстовий формат, а Parquet — бінарний."
  }
},
{
  "model": "interview_app.option",
  "pk": 991,
  "fields": {
    "question": 331,
    "key": "a",
    "text": "Це модель узгодженості в розподілених системах, яка гарантує, що якщо нові оновлення не вносяться, то з часом усі репліки врешті-решт стануть узгодженими."
  }
},
{
  "model": "interview_app.option",
  "pk": 992,
  "fields": {
    "question": 331,
    "key": "b",
    "text": "Це гарантія, що всі дані в системі узгоджені в будь-який момент часу."
  }
},
{
  "model": "interview_app.option",
  "pk": 993,
  "fields": {
    "question": 331,
    "key": "c",
    "text": "Це модель, при якій дані ніколи не стають узгодженими, але система продовжує працювати."
  }
},
{
  "model": "interview_app.option",
  "pk": 994,
  "fields": {
    "question": 332,
    "key": "a",
    "text": "Це техніка написання коду, який працює однаково в різних версіях Python."
  }
},
{
  "model": "interview_app.option",
  "pk": 995,
  "fields": {
    "question": 332,
    "key": "b",
    "text": "Це динамічна зміна поведінки класу або модуля під час виконання. Може бути виправданим для виправлення багів у сторонніх бібліотеках без очікування офіційного релізу або для тестування (mocking)."
  }
},
{
  "model": "interview_app.option",
  "pk": 996,
  "fields": {
    "question": 332,
    "key": "c",
    "text": "Це процес оптимізації коду шляхом видалення непотрібних частин."
  }
},
{
  "model": "interview_app.option",
  "pk": 997,
  "fields": {
    "question": 333,
    "key": "a",
    "text": "Це транзакція, яка виконується дуже швидко."
  }
},
{
  "model": "interview_app.option",
  "pk": 998,
  "fields": {
    "question": 333,
    "key": "b",
    "text": "Це транзакція, яка працює лише з однією таблицею в базі даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 999,
  "fields": {
    "question": 333,
    "key": "c",
    "text": "Це послідовність операцій, яка розглядається як єдина неподільна одиниця: або всі операції виконуються успішно, або жодна з них не виконується (відкат)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1000,
  "fields": {
    "question": 334,
    "key": "a",
    "text": "`epoll` — це стара, менш портативна версія `select`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1001,
  "fields": {
    "question": 334,
    "key": "b",
    "text": "`select` сканує весь список файлових дескрипторів при кожному виклику, що неефективно при великій їх кількості. `epoll` (у Linux) повідомляє ядро, за якими дескрипторами слідкувати, і ядро повертає лише ті, що готові, що значно ефективніше."
  }
},
{
  "model": "interview_app.option",
  "pk": 1002,
  "fields": {
    "question": 334,
    "key": "c",
    "text": "`select` працює тільки з TCP-сокетами, а `epoll` — з будь-якими файлами."
  }
},
{
  "model": "interview_app.option",
  "pk": 1003,
  "fields": {
    "question": 335,
    "key": "a",
    "text": "EAFP передбачає виконання операції в блоці `try` та обробку винятків (`except`), тоді як LBYL — це явна перевірка умов (`if`) перед виконанням. EAFP вважається більш 'пайтонічним', оскільки він чистіший і швидший, якщо винятки виникають рідко."
  }
},
{
  "model": "interview_app.option",
  "pk": 1004,
  "fields": {
    "question": 335,
    "key": "b",
    "text": "LBYL є більш ідіоматичним, оскільки він уникає винятків, які є дуже повільними в Python."
  }
},
{
  "model": "interview_app.option",
  "pk": 1005,
  "fields": {
    "question": 335,
    "key": "c",
    "text": "EAFP і LBYL — це два підходи до обробки помилок, але Python не надає переваги жодному з них; вибір залежить виключно від розробника."
  }
},
{
  "model": "interview_app.option",
  "pk": 1006,
  "fields": {
    "question": 336,
    "key": "a",
    "text": "Він використовує метод ланцюжків (chaining), де кожен елемент хеш-таблиці є зв'язаним списком для вирішення колізій."
  }
},
{
  "model": "interview_app.option",
  "pk": 1007,
  "fields": {
    "question": 336,
    "key": "b",
    "text": "Він реалізований як збалансоване червоно-чорне дерево, що гарантує логарифмічний час доступу та збереження порядку ключів."
  }
},
{
  "model": "interview_app.option",
  "pk": 1008,
  "fields": {
    "question": 336,
    "key": "c",
    "text": "Він використовує хеш-таблицю з відкритою адресацією. Для збереження порядку вставки додатково використовується окремий щільний масив, що зберігає хеші та індекси в основну таблицю."
  }
},
{
  "model": "interview_app.option",
  "pk": 1009,
  "fields": {
    "question": 337,
    "key": "a",
    "text": "Це протокол, який описує, як об'єкти повинні бути серіалізовані."
  }
},
{
  "model": "interview_app.option",
  "pk": 1010,
  "fields": {
    "question": 337,
    "key": "b",
    "text": "Це протокол, що дозволяє об'єктам, які мають методи `__get__`, `__set__` або `__delete__`, контролювати доступ до атрибутів в інших класах. `@property` є реалізацією дескриптора. Методи — це дескриптори, що мають лише `__get__`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1011,
  "fields": {
    "question": 337,
    "key": "c",
    "text": "Дескриптори — це синтаксичний цукор, який перетворюється на звичайні виклики функцій get/set під час компіляції."
  }
},
{
  "model": "interview_app.option",
  "pk": 1012,
  "fields": {
    "question": 338,
    "key": "a",
    "text": "Data descriptors (що мають `__set__` або `__delete__`) мають вищий пріоритет і перехоплюють доступ до атрибута перед словником екземпляра (`__dict__`). Non-data descriptors (лише з `__get__`) мають нижчий пріоритет."
  }
},
{
  "model": "interview_app.option",
  "pk": 1013,
  "fields": {
    "question": 338,
    "key": "b",
    "text": "Пріоритет не відрізняється; Python перевіряє їх у порядку визначення в класі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1014,
  "fields": {
    "question": 338,
    "key": "c",
    "text": "Non-data descriptors завжди мають вищий пріоритет, щоб забезпечити швидкий доступ для читання."
  }
},
{
  "model": "interview_app.option",
  "pk": 1015,
  "fields": {
    "question": 339,
    "key": "a",
    "text": "GIL — це м'ютекс, який дозволяє лише одному потоку виконувати Python байт-код в один момент часу. Він звільняється під час блокуючих операцій вводу-виводу (I/O) та при виконанні C-розширень, які явно це роблять (напр., NumPy)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1016,
  "fields": {
    "question": 339,
    "key": "b",
    "text": "GIL був повністю видалений у Python 3, і всі потоки тепер виконуються паралельно."
  }
},
{
  "model": "interview_app.option",
  "pk": 1017,
  "fields": {
    "question": 339,
    "key": "c",
    "text": "GIL блокує лише операції, що змінюють дані, але дозволяє паралельне виконання операцій читання."
  }
},
{
  "model": "interview_app.option",
  "pk": 1018,
  "fields": {
    "question": 340,
    "key": "a",
    "text": "Це версії збирача сміття, які змінювалися з поколіннями Python."
  }
},
{
  "model": "interview_app.option",
  "pk": 1019,
  "fields": {
    "question": 340,
    "key": "b",
    "text": "Це механізм, який розділяє всі об'єкти на три покоління. Нові об'єкти створюються в наймолодшому поколінні. Збирач сміття частіше перевіряє молодші покоління, оскільки більшість об'єктів помирають молодими."
  }
},
{
  "model": "interview_app.option",
  "pk": 1020,
  "fields": {
    "question": 340,
    "key": "c",
    "text": "Це спосіб класифікувати об'єкти за їхнім типом (числа, рядки, списки) для оптимізації збору сміття."
  }
},
{
  "model": "interview_app.option",
  "pk": 1021,
  "fields": {
    "question": 341,
    "key": "a",
    "text": "AST — це кінцевий байт-код, який виконується віртуальною машиною Python."
  }
},
{
  "model": "interview_app.option",
  "pk": 1022,
  "fields": {
    "question": 341,
    "key": "b",
    "text": "Це інструмент для автоматичного форматування коду згідно з PEP 8."
  }
},
{
  "model": "interview_app.option",
  "pk": 1023,
  "fields": {
    "question": 341,
    "key": "c",
    "text": "AST — це деревоподібне представлення синтаксичної структури коду, яке створюється парсером. Модуль `ast` дозволяє програмно аналізувати, змінювати та генерувати Python код на рівні його структури."
  }
},
{
  "model": "interview_app.option",
  "pk": 1024,
  "fields": {
    "question": 342,
    "key": "a",
    "text": "Це стекова віртуальна машина, яка виконує байт-код інструкцію за інструкцією. Вона має стек для обчислень, де операнди розміщуються на вершині, а операції їх знімають і кладуть результат назад."
  }
},
{
  "model": "interview_app.option",
  "pk": 1025,
  "fields": {
    "question": 342,
    "key": "b",
    "text": "Це регістрова віртуальна машина, яка використовує апаратні регістри процесора для виконання операцій."
  }
},
{
  "model": "interview_app.option",
  "pk": 1026,
  "fields": {
    "question": 342,
    "key": "c",
    "text": "PVM — це просто інша назва для інтерпретатора Python, яка не має конкретної реалізації."
  }
},
{
  "model": "interview_app.option",
  "pk": 1027,
  "fields": {
    "question": 343,
    "key": "a",
    "text": "Він запобігає створенню `__dict__` для екземплярів, замінюючи його на фіксовану структуру, схожу на кортеж, що значно зменшує споживання пам'яті, особливо для великої кількості маленьких об'єктів."
  }
},
{
  "model": "interview_app.option",
  "pk": 1028,
  "fields": {
    "question": 343,
    "key": "b",
    "text": "Він автоматично створює слоти в базі даних для зберігання атрибутів об'єкта."
  }
},
{
  "model": "interview_app.option",
  "pk": 1029,
  "fields": {
    "question": 343,
    "key": "c",
    "text": "Він використовується для визначення методів, які можуть бути викликані лише асинхронно."
  }
},
{
  "model": "interview_app.option",
  "pk": 1030,
  "fields": {
    "question": 344,
    "key": "a",
    "text": "Це механізм, який дозволяє змінювати рядки 'на місці' без створення нових об'єктів."
  }
},
{
  "model": "interview_app.option",
  "pk": 1031,
  "fields": {
    "question": 344,
    "key": "b",
    "text": "Це оптимізація, при якій Python зберігає лише один екземпляр кожної унікальної рядкової літерали. При створенні нового рядка інтерпретатор перевіряє, чи такий рядок уже існує, і якщо так, повертає посилання на нього."
  }
},
{
  "model": "interview_app.option",
  "pk": 1032,
  "fields": {
    "question": 344,
    "key": "c",
    "text": "Це процес перетворення рядків у байти для зберігання або передачі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1033,
  "fields": {
    "question": 345,
    "key": "a",
    "text": "Він викликається при кожному доступі до атрибута, на відміну від `__getattr__` (який викликається лише для відсутніх атрибутів). Небезпечний тим, що може легко спричинити нескінченну рекурсію, якщо всередині нього звернутися до атрибута через `self`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1034,
  "fields": {
    "question": 345,
    "key": "b",
    "text": "`__getattribute__` є безпечнішою версією `__getattr__`, яка автоматично запобігає рекурсії."
  }
},
{
  "model": "interview_app.option",
  "pk": 1035,
  "fields": {
    "question": 345,
    "key": "c",
    "text": "Це метод, який використовується лише для отримання атрибутів класу, а не екземпляра."
  }
},
{
  "model": "interview_app.option",
  "pk": 1036,
  "fields": {
    "question": 346,
    "key": "a",
    "text": "Він просто обходить дерево класів у глибину зліва направо."
  }
},
{
  "model": "interview_app.option",
  "pk": 1037,
  "fields": {
    "question": 346,
    "key": "b",
    "text": "Це алгоритм, який створює послідовний та монотонний порядок успадкування, навіть у складних випадках ромбовидного наслідування, гарантуючи, що базові класи не будуть перевірятися раніше за дочірні."
  }
},
{
  "model": "interview_app.option",
  "pk": 1038,
  "fields": {
    "question": 346,
    "key": "c",
    "text": "Він обходить дерево класів у ширину, щоб знайти найближчий метод."
  }
},
{
  "model": "interview_app.option",
  "pk": 1039,
  "fields": {
    "question": 347,
    "key": "a",
    "text": "Корутина — це узагальнення генератора, що може не тільки видавати значення, але й приймати їх. Синтаксис `async/await` є спеціалізованою версією корутин, оптимізованою для асинхронних операцій."
  }
},
{
  "model": "interview_app.option",
  "pk": 1040,
  "fields": {
    "question": 347,
    "key": "b",
    "text": "Генератори і корутини — це абсолютно різні концепції, не пов'язані між собою."
  }
},
{
  "model": "interview_app.option",
  "pk": 1041,
  "fields": {
    "question": 347,
    "key": "c",
    "text": "Корутина — це просто інша назва для функції, яка виконується в окремому потоці."
  }
},
{
  "model": "interview_app.option",
  "pk": 1042,
  "fields": {
    "question": 348,
    "key": "a",
    "text": "Він використовується для того, щоб генератор повернув значення, а не видав його."
  }
},
{
  "model": "interview_app.option",
  "pk": 1043,
  "fields": {
    "question": 348,
    "key": "b",
    "text": "Він створює канал для делегування операцій від зовнішнього генератора до внутрішнього (субгенератора), передаючи виклики `send()` та `throw()` безпосередньо, що спрощує роботу зі вкладеними генераторами."
  }
},
{
  "model": "interview_app.option",
  "pk": 1044,
  "fields": {
    "question": 348,
    "key": "c",
    "text": "Це просто скорочення для циклу `for item in iterable: yield item`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1045,
  "fields": {
    "question": 349,
    "key": "a",
    "text": "Це тонкий шар над звичайним списком Python, який додає лише нові методи."
  }
},
{
  "model": "interview_app.option",
  "pk": 1046,
  "fields": {
    "question": 349,
    "key": "b",
    "text": "Він реалізований як двобічно зв'язаний список блоків фіксованого розміру, що дозволяє додавати та видаляти елементи з обох кінців за константний час, не зсуваючи всі інші елементи, як у звичайному списку."
  }
},
{
  "model": "interview_app.option",
  "pk": 1047,
  "fields": {
    "question": 349,
    "key": "c",
    "text": "Він використовує динамічний масив, який подвоює свій розмір, але має спеціальні оптимізації для операцій зліва."
  }
},
{
  "model": "interview_app.option",
  "pk": 1048,
  "fields": {
    "question": 350,
    "key": "a",
    "text": "Це базовий клас, від якого повинні наслідуватися всі класи, що реалізують певний протокол зв'язку (напр., HTTP)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1049,
  "fields": {
    "question": 350,
    "key": "b",
    "text": "`Protocol` дозволяє визначити інтерфейс на основі наявності певних методів та атрибутів. Статичний аналізатор вважатиме клас сумісним з протоколом, якщо він має відповідну структуру, без необхідності явного наслідування."
  }
},
{
  "model": "interview_app.option",
  "pk": 1050,
  "fields": {
    "question": 350,
    "key": "c",
    "text": "Це декоратор, який автоматично додає відсутні методи до класу."
  }
},
{
  "model": "interview_app.option",
  "pk": 1051,
  "fields": {
    "question": 351,
    "key": "a",
    "text": "Вони використовуються для точної анотації декораторів, які пересилають або змінюють параметри функції. `ParamSpec` захоплює всі параметри, а `Concatenate` дозволяє додавати нові."
  }
},
{
  "model": "interview_app.option",
  "pk": 1052,
  "fields": {
    "question": 351,
    "key": "b",
    "text": "Вони використовуються для конкатенації рядків та списків з урахуванням типів."
  }
},
{
  "model": "interview_app.option",
  "pk": 1053,
  "fields": {
    "question": 351,
    "key": "c",
    "text": "Це типи для роботи з параметрами командного рядка."
  }
},
{
  "model": "interview_app.option",
  "pk": 1054,
  "fields": {
    "question": 352,
    "key": "a",
    "text": "Це об'єкт, що представляє один кадр стеку виконання. Він містить інформацію про поточний байт-код, локальні та глобальні змінні, та посилання на попередній кадр."
  }
},
{
  "model": "interview_app.option",
  "pk": 1055,
  "fields": {
    "question": 352,
    "key": "b",
    "text": "Це об'єкт, який використовується для відображення графічних вікон."
  }
},
{
  "model": "interview_app.option",
  "pk": 1056,
  "fields": {
    "question": 352,
    "key": "c",
    "text": "Це структура даних для зберігання одного кадру з відеофайлу."
  }
},
{
  "model": "interview_app.option",
  "pk": 1057,
  "fields": {
    "question": 353,
    "key": "a",
    "text": "Це чистий алгоритм швидкого сортування (Quicksort), який має середню складність O(n log n)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1058,
  "fields": {
    "question": 353,
    "key": "b",
    "text": "Це гібридний стабільний алгоритм, який поєднує сортування вставками (для малих масивів) та сортування злиттям. Він шукає в даних природні впорядковані послідовності ('runs') і ефективно їх зливає."
  }
},
{
  "model": "interview_app.option",
  "pk": 1059,
  "fields": {
    "question": 353,
    "key": "c",
    "text": "Це бульбашкове сортування, оптимізоване для частково відсортованих даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1060,
  "fields": {
    "question": 354,
    "key": "a",
    "text": "Він обгортає функцію в `try...except` блок для автоматичної обробки помилок."
  }
},
{
  "model": "interview_app.option",
  "pk": 1061,
  "fields": {
    "question": 354,
    "key": "b",
    "text": "Він копіює метадані (наприклад, `__name__`, `__doc__`) з оригінальної функції до функції-обгортки в декораторі, що важливо для інтроспекції та налагодження."
  }
},
{
  "model": "interview_app.option",
  "pk": 1062,
  "fields": {
    "question": 354,
    "key": "c",
    "text": "Він робить звичайну функцію асинхронною."
  }
},
{
  "model": "interview_app.option",
  "pk": 1063,
  "fields": {
    "question": 355,
    "key": "a",
    "text": "Це стек, який зберігає всі винятки, що виникли під час виконання програми."
  }
},
{
  "model": "interview_app.option",
  "pk": 1064,
  "fields": {
    "question": 355,
    "key": "b",
    "text": "Це функція, яка примусово завершує виконання всіх контекстних менеджерів."
  }
},
{
  "model": "interview_app.option",
  "pk": 1065,
  "fields": {
    "question": 355,
    "key": "c",
    "text": "Це контекстний менеджер, який дозволяє програмно та динамічно керувати кількома іншими контекстними менеджерами, гарантуючи, що всі їхні `__exit__` методи будуть викликані, навіть якщо деякі з них зазнають невдачі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1066,
  "fields": {
    "question": 356,
    "key": "a",
    "text": "Тому що ітератори зазвичай не мають визначеної довжини і можуть бути нескінченними. Крім того, будь-яка спроба 'виміряти' їх призведе до їх споживання, і дані будуть втрачені для подальшої обробки."
  }
},
{
  "model": "interview_app.option",
  "pk": 1067,
  "fields": {
    "question": 356,
    "key": "b",
    "text": "Тому що `len()` працює дуже повільно з ітераторами."
  }
},
{
  "model": "interview_app.option",
  "pk": 1068,
  "fields": {
    "question": 356,
    "key": "c",
    "text": "Можна, `len()` автоматично перетворює ітератор на список і повертає його довжину."
  }
},
{
  "model": "interview_app.option",
  "pk": 1069,
  "fields": {
    "question": 357,
    "key": "a",
    "text": "Це інструменти для виконання Python коду в браузері."
  }
},
{
  "model": "interview_app.option",
  "pk": 1070,
  "fields": {
    "question": 357,
    "key": "b",
    "text": "Це механізм, що дозволяє створювати кілька незалежних інтерпретаторів Python в одному процесі. Це може дозволити запускати код паралельно без GIL, оскільки кожен субінтерпретатор може мати свій власний GIL."
  }
},
{
  "model": "interview_app.option",
  "pk": 1071,
  "fields": {
    "question": 357,
    "key": "c",
    "text": "Це інтерпретатори для підмножини мови Python, які працюють швидше."
  }
},
{
  "model": "interview_app.option",
  "pk": 1072,
  "fields": {
    "question": 358,
    "key": "a",
    "text": "Він встановлює ім'я класу, в якому знаходиться дескриптор."
  }
},
{
  "model": "interview_app.option",
  "pk": 1073,
  "fields": {
    "question": 358,
    "key": "b",
    "text": "Він дозволяє перейменовувати атрибути під час виконання програми."
  }
},
{
  "model": "interview_app.option",
  "pk": 1074,
  "fields": {
    "question": 358,
    "key": "c",
    "text": "Він автоматично викликається при створенні класу і передає дескриптору ім'я атрибута, до якого він прив'язаний. Це дозволяє дескриптору знати своє власне ім'я без необхідності передавати його вручну."
  }
},
{
  "model": "interview_app.option",
  "pk": 1075,
  "fields": {
    "question": 359,
    "key": "a",
    "text": "Для цих об'єктів-синглтонів `is` є ідіоматичним та кращим вибором, оскільки він перевіряє ідентичність об'єкта, що швидше і гарантує, що ми порівнюємо саме з цими константами, а не з об'єктами, що мають еквівалентне значення."
  }
},
{
  "model": "interview_app.option",
  "pk": 1076,
  "fields": {
    "question": 359,
    "key": "b",
    "text": "Слід завжди використовувати `==`, оскільки `is` може давати непередбачувані результати."
  }
},
{
  "model": "interview_app.option",
  "pk": 1077,
  "fields": {
    "question": 359,
    "key": "c",
    "text": "Різниці немає, `is` та `==` завжди поводяться однаково для цих значень."
  }
},
{
  "model": "interview_app.option",
  "pk": 1078,
  "fields": {
    "question": 360,
    "key": "a",
    "text": "Вона перевіряє, чи є ітератор порожнім."
  }
},
{
  "model": "interview_app.option",
  "pk": 1079,
  "fields": {
    "question": 360,
    "key": "b",
    "text": "Вона об'єднує кілька ітераторів в один."
  }
},
{
  "model": "interview_app.option",
  "pk": 1080,
  "fields": {
    "question": 360,
    "key": "c",
    "text": "Вона створює кілька незалежних ітераторів з одного оригінального ітератора. Це корисно, коли потрібно пройтися по даних кілька разів, не зберігаючи їх усі в пам'яті."
  }
},
{
  "model": "interview_app.option",
  "pk": 1081,
  "fields": {
    "question": 361,
    "key": "a",
    "text": "Це можливо лише за допомогою сторонніх бібліотек, таких як `pip`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1082,
  "fields": {
    "question": 361,
    "key": "b",
    "text": "Механізм `import hooks` та модуль `zipimport`. Якщо додати шлях до .zip архіву в `sys.path`, Python зможе знаходити та завантажувати модулі безпосередньо з нього."
  }
},
{
  "model": "interview_app.option",
  "pk": 1083,
  "fields": {
    "question": 361,
    "key": "c",
    "text": "Python не може імпортувати з .zip архівів; їх потрібно спочатку розпакувати."
  }
},
{
  "model": "interview_app.option",
  "pk": 1084,
  "fields": {
    "question": 362,
    "key": "a",
    "text": "Shallow copy створює копію, яку не можна змінювати, а deep copy — можна."
  }
},
{
  "model": "interview_app.option",
  "pk": 1085,
  "fields": {
    "question": 362,
    "key": "b",
    "text": "Shallow copy створює новий об'єкт верхнього рівня, але копіює посилання на вкладені об'єкти. Deep copy рекурсивно створює повні копії всіх вкладених об'єктів, забезпечуючи повну незалежність."
  }
},
{
  "model": "interview_app.option",
  "pk": 1086,
  "fields": {
    "question": 362,
    "key": "c",
    "text": "Deep copy швидша, оскільки вона копіює дані блоками."
  }
},
{
  "model": "interview_app.option",
  "pk": 1087,
  "fields": {
    "question": 363,
    "key": "a",
    "text": "Це техніка для написання коду, який може працювати з різними типами даних без помилок."
  }
},
{
  "model": "interview_app.option",
  "pk": 1088,
  "fields": {
    "question": 363,
    "key": "b",
    "text": "Це техніка тестування, яка полягає у подачі на вхід програми великої кількості випадкових або напіввипадкових даних з метою викликати збій або знайти вразливість. В Python це можна робити з бібліотеками, як-от `Atheris`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1089,
  "fields": {
    "question": 363,
    "key": "c",
    "text": "Це процес оптимізації коду для роботи з нечіткими даними."
  }
},
{
  "model": "interview_app.option",
  "pk": 1090,
  "fields": {
    "question": 364,
    "key": "a",
    "text": "Це новий оператор для порівняння, який працює швидше за `==`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1091,
  "fields": {
    "question": 364,
    "key": "b",
    "text": "Це оператор присвоєння у виразі, який дозволяє присвоїти значення змінній і одночасно повернути це значення. Це дозволяє уникнути повторних обчислень у циклах `while` або list comprehensions."
  }
},
{
  "model": "interview_app.option",
  "pk": 1092,
  "fields": {
    "question": 364,
    "key": "c",
    "text": "Це оператор для створення глибоких копій об'єктів."
  }
},
{
  "model": "interview_app.option",
  "pk": 1093,
  "fields": {
    "question": 365,
    "key": "a",
    "text": "Це спосіб виконання кожної SQL-команди в окремій транзакції для максимальної ізоляції."
  }
},
{
  "model": "interview_app.option",
  "pk": 1094,
  "fields": {
    "question": 365,
    "key": "b",
    "text": "Це патерн, який відстежує всі зміни в об'єктах протягом бізнес-транзакції і записує їх в базу даних атомарно (зазвичай через `session.commit()`). Сесія діє як координатор цієї роботи."
  }
},
{
  "model": "interview_app.option",
  "pk": 1095,
  "fields": {
    "question": 365,
    "key": "c",
    "text": "Це патерн, який вимагає, щоб кожна функція працювала лише з одним об'єктом бази даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1096,
  "fields": {
    "question": 366,
    "key": "a",
    "text": "`flush()` надсилає накопичені SQL-команди (INSERT, UPDATE, DELETE) до бази даних, але не завершує транзакцію. `commit()` виконує `flush()` і потім завершує транзакцію, роблячи зміни постійними."
  }
},
{
  "model": "interview_app.option",
  "pk": 1097,
  "fields": {
    "question": 366,
    "key": "b",
    "text": "`flush()` використовується для операцій читання, а `commit()` — для запису."
  }
},
{
  "model": "interview_app.option",
  "pk": 1098,
  "fields": {
    "question": 366,
    "key": "c",
    "text": "`commit()` швидший, оскільки він не чекає підтвердження від бази даних, на відміну від `flush()`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1099,
  "fields": {
    "question": 367,
    "key": "a",
    "text": "`joinedload` використовує LEFT JOIN. `subqueryload` виконує другий запит з JOIN для завантаження колекцій. `selectinload` виконує другий запит з `WHERE ... IN (...)` для завантаження колекцій, що ефективно для уникнення декартового добутку."
  }
},
{
  "model": "interview_app.option",
  "pk": 1100,
  "fields": {
    "question": 367,
    "key": "b",
    "text": "Всі три роблять одне й те саме, але оптимізовані для різних рушіїв баз даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1101,
  "fields": {
    "question": 367,
    "key": "c",
    "text": "`joinedload` — для зв'язків 'один-до-одного', `subqueryload` — для 'багато-до-одного', `selectinload` — для 'багато-до-багатьох'."
  }
},
{
  "model": "interview_app.option",
  "pk": 1102,
  "fields": {
    "question": 368,
    "key": "a",
    "text": "Це механізм для керування пулом з'єднань з базою даних. `QueuePool` (використовується за замовчуванням) підтримує чергу відкритих з'єднань для повторного використання, що значно зменшує накладні витрати на підключення."
  }
},
{
  "model": "interview_app.option",
  "pk": 1103,
  "fields": {
    "question": 368,
    "key": "b",
    "text": "Це спосіб об'єднати кілька запитів в один для оптимізації."
  }
},
{
  "model": "interview_app.option",
  "pk": 1104,
  "fields": {
    "question": 368,
    "key": "c",
    "text": "Це черга для SQL-запитів, які очікують на виконання."
  }
},
{
  "model": "interview_app.option",
  "pk": 1105,
  "fields": {
    "question": 369,
    "key": "a",
    "text": "Він вимагає вручну вказувати всі зміни в спеціальному конфігураційному файлі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1106,
  "fields": {
    "question": 369,
    "key": "b",
    "text": "Він порівнює метадані, визначені у ваших моделях SQLAlchemy, зі станом, збереженим у таблиці `alembic_version` та станом реальної схеми бази даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1107,
  "fields": {
    "question": 369,
    "key": "c",
    "text": "Він аналізує Git diff з моменту останньої міграції, щоб знайти зміни в моделях."
  }
},
{
  "model": "interview_app.option",
  "pk": 1108,
  "fields": {
    "question": 370,
    "key": "a",
    "text": "Це функція, яка дозволяє застосовувати міграції в залежності від умов."
  }
},
{
  "model": "interview_app.option",
  "pk": 1109,
  "fields": {
    "question": 370,
    "key": "b",
    "text": "Це ситуація, коли в історії міграцій з'являються дві або більше паралельні гілки. Це трапляється, коли кілька розробників створюють міграції в різних гілках Git, а потім об'єднують їх."
  }
},
{
  "model": "interview_app.option",
  "pk": 1110,
  "fields": {
    "question": 370,
    "key": "c",
    "text": "Це створення копії бази даних для кожної нової гілки Git."
  }
},
{
  "model": "interview_app.option",
  "pk": 1111,
  "fields": {
    "question": 371,
    "key": "a",
    "text": "GIN (Generalized Inverted Index) оптимізований для індексації композитних типів, де елементи повторюються (напр., повнотекстовий пошук, масиви, JSONB). GiST (Generalized Search Tree) є більш гнучким і підходить для індексації геометричних даних та складних умов перекриття."
  }
},
{
  "model": "interview_app.option",
  "pk": 1112,
  "fields": {
    "question": 371,
    "key": "b",
    "text": "GiST швидший за GIN у всіх випадках, але займає більше місця."
  }
},
{
  "model": "interview_app.option",
  "pk": 1113,
  "fields": {
    "question": 371,
    "key": "c",
    "text": "GIN — це індекс лише для читання, а GiST — для читання та запису."
  }
},
{
  "model": "interview_app.option",
  "pk": 1114,
  "fields": {
    "question": 372,
    "key": "a",
    "text": "Це блокування, які автоматично знімаються через певний час."
  }
},
{
  "model": "interview_app.option",
  "pk": 1115,
  "fields": {
    "question": 372,
    "key": "b",
    "text": "Це механізм блокувань, керований додатком, а не базою даних. Вони не блокують таблиці чи рядки, а дозволяють координувати дії між різними сесіями за допомогою довільних числових ключів."
  }
},
{
  "model": "interview_app.option",
  "pk": 1116,
  "fields": {
    "question": 372,
    "key": "c",
    "text": "Це рекомендації від PostgreSQL щодо того, які блокування слід використовувати."
  }
},
{
  "model": "interview_app.option",
  "pk": 1117,
  "fields": {
    "question": 373,
    "key": "a",
    "text": "Це команди для моніторингу стану сервера PostgreSQL."
  }
},
{
  "model": "interview_app.option",
  "pk": 1118,
  "fields": {
    "question": 373,
    "key": "b",
    "text": "Це механізм для асинхронного сповіщення між сесіями. Одна сесія може надіслати сповіщення (`NOTIFY`) по певному каналу, а інші сесії, що 'слухають' (`LISTEN`) цей канал, отримають його."
  }
},
{
  "model": "interview_app.option",
  "pk": 1119,
  "fields": {
    "question": 373,
    "key": "c",
    "text": "Це спосіб надсилати email-сповіщення при виникненні помилок у базі даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1120,
  "fields": {
    "question": 374,
    "key": "a",
    "text": "MongoDB вимагає, щоб усі дані були в одній великій колекції без будь-яких зв'язків."
  }
},
{
  "model": "interview_app.option",
  "pk": 1121,
  "fields": {
    "question": 374,
    "key": "b",
    "text": "У MongoDB немає різниці, дані моделюються так само, як у реляційних таблицях."
  }
},
{
  "model": "interview_app.option",
  "pk": 1122,
  "fields": {
    "question": 374,
    "key": "c",
    "text": "У MongoDB перевага надається 'вбудовуванню' (embedding) пов'язаних даних в один документ для швидкого читання, на відміну від 'нормалізації' та JOIN'ів у реляційних БД."
  }
},
{
  "model": "interview_app.option",
  "pk": 1123,
  "fields": {
    "question": 375,
    "key": "a",
    "text": "Це індекс, який перестає працювати через певний час і потребує перебудови."
  }
},
{
  "model": "interview_app.option",
  "pk": 1124,
  "fields": {
    "question": 375,
    "key": "b",
    "text": "Це індекс, який вимірює час життя запиту до бази даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1125,
  "fields": {
    "question": 375,
    "key": "c",
    "text": "Це спеціальний індекс, який дозволяє автоматично видаляти документи з колекції через певний проміжок часу після дати, вказаної в індексованому полі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1126,
  "fields": {
    "question": 376,
    "key": "a",
    "text": "Це повідомлення, яке воркер надсилає користувачу після завершення задачі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1127,
  "fields": {
    "question": 376,
    "key": "b",
    "text": "Це підтвердження від воркера, що задача була отримана та оброблена. Якщо воркер падає до підтвердження, брокер повідомлень передасть задачу іншому воркеру, забезпечуючи 'at-least-once' доставку."
  }
},
{
  "model": "interview_app.option",
  "pk": 1128,
  "fields": {
    "question": 376,
    "key": "c",
    "text": "Це лог, який записується в базу даних після кожної виконаної задачі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1129,
  "fields": {
    "question": 377,
    "key": "a",
    "text": "При невдачі задача може бути повторно запущена. 'Exponential backoff' означає, що затримка перед кожною наступною спробою експоненційно збільшується, щоб зменшити навантаження на залежні системи."
  }
},
{
  "model": "interview_app.option",
  "pk": 1130,
  "fields": {
    "question": 377,
    "key": "b",
    "text": "Воркер намагається виконати задачу знову і знову без затримки, доки вона не буде успішною."
  }
},
{
  "model": "interview_app.option",
  "pk": 1131,
  "fields": {
    "question": 377,
    "key": "c",
    "text": "Задача повторюється негайно фіксовану кількість разів."
  }
},
{
  "model": "interview_app.option",
  "pk": 1132,
  "fields": {
    "question": 378,
    "key": "a",
    "text": "Це алгоритм, який оптимізує розподіл задач між воркерами."
  }
},
{
  "model": "interview_app.option",
  "pk": 1133,
  "fields": {
    "question": 378,
    "key": "b",
    "text": "Це інструмент для вимірювання 'пульсу' (heartbeat) воркерів Celery."
  }
},
{
  "model": "interview_app.option",
  "pk": 1134,
  "fields": {
    "question": 378,
    "key": "c",
    "text": "Це планувальник, який запускає задачі за розкладом (подібно до cron), надсилаючи їх у чергу в зазначений час або через певні інтервали."
  }
},
{
  "model": "interview_app.option",
  "pk": 1135,
  "fields": {
    "question": 379,
    "key": "a",
    "text": "Це інженерна дисципліна, що займається розробкою архітектури мовних моделей."
  }
},
{
  "model": "interview_app.option",
  "pk": 1136,
  "fields": {
    "question": 379,
    "key": "b",
    "text": "Це процес і мистецтво створення ефективних вхідних запитів (промптів) для отримання бажаних та точних відповідей від великих мовних моделей."
  }
},
{
  "model": "interview_app.option",
  "pk": 1137,
  "fields": {
    "question": 379,
    "key": "c",
    "text": "Це процес автоматичного генерування промптів за допомогою іншої AI-моделі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1138,
  "fields": {
    "question": 380,
    "key": "a",
    "text": "Zero-shot: модель виконує завдання без прикладів. One-shot: надається один приклад. Few-shot: надається кілька прикладів, що допомагає моделі краще зрозуміти контекст і формат відповіді."
  }
},
{
  "model": "interview_app.option",
  "pk": 1139,
  "fields": {
    "question": 380,
    "key": "b",
    "text": "Це кількість спроб, які даються моделі для правильної відповіді."
  }
},
{
  "model": "interview_app.option",
  "pk": 1140,
  "fields": {
    "question": 380,
    "key": "c",
    "text": "Це рівні складності завдань: zero-shot — найпростіше, few-shot — найскладніше."
  }
},
{
  "model": "interview_app.option",
  "pk": 1141,
  "fields": {
    "question": 381,
    "key": "a",
    "text": "Це техніка, при якій модель спонукають розписувати покроковий процес мислення перед тим, як дати фінальну відповідь. Це значно покращує результати для складних логічних та математичних задач."
  }
},
{
  "model": "interview_app.option",
  "pk": 1142,
  "fields": {
    "question": 381,
    "key": "b",
    "text": "Це промпт, який просить модель думати про історію людства."
  }
},
{
  "model": "interview_app.option",
  "pk": 1143,
  "fields": {
    "question": 381,
    "key": "c",
    "text": "Це створення ланцюжка промптів, де відповідь на один стає частиною наступного."
  }
},
{
  "model": "interview_app.option",
  "pk": 1144,
  "fields": {
    "question": 382,
    "key": "a",
    "text": "Це промпт, який надсилається від імені операційної системи."
  }
},
{
  "model": "interview_app.option",
  "pk": 1145,
  "fields": {
    "question": 382,
    "key": "b",
    "text": "Він задає загальний контекст, роль та інструкції для поведінки моделі протягом усієї розмови (наприклад, 'Ти — корисний асистент, що відповідає у стилі Шекспіра')."
  }
},
{
  "model": "interview_app.option",
  "pk": 1146,
  "fields": {
    "question": 382,
    "key": "c",
    "text": "Це останній промпт у розмові, який підсумовує все сказане."
  }
},
{
  "model": "interview_app.option",
  "pk": 1147,
  "fields": {
    "question": 383,
    "key": "a",
    "text": "Це процес перетворення коду, згенерованого моделлю, у виконувану функцію."
  }
},
{
  "model": "interview_app.option",
  "pk": 1148,
  "fields": {
    "question": 383,
    "key": "b",
    "text": "Це можливість викликати вбудовані функції Python безпосередньо з промпту."
  }
},
{
  "model": "interview_app.option",
  "pk": 1149,
  "fields": {
    "question": 383,
    "key": "c",
    "text": "Це здатність моделі визначати, коли їй потрібно викликати зовнішню функцію (надану розробником) для отримання додаткової інформації, і генерувати JSON з аргументами для цього виклику."
  }
},
{
  "model": "interview_app.option",
  "pk": 1150,
  "fields": {
    "question": 384,
    "key": "a",
    "text": "Він контролює максимальну довжину відповіді в токенах."
  }
},
{
  "model": "interview_app.option",
  "pk": 1151,
  "fields": {
    "question": 384,
    "key": "b",
    "text": "Він встановлює 'температуру' тону відповіді: від холодно-офіційного до тепло-дружнього."
  }
},
{
  "model": "interview_app.option",
  "pk": 1152,
  "fields": {
    "question": 384,
    "key": "c",
    "text": "Він контролює випадковість відповіді. Низьке значення (напр., 0.1) робить відповідь більш детермінованою та сфокусованою. Високе значення (напр., 0.9) робить її більш творчою та непередбачуваною."
  }
},
{
  "model": "interview_app.option",
  "pk": 1153,
  "fields": {
    "question": 385,
    "key": "a",
    "text": "Це векторні (числові) представлення тексту, що відображають його семантичне значення. Вони використовуються для задач, як-от семантичний пошук, кластеризація та рекомендації."
  }
},
{
  "model": "interview_app.option",
  "pk": 1154,
  "fields": {
    "question": 385,
    "key": "b",
    "text": "Це спосіб вбудовувати зображення та відео в текстові промпти."
  }
},
{
  "model": "interview_app.option",
  "pk": 1155,
  "fields": {
    "question": 385,
    "key": "c",
    "text": "Це метадані, які додаються до кожної відповіді моделі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1156,
  "fields": {
    "question": 386,
    "key": "a",
    "text": "Це техніка, яка змушує модель генерувати лише цитати з наданих джерел."
  }
},
{
  "model": "interview_app.option",
  "pk": 1157,
  "fields": {
    "question": 386,
    "key": "b",
    "text": "Це підхід, при якому перед генерацією відповіді модель спочатку шукає релевантну інформацію у зовнішній базі знань (часто за допомогою embeddings), а потім використовує знайдені дані для створення точної відповіді."
  }
},
{
  "model": "interview_app.option",
  "pk": 1158,
  "fields": {
    "question": 386,
    "key": "c",
    "text": "Це процес донавчання (fine-tuning) моделі на нових даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1159,
  "fields": {
    "question": 387,
    "key": "a",
    "text": "Це процес розбиття тексту на менші одиниці (токени). Розуміння цього важливе, оскільки вартість та ліміт контексту API залежать від кількості токенів, а не символів, і різні мови токенізуються по-різному."
  }
},
{
  "model": "interview_app.option",
  "pk": 1160,
  "fields": {
    "question": 387,
    "key": "b",
    "text": "Це спосіб заміни чутливих даних у тексті на спеціальні токени."
  }
},
{
  "model": "interview_app.option",
  "pk": 1161,
  "fields": {
    "question": 387,
    "key": "c",
    "text": "Це процес генерації унікального токена доступу для кожного запиту до API."
  }
},
{
  "model": "interview_app.option",
  "pk": 1162,
  "fields": {
    "question": 388,
    "key": "a",
    "text": "Коли потрібно навчити модель дуже специфічному стилю, формату або навичці, яку важко передати через промпт, і коли є великий набір якісних даних для навчання."
  }
},
{
  "model": "interview_app.option",
  "pk": 1163,
  "fields": {
    "question": 388,
    "key": "b",
    "text": "Fine-tuning завжди кращий за промпт-інжиніринг, оскільки робить модель розумнішою."
  }
},
{
  "model": "interview_app.option",
  "pk": 1164,
  "fields": {
    "question": 388,
    "key": "c",
    "text": "Коли потрібно, щоб модель мала доступ до актуальної інформації."
  }
},
{
  "model": "interview_app.option",
  "pk": 1165,
  "fields": {
    "question": 389,
    "key": "a",
    "text": "Це спосіб зберігати копію кожного запиту, відправленого на зовнішній сервіс."
  }
},
{
  "model": "interview_app.option",
  "pk": 1166,
  "fields": {
    "question": 389,
    "key": "b",
    "text": "Це патерн для надійної відправки подій з мікросервісу. Замість прямої відправки події, вона записується в спеціальну таблицю ('outbox') в тій же транзакції, що й зміна бізнес-даних. Окремий процес потім читає цю таблицю і надсилає події."
  }
},
{
  "model": "interview_app.option",
  "pk": 1167,
  "fields": {
    "question": 389,
    "key": "c",
    "text": "Це патерн, який збирає всі вихідні email-повідомлення в одну чергу для відправки."
  }
},
{
  "model": "interview_app.option",
  "pk": 1168,
  "fields": {
    "question": 390,
    "key": "a",
    "text": "Це спрощена версія TLS, яка використовує менш надійне шифрування."
  }
},
{
  "model": "interview_app.option",
  "pk": 1169,
  "fields": {
    "question": 390,
    "key": "b",
    "text": "Це розширення TLS, при якому не тільки сервер надає сертифікат для автентифікації клієнту, але й клієнт надає свій сертифікат серверу. Це забезпечує двосторонню автентифікацію, що часто використовується для комунікації між сервісами."
  }
},
{
  "model": "interview_app.option",
  "pk": 1170,
  "fields": {
    "question": 390,
    "key": "c",
    "text": "Це протокол, який дозволяє кільком клієнтам використовувати один і той же TLS-сертифікат."
  }
},
{
  "model": "interview_app.option",
  "pk": 1171,
  "fields": {
    "question": 391,
    "key": "a",
    "text": "Write-through: запис відбувається одночасно в кеш і в базу. Write-behind: запис відбувається спочатку тільки в кеш (дуже швидко), а в базу даних дані записуються асинхронно через деякий час."
  }
},
{
  "model": "interview_app.option",
  "pk": 1172,
  "fields": {
    "question": 391,
    "key": "b",
    "text": "Write-through швидший, оскільки не чекає на запис у базу."
  }
},
{
  "model": "interview_app.option",
  "pk": 1173,
  "fields": {
    "question": 391,
    "key": "c",
    "text": "Write-behind надійніший, оскільки гарантує, що дані завжди є і в кеші, і в базі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1174,
  "fields": {
    "question": 392,
    "key": "a",
    "text": "Це алгоритм, який обробляє запити з фіксованою швидкістю. Запити, що надходять, додаються в чергу ('відро'). Якщо черга переповнена, нові запити відхиляються. Це згладжує сплески трафіку."
  }
},
{
  "model": "interview_app.option",
  "pk": 1175,
  "fields": {
    "question": 392,
    "key": "b",
    "text": "Це алгоритм, який дозволяє 'витікати' старим запитам, щоб звільнити місце для нових."
  }
},
{
  "model": "interview_app.option",
  "pk": 1176,
  "fields": {
    "question": 392,
    "key": "c",
    "text": "Це алгоритм, який дає кожному користувачу певну кількість 'токенів' для запитів."
  }
},
{
  "model": "interview_app.option",
  "pk": 1177,
  "fields": {
    "question": 393,
    "key": "a",
    "text": "Це спосіб стиснення даних, заснований на повторюваних префіксах."
  }
},
{
  "model": "interview_app.option",
  "pk": 1178,
  "fields": {
    "question": 393,
    "key": "b",
    "text": "Це деревоподібна структура даних для ефективного зберігання та пошуку рядків за префіксами. Часто використовується для реалізації автодоповнення (autocomplete) у пошукових системах."
  }
},
{
  "model": "interview_app.option",
  "pk": 1179,
  "fields": {
    "question": 393,
    "key": "c",
    "text": "Це алгоритм сортування, оптимізований для коротких рядків."
  }
},
{
  "model": "interview_app.option",
  "pk": 1180,
  "fields": {
    "question": 394,
    "key": "a",
    "text": "WebSockets забезпечують постійне двонаправлене з'єднання між клієнтом і сервером. SSE забезпечують однонаправлене з'єднання, де лише сервер може надсилати дані клієнту."
  }
},
{
  "model": "interview_app.option",
  "pk": 1181,
  "fields": {
    "question": 394,
    "key": "b",
    "text": "WebSockets працюють поверх HTTP, а SSE — поверх TCP."
  }
},
{
  "model": "interview_app.option",
  "pk": 1182,
  "fields": {
    "question": 394,
    "key": "c",
    "text": "SSE є більш сучасним і швидким протоколом, ніж WebSockets."
  }
},
{
  "model": "interview_app.option",
  "pk": 1183,
  "fields": {
    "question": 395,
    "key": "a",
    "text": "Це три назви для одного й того ж методу, вибір залежить лише від операційної системи."
  }
},
{
  "model": "interview_app.option",
  "pk": 1184,
  "fields": {
    "question": 395,
    "key": "b",
    "text": "'fork' копіює батьківський процес (швидко, але небезпечно з потоками). 'spawn' створює новий процес з нуля (повільніше, але безпечно). 'forkserver' створює серверний процес, від якого потім 'форкаються' воркери."
  }
},
{
  "model": "interview_app.option",
  "pk": 1185,
  "fields": {
    "question": 395,
    "key": "c",
    "text": "'spawn' є найшвидшим методом, оскільки не копіює пам'ять."
  }
},
{
  "model": "interview_app.option",
  "pk": 1186,
  "fields": {
    "question": 396,
    "key": "a",
    "text": "Це спосіб утримувати сесію користувача активною на рівні додатку."
  }
},
{
  "model": "interview_app.option",
  "pk": 1187,
  "fields": {
    "question": 396,
    "key": "b",
    "text": "Це команда, яка змушує сервер не закривати з'єднання після відправки відповіді."
  }
},
{
  "model": "interview_app.option",
  "pk": 1188,
  "fields": {
    "question": 396,
    "key": "c",
    "text": "Це механізм, який дозволяє перевіряти, чи з'єднання все ще активне, надсилаючи періодичні 'порожні' пакети. Це запобігає розриву з'єднання через бездіяльність мережевими пристроями (напр., NAT, фаєрволами)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1189,
  "fields": {
    "question": 397,
    "key": "a",
    "text": "Це алгоритм, що об'єднує кілька невеликих вихідних пакетів в один для більш ефективного використання мережі. Його вимикають (опція `TCP_NODELAY`), оскільки він може вносити затримки в очікуванні даних для об'єднання."
  }
},
{
  "model": "interview_app.option",
  "pk": 1190,
  "fields": {
    "question": 397,
    "key": "b",
    "text": "Це алгоритм шифрування, який використовується в TCP-з'єднаннях."
  }
},
{
  "model": "interview_app.option",
  "pk": 1191,
  "fields": {
    "question": 397,
    "key": "c",
    "text": "Це механізм для автоматичного повторного надсилання втрачених пакетів."
  }
},
{
  "model": "interview_app.option",
  "pk": 1192,
  "fields": {
    "question": 398,
    "key": "a",
    "text": "Це фреймворк для створення розширень для браузера для моніторингу веб-трафіку."
  }
},
{
  "model": "interview_app.option",
  "pk": 1193,
  "fields": {
    "question": 398,
    "key": "b",
    "text": "Це технологія, що дозволяє запускати програми в 'пісочниці' всередині ядра ОС, надаючи глибокий та безпечний доступ до системних викликів і мережевого стеку з низькими накладними витратами. Використовується для профілювання та моніторингу."
  }
},
{
  "model": "interview_app.option",
  "pk": 1194,
  "fields": {
    "question": 398,
    "key": "c",
    "text": "Це новий формат байт-коду для Python, який виконується швидше, ніж стандартний."
  }
},
{
  "model": "interview_app.option",
  "pk": 1195,
  "fields": {
    "question": 399,
    "key": "a",
    "text": "Симетричне використовує один і той же ключ для шифрування та дешифрування (напр., AES). Асиметричне використовує пару ключів: публічний для шифрування та приватний для дешифрування (напр., RSA)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1196,
  "fields": {
    "question": 399,
    "key": "b",
    "text": "Симетричне шифрування використовується для автентифікації, а асиметричне — для конфіденційності."
  }
},
{
  "model": "interview_app.option",
  "pk": 1197,
  "fields": {
    "question": 399,
    "key": "c",
    "text": "Асиметричне шифрування швидше, оскільки використовує два ключі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1198,
  "fields": {
    "question": 400,
    "key": "a",
    "text": "Це довірена організація, яка підписує цифрові сертифікати, підтверджуючи, що власник сертифіката є тим, за кого себе видає. Браузери та ОС довіряють сертифікатам, підписаним відомими CA."
  }
},
{
  "model": "interview_app.option",
  "pk": 1199,
  "fields": {
    "question": 400,
    "key": "b",
    "text": "Це сервер, який генерує сертифікати для внутрішнього використання в компанії."
  }
},
{
  "model": "interview_app.option",
  "pk": 1200,
  "fields": {
    "question": 400,
    "key": "c",
    "text": "Це програмне забезпечення на сервері, яке керує TLS-з'єднаннями."
  }
},
{
  "model": "interview_app.option",
  "pk": 1201,
  "fields": {
    "question": 401,
    "key": "a",
    "text": "Це атака, яка виконується в певний, заздалегідь визначений час."
  }
},
{
  "model": "interview_app.option",
  "pk": 1202,
  "fields": {
    "question": 401,
    "key": "b",
    "text": "Це атака, при якій зловмисник аналізує час, необхідний для виконання криптографічних операцій (напр., порівняння паролів чи підписів), щоб отримати інформацію про секретні дані."
  }
},
{
  "model": "interview_app.option",
  "pk": 1203,
  "fields": {
    "question": 401,
    "key": "c",
    "text": "Це спосіб уповільнити роботу сервера, надсилаючи велику кількість запитів, що вимагають багато часу."
  }
},
{
  "model": "interview_app.option",
  "pk": 1204,
  "fields": {
    "question": 402,
    "key": "a",
    "text": "Batch processing завжди швидший, оскільки оптимізований для великих об'ємів."
  }
},
{
  "model": "interview_app.option",
  "pk": 1205,
  "fields": {
    "question": 402,
    "key": "b",
    "text": "Stream processing використовується для текстових даних, а batch processing — для бінарних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1206,
  "fields": {
    "question": 402,
    "key": "c",
    "text": "Batch processing обробляє великі, обмежені набори даних за один раз (напр., нічний звіт). Stream processing обробляє дані безперервно, по мірі їх надходження, в режимі реального часу."
  }
},
{
  "model": "interview_app.option",
  "pk": 1207,
  "fields": {
    "question": 403,
    "key": "a",
    "text": "Data lake зберігає величезні обсяги сирих даних у їхньому нативному форматі ('schema-on-read'). Data warehouse зберігає структуровані, оброблені дані, оптимізовані для аналітики ('schema-on-write')."
  }
},
{
  "model": "interview_app.option",
  "pk": 1208,
  "fields": {
    "question": 403,
    "key": "b",
    "text": "Data lake — це хмарне сховище, а data warehouse — локальне."
  }
},
{
  "model": "interview_app.option",
  "pk": 1209,
  "fields": {
    "question": 403,
    "key": "c",
    "text": "Data lake використовується для невеликих компаній, а data warehouse — для великих корпорацій."
  }
},
{
  "model": "interview_app.option",
  "pk": 1210,
  "fields": {
    "question": 404,
    "key": "a",
    "text": "Це патерн, при якому допоміжний контейнер ('сайдкар') розгортається разом з основним контейнером додатку в одному поді (Pod) для розширення його функціональності (напр., логування, моніторинг, проксі)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1211,
  "fields": {
    "question": 404,
    "key": "b",
    "text": "Це спосіб запустити два екземпляри одного й того ж додатку для високої доступності."
  }
},
{
  "model": "interview_app.option",
  "pk": 1212,
  "fields": {
    "question": 404,
    "key": "c",
    "text": "Це контейнер, який зберігає дані для основного додатку."
  }
},
{
  "model": "interview_app.option",
  "pk": 1213,
  "fields": {
    "question": 405,
    "key": "a",
    "text": "Serverless абстрагує все, окрім коду функції; ви платите за час виконання. CaaS абстрагує сервери, але ви все ще керуєте контейнерами як довготривалими процесами; ви платите за ресурси, виділені контейнеру."
  }
},
{
  "model": "interview_app.option",
  "pk": 1214,
  "fields": {
    "question": 405,
    "key": "b",
    "text": "Serverless призначений лише для Python, а CaaS — для будь-яких мов."
  }
},
{
  "model": "interview_app.option",
  "pk": 1215,
  "fields": {
    "question": 405,
    "key": "c",
    "text": "CaaS є дешевшою, але менш масштабованою альтернативою serverless."
  }
},
{
  "model": "interview_app.option",
  "pk": 1216,
  "fields": {
    "question": 406,
    "key": "a",
    "text": "Це інструмент для валідації зовнішніх даних перед їх імпортом у PostgreSQL."
  }
},
{
  "model": "interview_app.option",
  "pk": 1217,
  "fields": {
    "question": 406,
    "key": "b",
    "text": "Це обгортки для даних, які забезпечують їх шифрування при зберіганні."
  }
},
{
  "model": "interview_app.option",
  "pk": 1218,
  "fields": {
    "question": 406,
    "key": "c",
    "text": "Вони дозволяють звертатися до даних, що знаходяться в зовнішніх системах (іншій БД, файлі, веб-сервісі), так, ніби це звичайні таблиці в локальній базі даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1219,
  "fields": {
    "question": 407,
    "key": "a",
    "text": "Це процес розділення прав доступу до таблиці між різними користувачами."
  }
},
{
  "model": "interview_app.option",
  "pk": 1220,
  "fields": {
    "question": 407,
    "key": "b",
    "text": "Це створення копій таблиці на різних дисках для резервування."
  }
},
{
  "model": "interview_app.option",
  "pk": 1221,
  "fields": {
    "question": 407,
    "key": "c",
    "text": "Це техніка розбиття однієї великої логічної таблиці на кілька менших фізичних частин (партицій) за певним ключем (напр., дата, регіон). Це може значно покращити продуктивність запитів та спростити керування даними."
  }
},
{
  "model": "interview_app.option",
  "pk": 1222,
  "fields": {
    "question": 408,
    "key": "a",
    "text": "Воно стискає текстові дані для економії місця."
  }
},
{
  "model": "interview_app.option",
  "pk": 1223,
  "fields": {
    "question": 408,
    "key": "b",
    "text": "Воно розбиває текст на триграми (послідовності з трьох символів) і створює індекс на їх основі, що дозволяє дуже швидко виконувати нечіткий пошук рядків (fuzzy search) та визначати схожість."
  }
},
{
  "model": "interview_app.option",
  "pk": 1224,
  "fields": {
    "question": 408,
    "key": "c",
    "text": "Воно дозволяє виконувати повнотекстовий пошук з урахуванням морфології."
  }
},
{
  "model": "interview_app.option",
  "pk": 1225,
  "fields": {
    "question": 409,
    "key": "a",
    "text": "Це техніка для зменшення навантаження на базу даних шляхом кешування запитів."
  }
},
{
  "model": "interview_app.option",
  "pk": 1226,
  "fields": {
    "question": 409,
    "key": "b",
    "text": "Це процес розподілу вхідного трафіку між кількома серверами. Round Robin по черзі відправляє запити на кожен сервер. Least Connections відправляє запит на сервер з найменшою кількістю активних з'єднань."
  }
},
{
  "model": "interview_app.option",
  "pk": 1227,
  "fields": {
    "question": 409,
    "key": "c",
    "text": "Це спосіб збалансувати навантаження на центральний процесор сервера."
  }
},
{
  "model": "interview_app.option",
  "pk": 1228,
  "fields": {
    "question": 410,
    "key": "a",
    "text": "Це мережа, яка доставляє динамічний контент, генерований Python-додатком."
  }
},
{
  "model": "interview_app.option",
  "pk": 1229,
  "fields": {
    "question": 410,
    "key": "b",
    "text": "Це система для захисту від DDoS-атак шляхом фільтрації трафіку."
  }
},
{
  "model": "interview_app.option",
  "pk": 1230,
  "fields": {
    "question": 410,
    "key": "c",
    "text": "Це географічно розподілена мережа серверів, яка зберігає кешовані копії статичного контенту (зображення, CSS) і доставляє їх користувачам з найближчого до них сервера, зменшуючи затримки."
  }
},
{
  "model": "interview_app.option",
  "pk": 1231,
  "fields": {
    "question": 411,
    "key": "a",
    "text": "Це принцип, який стверджує, що архітектура системи, яку проектує організація, буде відображати комунікаційну структуру цієї організації. Наприклад, команда з 4 людей, швидше за все, створить 4-компонентну систему."
  }
},
{
  "model": "interview_app.option",
  "pk": 1232,
  "fields": {
    "question": 411,
    "key": "b",
    "text": "Це закон, що описує максимальну кількість мікросервісів, якими може керувати одна команда."
  }
},
{
  "model": "interview_app.option",
  "pk": 1233,
  "fields": {
    "question": 411,
    "key": "c",
    "text": "Це правило, згідно з яким код повинен бути максимально простим і зрозумілим."
  }
},
{
  "model": "interview_app.option",
  "pk": 1234,
  "fields": {
    "question": 412,
    "key": "a",
    "text": "API Gateway працює на рівні мережі, а BFF — на рівні коду додатку."
  }
},
{
  "model": "interview_app.option",
  "pk": 1235,
  "fields": {
    "question": 412,
    "key": "b",
    "text": "BFF — це застаріла назва для API Gateway."
  }
},
{
  "model": "interview_app.option",
  "pk": 1236,
  "fields": {
    "question": 412,
    "key": "c",
    "text": "API Gateway — це загальна точка входу для всіх клієнтів. BFF — це специфічний API Gateway, створений для конкретного фронтенд-додатку (напр., мобільного), який агрегує дані з кількох мікросервісів в оптимальному для цього клієнта форматі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1237,
  "fields": {
    "question": 413,
    "key": "a",
    "text": "Це змінна, що містить шлях до метакласів, які використовуються в проекті."
  }
},
{
  "model": "interview_app.option",
  "pk": 1238,
  "fields": {
    "question": 413,
    "key": "b",
    "text": "Це список об'єктів-пошуковців (finders). Коли Python намагається імпортувати модуль, він по черзі викликає метод `find_spec()` кожного об'єкта в цьому списку. Це дозволяє перехоплювати процес імпорту і завантажувати модулі з нестандартних джерел."
  }
},
{
  "model": "interview_app.option",
  "pk": 1239,
  "fields": {
    "question": 413,
    "key": "c",
    "text": "Це кеш, де Python зберігає шляхи до вже імпортованих модулів."
  }
},
{
  "model": "interview_app.option",
  "pk": 1240,
  "fields": {
    "question": 414,
    "key": "a",
    "text": "Це API для створення клієнтських додатків, які взаємодіють з Python-сервером."
  }
},
{
  "model": "interview_app.option",
  "pk": 1241,
  "fields": {
    "question": 414,
    "key": "b",
    "text": "Він дозволяє писати розширення для Python на мові C/C++, що використовується для створення високопродуктивних модулів (напр., для наукових обчислень) або для інтеграції з існуючими C-бібліотеками."
  }
},
{
  "model": "interview_app.option",
  "pk": 1242,
  "fields": {
    "question": 414,
    "key": "c",
    "text": "Це стандарт, який описує, як Python-код повинен бути скомпільований у C."
  }
},
{
  "model": "interview_app.option",
  "pk": 1243,
  "fields": {
    "question": 415,
    "key": "a",
    "text": "Це плагін для Celery, який дозволяє малювати графіки залежностей між задачами."
  }
},
{
  "model": "interview_app.option",
  "pk": 1244,
  "fields": {
    "question": 415,
    "key": "b",
    "text": "Це алгоритм, який оптимізує маршрутизацію задач Celery."
  }
},
{
  "model": "interview_app.option",
  "pk": 1245,
  "fields": {
    "question": 415,
    "key": "c",
    "text": "Це веб-інструмент для моніторингу та керування воркерами та задачами Celery в реальному часі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1246,
  "fields": {
    "question": 416,
    "key": "a",
    "text": "Це робиться автоматично; Celery завжди відправляє задачі в чергу з найменшою кількістю задач."
  }
},
{
  "model": "interview_app.option",
  "pk": 1247,
  "fields": {
    "question": 416,
    "key": "b",
    "text": "Для кожної черги потрібно запускати окремий екземпляр брокера повідомлень."
  }
},
{
  "model": "interview_app.option",
  "pk": 1248,
  "fields": {
    "question": 416,
    "key": "c",
    "text": "За допомогою налаштування `task_routes`, яке дозволяє направляти задачі в певні черги на основі їхнього імені або інших властивостей. Воркери потім можна налаштувати на прослуховування лише конкретних черг."
  }
},
{
  "model": "interview_app.option",
  "pk": 1249,
  "fields": {
    "question": 417,
    "key": "a",
    "text": "Регіон — це країна, а зона доступності — це місто."
  }
},
{
  "model": "interview_app.option",
  "pk": 1250,
  "fields": {
    "question": 417,
    "key": "b",
    "text": "Це синоніми, що позначають дата-центр."
  }
},
{
  "model": "interview_app.option",
  "pk": 1251,
  "fields": {
    "question": 417,
    "key": "c",
    "text": "Регіон — це окрема географічна область. Зона доступності — це один або кілька ізольованих дата-центрів у межах регіону. Розгортання додатку в кількох AZ забезпечує високу доступність у разі відмови однієї з них."
  }
},
{
  "model": "interview_app.option",
  "pk": 1252,
  "fields": {
    "question": 418,
    "key": "a",
    "text": "Ansible використовує JSON для конфігурації, а Terraform — YAML."
  }
},
{
  "model": "interview_app.option",
  "pk": 1253,
  "fields": {
    "question": 418,
    "key": "b",
    "text": "IaC — це керування інфраструктурою через код. Terraform є декларативним і фокусується на створенні та керуванні станом інфраструктури. Ansible є процедурним і зазвичай використовується для конфігурації вже існуючих серверів."
  }
},
{
  "model": "interview_app.option",
  "pk": 1254,
  "fields": {
    "question": 418,
    "key": "c",
    "text": "Terraform працює лише з AWS, а Ansible — з будь-якою хмарою."
  }
},
{
  "model": "interview_app.option",
  "pk": 1255,
  "fields": {
    "question": 419,
    "key": "a",
    "text": "Це стратегія, при якій екземпляри додатку оновлюються поступово, один за одним або невеликими групами. Старі версії замінюються новими, що забезпечує оновлення без простою."
  }
},
{
  "model": "interview_app.option",
  "pk": 1256,
  "fields": {
    "question": 419,
    "key": "b",
    "text": "Це оновлення, яке 'відкочується' назад у разі помилки."
  }
},
{
  "model": "interview_app.option",
  "pk": 1257,
  "fields": {
    "question": 419,
    "key": "c",
    "text": "Це повна зупинка старої версії додатку і запуск нової."
  }
},
{
  "model": "interview_app.option",
  "pk": 1258,
  "fields": {
    "question": 420,
    "key": "a",
    "text": "Це специфікація та реалізація, яка дозволяє веб-браузерам (які не можуть напряму працювати з HTTP/2 gRPC) взаємодіяти з gRPC-сервісами через спеціальний проксі-сервер."
  }
},
{
  "model": "interview_app.option",
  "pk": 1259,
  "fields": {
    "question": 420,
    "key": "b",
    "text": "Це нова версія gRPC, яка працює повністю через WebSockets."
  }
},
{
  "model": "interview_app.option",
  "pk": 1260,
  "fields": {
    "question": 420,
    "key": "c",
    "text": "Це фреймворк для створення веб-інтерфейсів за допомогою gRPC."
  }
},
{
  "model": "interview_app.option",
  "pk": 1261,
  "fields": {
    "question": 421,
    "key": "a",
    "text": "Це синоніми, що означають процес входу користувача в систему."
  }
},
{
  "model": "interview_app.option",
  "pk": 1262,
  "fields": {
    "question": 421,
    "key": "b",
    "text": "Це два етапи одного й того ж процесу; авторизація завжди йде першою."
  }
},
{
  "model": "interview_app.option",
  "pk": 1263,
  "fields": {
    "question": 421,
    "key": "c",
    "text": "Автентифікація — це процес перевірки, ким є користувач (напр., перевірка логіна та пароля). Авторизація — це процес перевірки, чи має автентифікований користувач права на виконання певної дії."
  }
},
{
  "model": "interview_app.option",
  "pk": 1264,
  "fields": {
    "question": 422,
    "key": "a",
    "text": "Це алгоритм, який мінімізує кількість ключів, що потребують перерозподілу при додаванні або видаленні одного вузла у розподіленому хешуванні. Часто використовується в кешуванні та розподілених базах даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1265,
  "fields": {
    "question": 422,
    "key": "b",
    "text": "Це спосіб хешування, який гарантує відсутність колізій."
  }
},
{
  "model": "interview_app.option",
  "pk": 1266,
  "fields": {
    "question": 422,
    "key": "c",
    "text": "Це техніка, при якій хеш-функція завжди повертає однаковий результат для будь-яких вхідних даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1267,
  "fields": {
    "question": 423,
    "key": "a",
    "text": "Бінарні протоколи легше налагоджувати, оскільки їх можна читати в текстовому редакторі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1268,
  "fields": {
    "question": 423,
    "key": "b",
    "text": "Це протокол, де дані передаються у бінарному форматі, а не як рядки. Переваги: компактність (менший розмір), швидкість парсингу та строга типізація. Приклади: Protocol Buffers, Avro."
  }
},
{
  "model": "interview_app.option",
  "pk": 1269,
  "fields": {
    "question": 423,
    "key": "c",
    "text": "Вони менш безпечні, оскільки не підтримують шифрування."
  }
},
{
  "model": "interview_app.option",
  "pk": 1270,
  "fields": {
    "question": 424,
    "key": "a",
    "text": "Це відкритий стандарт та набір інструментів для збору та експорту телеметричних даних (метрики, логи, трейси) з додатків, що забезпечує уніфікований підхід до observability."
  }
},
{
  "model": "interview_app.option",
  "pk": 1271,
  "fields": {
    "question": 424,
    "key": "b",
    "text": "Це бібліотека для вимірювання швидкості виконання Python-коду."
  }
},
{
  "model": "interview_app.option",
  "pk": 1272,
  "fields": {
    "question": 424,
    "key": "c",
    "text": "Це комерційний продукт для моніторингу, який конкурує з Datadog."
  }
},
{
  "model": "interview_app.option",
  "pk": 1273,
  "fields": {
    "question": 425,
    "key": "a",
    "text": "Це процес переміщення логіки з додатку в базу даних за допомогою збережених процедур."
  }
},
{
  "model": "interview_app.option",
  "pk": 1274,
  "fields": {
    "question": 425,
    "key": "b",
    "text": "Це техніка, при якій предикати з `HAVING` перетворюються на предикати `WHERE`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1275,
  "fields": {
    "question": 425,
    "key": "c",
    "text": "Це оптимізація, при якій умови з `WHERE` 'проштовхуються' якомога глибше в план запиту (наприклад, до операції сканування таблиці), щоб відфільтрувати дані на ранньому етапі і зменшити обсяг, що передається далі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1276,
  "fields": {
    "question": 426,
    "key": "a",
    "text": "Nested Loop ітерує по одному набору і для кожного рядка шукає збіги в іншому. Hash Join будує хеш-таблицю для меншого набору. Merge Join вимагає відсортованих наборів і зливає їх."
  }
},
{
  "model": "interview_app.option",
  "pk": 1277,
  "fields": {
    "question": 426,
    "key": "b",
    "text": "Nested Loop найшвидший для великих таблиць, а Hash Join — для малих."
  }
},
{
  "model": "interview_app.option",
  "pk": 1278,
  "fields": {
    "question": 426,
    "key": "c",
    "text": "Merge Join — це єдиний тип об'єднання, який може працювати з `FULL OUTER JOIN`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1279,
  "fields": {
    "question": 427,
    "key": "a",
    "text": "Це міра того, наскільки дані в таблиці нормалізовані."
  }
},
{
  "model": "interview_app.option",
  "pk": 1280,
  "fields": {
    "question": 427,
    "key": "b",
    "text": "Це загальна кількість рядків у таблиці."
  }
},
{
  "model": "interview_app.option",
  "pk": 1281,
  "fields": {
    "question": 427,
    "key": "c",
    "text": "Це кількість унікальних значень у колонці. Оптимізатор використовує статистику про кардинальність для оцінки кількості рядків, які поверне операція, що допомагає йому вибрати найефективніший план запиту."
  }
},
{
  "model": "interview_app.option",
  "pk": 1282,
  "fields": {
    "question": 428,
    "key": "a",
    "text": "Для фізичного стиснення даних у таблицях для економії місця на диску."
  }
},
{
  "model": "interview_app.option",
  "pk": 1283,
  "fields": {
    "question": 428,
    "key": "b",
    "text": "Для очищення кешу запитів, щоб звільнити пам'ять."
  }
},
{
  "model": "interview_app.option",
  "pk": 1284,
  "fields": {
    "question": 428,
    "key": "c",
    "text": "Для звільнення місця, зайнятого 'мертвими' рядками (після UPDATE або DELETE), та для оновлення статистики, яку використовує планувальник запитів. `AUTOVACUUM` робить це автоматично у фоновому режимі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1285,
  "fields": {
    "question": 429,
    "key": "a",
    "text": "Це індекс, який тимчасово вимкнений і не використовується оптимізатором."
  }
},
{
  "model": "interview_app.option",
  "pk": 1286,
  "fields": {
    "question": 429,
    "key": "b",
    "text": "Це індекс, який покриває лише частину колонок таблиці."
  }
},
{
  "model": "interview_app.option",
  "pk": 1287,
  "fields": {
    "question": 429,
    "key": "c",
    "text": "Це індекс, який будується лише для підмножини рядків таблиці, визначеної умовою `WHERE`. Це корисно для індексації рідкісних значень або для виключення `NULL` значень, що зменшує розмір індексу."
  }
},
{
  "model": "interview_app.option",
  "pk": 1288,
  "fields": {
    "question": 430,
    "key": "a",
    "text": "Це сканування, яке використовує лише один індекс, навіть якщо їх є кілька."
  }
},
{
  "model": "interview_app.option",
  "pk": 1289,
  "fields": {
    "question": 430,
    "key": "b",
    "text": "Це повне сканування індексу, а не таблиці."
  }
},
{
  "model": "interview_app.option",
  "pk": 1290,
  "fields": {
    "question": 430,
    "key": "c",
    "text": "Це операція, при якій база даних може відповісти на запит, використовуючи лише дані з індексу, без необхідності звертатися до самої таблиці ('heap'). Це можливо, коли всі потрібні колонки є в індексі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1291,
  "fields": {
    "question": 431,
    "key": "a",
    "text": "Це CTE, який викликається кілька разів у межах одного запиту."
  }
},
{
  "model": "interview_app.option",
  "pk": 1292,
  "fields": {
    "question": 431,
    "key": "b",
    "text": "Це техніка, при якій CTE рекурсивно викликає збережену процедуру."
  }
},
{
  "model": "interview_app.option",
  "pk": 1293,
  "fields": {
    "question": 431,
    "key": "c",
    "text": "Це CTE, що складається з 'якірного' (anchor) запиту і рекурсивного запиту, який посилається на сам CTE. Використовується для обробки ієрархічних або графових структур, наприклад, для побудови дерева менеджер-підлеглий."
  }
},
{
  "model": "interview_app.option",
  "pk": 1294,
  "fields": {
    "question": 432,
    "key": "a",
    "text": "Немає різниці, `ALL` є необов'язковим ключовим словом."
  }
},
{
  "model": "interview_app.option",
  "pk": 1295,
  "fields": {
    "question": 432,
    "key": "b",
    "text": "`UNION ALL` працює лише якщо таблиці мають однакову кількість колонок, а `UNION` — ні."
  }
},
{
  "model": "interview_app.option",
  "pk": 1296,
  "fields": {
    "question": 432,
    "key": "c",
    "text": "`UNION` об'єднує результати двох запитів і видаляє дублікати, що вимагає сортування або хешування. `UNION ALL` просто об'єднує результати без перевірки на унікальність, що значно швидше."
  }
},
{
  "model": "interview_app.option",
  "pk": 1297,
  "fields": {
    "question": 433,
    "key": "a",
    "text": "Це оператори, які працюють на рівні колонок, а не рядків."
  }
},
{
  "model": "interview_app.option",
  "pk": 1298,
  "fields": {
    "question": 433,
    "key": "b",
    "text": "`INTERSECT` повертає рядки, які є в результатах обох запитів. `EXCEPT` повертає рядки з першого запиту, яких немає в другому."
  }
},
{
  "model": "interview_app.option",
  "pk": 1299,
  "fields": {
    "question": 433,
    "key": "c",
    "text": "Це синоніми для `INNER JOIN` та `LEFT JOIN ... WHERE ... IS NULL` відповідно."
  }
},
{
  "model": "interview_app.option",
  "pk": 1300,
  "fields": {
    "question": 434,
    "key": "a",
    "text": "Це тимчасова таблиця, яка існує лише в межах однієї сесії."
  }
},
{
  "model": "interview_app.option",
  "pk": 1301,
  "fields": {
    "question": 434,
    "key": "b",
    "text": "Це віртуальна таблиця, яка виконує запит кожного разу, коли до неї звертаються."
  }
},
{
  "model": "interview_app.option",
  "pk": 1302,
  "fields": {
    "question": 434,
    "key": "c",
    "text": "Це об'єкт бази даних, який зберігає результат запиту у вигляді фізичної таблиці. Її використовують для складних та довготривалих запитів, які не потребують даних у реальному часі, оскільки дані потрібно періодично оновлювати (`REFRESH`)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1303,
  "fields": {
    "question": 435,
    "key": "a",
    "text": "Це механізм, який запобігає будь-яким змінам у таблиці."
  }
},
{
  "model": "interview_app.option",
  "pk": 1304,
  "fields": {
    "question": 435,
    "key": "b",
    "text": "Це заплановане завдання, яке виконується за розкладом."
  }
},
{
  "model": "interview_app.option",
  "pk": 1305,
  "fields": {
    "question": 435,
    "key": "c",
    "text": "Це процедура, яка автоматично виконується у відповідь на певні події (INSERT, UPDATE, DELETE) з таблицею. Недоліком є прихована бізнес-логіка, яка ускладнює розуміння та налагодження додатку."
  }
},
{
  "model": "interview_app.option",
  "pk": 1306,
  "fields": {
    "question": 436,
    "key": "a",
    "text": "Це рівні доступу користувачів до бази даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1307,
  "fields": {
    "question": 436,
    "key": "b",
    "text": "Це налаштування, що визначають, скільки пам'яті виділяється для транзакції."
  }
},
{
  "model": "interview_app.option",
  "pk": 1308,
  "fields": {
    "question": 436,
    "key": "c",
    "text": "Вони визначають, які аномалії (брудне читання, неповторюване читання, фантоми) дозволені. `Serializable` є найсуворішим, `Read Uncommitted` — найменш."
  }
},
{
  "model": "interview_app.option",
  "pk": 1309,
  "fields": {
    "question": 437,
    "key": "a",
    "text": "Це аномалія, коли транзакція при повторному читанні з тією ж умовою `WHERE` бачить нові рядки, додані іншою транзакцією. Їй запобігає рівень `Serializable`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1310,
  "fields": {
    "question": 437,
    "key": "b",
    "text": "Це коли транзакція бачить різні значення для одного й того ж рядка при повторному читанні. Запобігає `Repeatable Read`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1311,
  "fields": {
    "question": 437,
    "key": "c",
    "text": "Це коли транзакція читає дані, які потім були видалені."
  }
},
{
  "model": "interview_app.option",
  "pk": 1312,
  "fields": {
    "question": 438,
    "key": "a",
    "text": "Для збереження результатів запиту у файл."
  }
},
{
  "model": "interview_app.option",
  "pk": 1313,
  "fields": {
    "question": 438,
    "key": "b",
    "text": "Вони дозволяють створювати точки збереження всередині транзакції, до яких можна частково відкотитися (`ROLLBACK TO SAVEPOINT`), не скасовуючи всю транзакцію."
  }
},
{
  "model": "interview_app.option",
  "pk": 1314,
  "fields": {
    "question": 438,
    "key": "c",
    "text": "Для створення резервної копії бази даних перед початком транзакції."
  }
},
{
  "model": "interview_app.option",
  "pk": 1315,
  "fields": {
    "question": 439,
    "key": "a",
    "text": "Це процес, при якому коміт виконується у два етапи: спочатку для індексів, потім для даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1316,
  "fields": {
    "question": 439,
    "key": "b",
    "text": "Це протокол для забезпечення атомарності розподілених транзакцій (що охоплюють кілька баз даних). Він складається з фази 'prepare', де всі учасники голосують, чи можуть вони виконати коміт, і фази 'commit', де вони всі разом фіксують або скасовують зміни."
  }
},
{
  "model": "interview_app.option",
  "pk": 1317,
  "fields": {
    "question": 439,
    "key": "c",
    "text": "Це вимога зробити `COMMIT` двічі для підтвердження транзакції."
  }
},
{
  "model": "interview_app.option",
  "pk": 1318,
  "fields": {
    "question": 440,
    "key": "a",
    "text": "`->` — для об'єктів, `->>` — для масивів, `@>` — для скалярних значень."
  }
},
{
  "model": "interview_app.option",
  "pk": 1319,
  "fields": {
    "question": 440,
    "key": "b",
    "text": "`->` отримує елемент за ключем або індексом як JSONB. `->>` отримує його як текст. `@>` перевіряє, чи містить лівий JSONB правий (чи є він його надмножиною)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1320,
  "fields": {
    "question": 440,
    "key": "c",
    "text": "Це синоніми, які роблять одне й те саме, але для різних версій PostgreSQL."
  }
},
{
  "model": "interview_app.option",
  "pk": 1321,
  "fields": {
    "question": 441,
    "key": "a",
    "text": "Це процес приведення схеми бази даних до ще більш суворих нормальних форм, ніж 3NF."
  }
},
{
  "model": "interview_app.option",
  "pk": 1322,
  "fields": {
    "question": 441,
    "key": "b",
    "text": "Це процес навмисного додавання надлишкових даних до таблиць для уникнення складних JOIN'ів та підвищення продуктивності читання, жертвуючи при цьому простотою запису та цілісністю даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1323,
  "fields": {
    "question": 441,
    "key": "c",
    "text": "Це помилка в проектуванні, якої слід уникати за будь-яких обставин."
  }
},
{
  "model": "interview_app.option",
  "pk": 1324,
  "fields": {
    "question": 442,
    "key": "a",
    "text": "Тому що B-Tree індекси не підтримують тип UUID."
  }
},
{
  "model": "interview_app.option",
  "pk": 1325,
  "fields": {
    "question": 442,
    "key": "b",
    "text": "Тому що UUID довші за `INTEGER`, і тому індекс працює повільніше."
  }
},
{
  "model": "interview_app.option",
  "pk": 1326,
  "fields": {
    "question": 442,
    "key": "c",
    "text": "Тому що UUID не є послідовними. Це призводить до фрагментації індексу, оскільки нові записи вставляються у випадкові місця, що робить індекс більшим і менш ефективним для кешування."
  }
},
{
  "model": "interview_app.option",
  "pk": 1327,
  "fields": {
    "question": 443,
    "key": "a",
    "text": "Це обмеження, яке перевіряє наявність відповідного запису в іншій таблиці."
  }
},
{
  "model": "interview_app.option",
  "pk": 1328,
  "fields": {
    "question": 443,
    "key": "b",
    "text": "Це обмеження, яке гарантує, що значення в колонці або кількох колонках відповідають певній булевій умові (наприклад, `price > 0`)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1329,
  "fields": {
    "question": 443,
    "key": "c",
    "text": "Це обмеження, яке перевіряє унікальність значень у колонці."
  }
},
{
  "model": "interview_app.option",
  "pk": 1330,
  "fields": {
    "question": 444,
    "key": "a",
    "text": "Це розширення `GROUP BY`, яке дозволяє визначити кілька наборів групування в одному запиті, що еквівалентно виконанню `UNION ALL` для кількох окремих запитів `GROUP BY`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1331,
  "fields": {
    "question": 444,
    "key": "b",
    "text": "Це спосіб групувати дані по наборах значень, а не по окремих значеннях."
  }
},
{
  "model": "interview_app.option",
  "pk": 1332,
  "fields": {
    "question": 444,
    "key": "c",
    "text": "Це функція, яка встановлює, які колонки будуть використовуватися для групування за замовчуванням."
  }
},
{
  "model": "interview_app.option",
  "pk": 1333,
  "fields": {
    "question": 445,
    "key": "a",
    "text": "Вона повертає перше зі своїх аргументів, яке не є `NULL`. Використовується для заміни `NULL` значень на значення за замовчуванням."
  }
},
{
  "model": "interview_app.option",
  "pk": 1334,
  "fields": {
    "question": 445,
    "key": "b",
    "text": "Вона об'єднує кілька рядків в один."
  }
},
{
  "model": "interview_app.option",
  "pk": 1335,
  "fields": {
    "question": 445,
    "key": "c",
    "text": "Вона перевіряє, чи є два значення рівними, враховуючи `NULL`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1336,
  "fields": {
    "question": 446,
    "key": "a",
    "text": "`ROW_NUMBER` дає унікальний номер кожному рядку. `RANK` дає однакові ранги рядкам з однаковими значеннями, але з пропусками в нумерації. `DENSE_RANK` робить те ж саме, але без пропусків."
  }
},
{
  "model": "interview_app.option",
  "pk": 1337,
  "fields": {
    "question": 446,
    "key": "b",
    "text": "Всі три функції роблять одне й те саме, але оптимізовані для різних типів даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1338,
  "fields": {
    "question": 446,
    "key": "c",
    "text": "`DENSE_RANK` є найшвидшою, а `ROW_NUMBER` — найповільнішою."
  }
},
{
  "model": "interview_app.option",
  "pk": 1339,
  "fields": {
    "question": 447,
    "key": "a",
    "text": "Це спосіб відфільтрувати результати віконної функції."
  }
},
{
  "model": "interview_app.option",
  "pk": 1340,
  "fields": {
    "question": 447,
    "key": "b",
    "text": "Це синтаксис (напр., `COUNT(id) FILTER (WHERE status = 'active')`), який дозволяє застосувати умову `WHERE` до аргументів агрегатної функції, не фільтруючи при цьому всі рядки запиту."
  }
},
{
  "model": "interview_app.option",
  "pk": 1341,
  "fields": {
    "question": 447,
    "key": "c",
    "text": "Це синонім для `HAVING`, який застосовується після агрегації."
  }
},
{
  "model": "interview_app.option",
  "pk": 1342,
  "fields": {
    "question": 448,
    "key": "a",
    "text": "Це індекс для бінарних даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1343,
  "fields": {
    "question": 448,
    "key": "b",
    "text": "Це індекс, який зберігає мінімальне та максимальне значення для діапазону блоків сторінок. Він дуже маленький і ефективний для великих таблиць з даними, що мають природну кореляцію з їхнім фізичним розташуванням (напр., лог-таблиці з часовими мітками)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1344,
  "fields": {
    "question": 448,
    "key": "c",
    "text": "Це стиснена версія B-Tree індексу."
  }
},
{
  "model": "interview_app.option",
  "pk": 1345,
  "fields": {
    "question": 449,
    "key": "a",
    "text": "Це обмеження (напр., `FOREIGN KEY`), перевірку якого можна відкласти до кінця транзакції. Це корисно для операцій, які тимчасово порушують цілісність, наприклад, для циклічних посилань."
  }
},
{
  "model": "interview_app.option",
  "pk": 1346,
  "fields": {
    "question": 449,
    "key": "b",
    "text": "Це обмеження, які можна тимчасово вимкнути для всієї бази даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1347,
  "fields": {
    "question": 449,
    "key": "c",
    "text": "Це обмеження, які перевіряються лише для нових рядків, а не для існуючих."
  }
},
{
  "model": "interview_app.option",
  "pk": 1348,
  "fields": {
    "question": 450,
    "key": "a",
    "text": "Він показує, як дані буферизуються перед відправкою клієнту."
  }
},
{
  "model": "interview_app.option",
  "pk": 1349,
  "fields": {
    "question": 450,
    "key": "b",
    "text": "Він аналізує, скільки пам'яті (буферів) потрібно виділити для виконання запиту."
  }
},
{
  "model": "interview_app.option",
  "pk": 1350,
  "fields": {
    "question": 450,
    "key": "c",
    "text": "Окрім виконання запиту та показу реального часу, він надає інформацію про використання буферів (скільки блоків було прочитано з диска, а скільки — з кешу), що допомагає оцінити ефективність I/O."
  }
},
{
  "model": "interview_app.option",
  "pk": 1351,
  "fields": {
    "question": 451,
    "key": "a",
    "text": "Це система для реплікації даних на інші сервери."
  }
},
{
  "model": "interview_app.option",
  "pk": 1352,
  "fields": {
    "question": 451,
    "key": "b",
    "text": "Це лог, який записує всі повільні запити."
  }
},
{
  "model": "interview_app.option",
  "pk": 1353,
  "fields": {
    "question": 451,
    "key": "c",
    "text": "Це механізм, при якому всі зміни записуються в журнал транзакцій (`WAL`) на диск перед тим, як вони будуть застосовані до файлів даних. Це гарантує довговічність (Durability) та можливість відновлення після збоїв."
  }
},
{
  "model": "interview_app.option",
  "pk": 1354,
  "fields": {
    "question": 452,
    "key": "a",
    "text": "`TRUNCATE` є DDL-операцією, яка швидко видаляє всі рядки з таблиці, зазвичай без можливості відкату та не активуючи тригери. `DELETE` є DML-операцією, яка видаляє рядки по одному і може бути відкочена."
  }
},
{
  "model": "interview_app.option",
  "pk": 1355,
  "fields": {
    "question": 452,
    "key": "b",
    "text": "`DELETE` швидший, оскільки працює з меншою кількістю даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1356,
  "fields": {
    "question": 452,
    "key": "c",
    "text": "Різниці немає, `TRUNCATE` — це просто синтаксичний цукор для `DELETE FROM table`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1357,
  "fields": {
    "question": 453,
    "key": "a",
    "text": "Це тип даних для зберігання послідовностей ДНК."
  }
},
{
  "model": "interview_app.option",
  "pk": 1358,
  "fields": {
    "question": 453,
    "key": "b",
    "text": "Це впорядкований набір рядків, повернутий запитом."
  }
},
{
  "model": "interview_app.option",
  "pk": 1359,
  "fields": {
    "question": 453,
    "key": "c",
    "text": "Це об'єкт, який генерує послідовність унікальних цілих чисел. Часто використовується для автоматичного створення значень первинних ключів (аналог `AUTO_INCREMENT` або `SERIAL`)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1360,
  "fields": {
    "question": 454,
    "key": "a",
    "text": "Тому що оператор `OR` є логічно складнішим для процесора, ніж `AND`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1361,
  "fields": {
    "question": 454,
    "key": "b",
    "text": "Тому що оптимізатор рідко може ефективно використовувати кілька окремих індексів для умови `OR`. Йому часто доводиться робити повне сканування або комбінувати результати сканування кількох індексів, що може бути повільно."
  }
},
{
  "model": "interview_app.option",
  "pk": 1362,
  "fields": {
    "question": 454,
    "key": "c",
    "text": "Тому що SQL-стандарт вимагає, щоб `OR` завжди виконувався після `AND`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1363,
  "fields": {
    "question": 455,
    "key": "a",
    "text": "Це синоніми для одного й того ж процесу повної автоматизації від коміту до продакшену."
  }
},
{
  "model": "interview_app.option",
  "pk": 1364,
  "fields": {
    "question": 455,
    "key": "b",
    "text": "Continuous Delivery означає, що кожна зміна автоматично готова до релізу, але сам реліз в продакшен вимагає ручного підтвердження. Continuous Deployment автоматизує і цей останній крок."
  }
},
{
  "model": "interview_app.option",
  "pk": 1365,
  "fields": {
    "question": 455,
    "key": "c",
    "text": "Continuous Delivery — це доставка артефактів в репозиторій, а Continuous Deployment — їх розгортання на сервери."
  }
},
{
  "model": "interview_app.option",
  "pk": 1366,
  "fields": {
    "question": 456,
    "key": "a",
    "text": "Команди, що змінюються рідко (напр., встановлення залежностей через `pip install`), слід розміщувати раніше, щоб їх шари кешувалися і не перебудовувалися при кожній зміні коду додатку, який копіюється пізніше."
  }
},
{
  "model": "interview_app.option",
  "pk": 1367,
  "fields": {
    "question": 456,
    "key": "b",
    "text": "Порядок не має значення, Docker завжди перебудовує весь образ з нуля для надійності."
  }
},
{
  "model": "interview_app.option",
  "pk": 1368,
  "fields": {
    "question": 456,
    "key": "c",
    "text": "Найкраще кешування досягається, якщо команда `COPY . .` стоїть на самому початку Dockerfile."
  }
},
{
  "model": "interview_app.option",
  "pk": 1369,
  "fields": {
    "question": 457,
    "key": "a",
    "text": "Щоб виключити файли та директорії (напр., `.git`, `__pycache__`, локальні середовища) з контексту збірки, що зменшує розмір контексту та запобігає потраплянню непотрібних файлів в образ."
  }
},
{
  "model": "interview_app.option",
  "pk": 1370,
  "fields": {
    "question": 457,
    "key": "b",
    "text": "Це файл, який містить список образів, які не слід видаляти при очищенні системи."
  }
},
{
  "model": "interview_app.option",
  "pk": 1371,
  "fields": {
    "question": 457,
    "key": "c",
    "text": "Щоб вказати Docker, які файли слід ігнорувати при запуску контейнера."
  }
},
{
  "model": "interview_app.option",
  "pk": 1372,
  "fields": {
    "question": 458,
    "key": "a",
    "text": "При збої Readiness Probe, щоб він швидше став готовим до роботи."
  }
},
{
  "model": "interview_app.option",
  "pk": 1373,
  "fields": {
    "question": 458,
    "key": "b",
    "text": "При збої Liveness Probe, оскільки це свідчить, що додаток 'мертвий' і потребує перезапуску. Збій Readiness Probe лише тимчасово виключить под з сервісу, не направляючи на нього трафік."
  }
},
{
  "model": "interview_app.option",
  "pk": 1374,
  "fields": {
    "question": 458,
    "key": "c",
    "text": "При збої будь-якого з них, оскільки обидва вказують на критичну проблему."
  }
},
{
  "model": "interview_app.option",
  "pk": 1375,
  "fields": {
    "question": 459,
    "key": "a",
    "text": "Це налаштування, які використовуються лише для моніторингу, і не впливають на поведінку контейнера."
  }
},
{
  "model": "interview_app.option",
  "pk": 1376,
  "fields": {
    "question": 459,
    "key": "b",
    "text": "`requests` — це гарантована кількість ресурсів, яку отримає контейнер. `limits` — це максимальна кількість, яку йому дозволено використовувати. Якщо контейнер перевищить `limit` по пам'яті, його буде знищено (OOMKilled)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1377,
  "fields": {
    "question": 459,
    "key": "c",
    "text": "`requests` — це максимальна кількість ресурсів, а `limits` — мінімальна."
  }
},
{
  "model": "interview_app.option",
  "pk": 1378,
  "fields": {
    "question": 460,
    "key": "a",
    "text": "`Secret` завжди шифрується на рівні etcd, а `ConfigMap` — ніколи."
  }
},
{
  "model": "interview_app.option",
  "pk": 1379,
  "fields": {
    "question": 460,
    "key": "b",
    "text": "Обидва зберігають конфігураційні дані, але `Secret` призначений для чутливих даних (паролі, токени) і за замовчуванням зберігається в закодованому (base64) вигляді, а також має додаткові механізми захисту."
  }
},
{
  "model": "interview_app.option",
  "pk": 1380,
  "fields": {
    "question": 460,
    "key": "c",
    "text": "`ConfigMap` може зберігати лише рядкові дані, а `Secret` — бінарні."
  }
},
{
  "model": "interview_app.option",
  "pk": 1381,
  "fields": {
    "question": 461,
    "key": "a",
    "text": "Це менеджер пакетів, який дозволяє керувати складними Kubernetes-додатками за допомогою шаблонів, що називаються 'чартами' (charts), спрощуючи їх встановлення, оновлення та видалення."
  }
},
{
  "model": "interview_app.option",
  "pk": 1382,
  "fields": {
    "question": 461,
    "key": "b",
    "text": "Це інструмент для візуалізації архітектури кластера Kubernetes."
  }
},
{
  "model": "interview_app.option",
  "pk": 1383,
  "fields": {
    "question": 461,
    "key": "c",
    "text": "Це система моніторингу, спеціально розроблена для Kubernetes."
  }
},
{
  "model": "interview_app.option",
  "pk": 1384,
  "fields": {
    "question": 462,
    "key": "a",
    "text": "Це політика, що визначає, які сервіси можуть спілкуватися між собою."
  }
},
{
  "model": "interview_app.option",
  "pk": 1385,
  "fields": {
    "question": 462,
    "key": "b",
    "text": "Це абстракція, що надає стабільну IP-адресу та DNS-ім'я для групи подів. Основні типи: `ClusterIP` (внутрішній), `NodePort` (зовнішній через порт на вузлі), `LoadBalancer` (зовнішній через хмарний балансувальник)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1386,
  "fields": {
    "question": 462,
    "key": "c",
    "text": "Це один конкретний мікросервіс, запущений у кластері."
  }
},
{
  "model": "interview_app.option",
  "pk": 1387,
  "fields": {
    "question": 463,
    "key": "a",
    "text": "WSGI працює лише з Apache, а ASGI — з Nginx."
  }
},
{
  "model": "interview_app.option",
  "pk": 1388,
  "fields": {
    "question": 463,
    "key": "b",
    "text": "WSGI — це синхронний інтерфейс для традиційних Python веб-фреймворків. ASGI — це асинхронний інтерфейс, розроблений для підтримки довготривалих з'єднань (WebSockets) та асинхронних фреймворків (FastAPI, Django 3+)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1389,
  "fields": {
    "question": 463,
    "key": "c",
    "text": "ASGI є старішою версією WSGI, яку більше не використовують."
  }
},
{
  "model": "interview_app.option",
  "pk": 1390,
  "fields": {
    "question": 464,
    "key": "a",
    "text": "Вони працюють паралельно і не взаємодіють один з одним."
  }
},
{
  "model": "interview_app.option",
  "pk": 1391,
  "fields": {
    "question": 464,
    "key": "b",
    "text": "Gunicorn виступає як reverse proxy для Nginx."
  }
},
{
  "model": "interview_app.option",
  "pk": 1392,
  "fields": {
    "question": 464,
    "key": "c",
    "text": "Nginx виступає як 'reverse proxy', приймаючи вхідні HTTP-запити, віддаючи статичні файли та перенаправляючи динамічні запити до Gunicorn через Unix-сокет або локальний TCP-порт."
  }
},
{
  "model": "interview_app.option",
  "pk": 1393,
  "fields": {
    "question": 465,
    "key": "a",
    "text": "Це властивість операції, при якій повторне її виконання на тій самій системі не призводить до змін, якщо система вже знаходиться в бажаному стані. Це робить плейбуки безпечними для повторного запуску."
  }
},
{
  "model": "interview_app.option",
  "pk": 1394,
  "fields": {
    "question": 465,
    "key": "b",
    "text": "Це здатність Ansible працювати з різними операційними системами."
  }
},
{
  "model": "interview_app.option",
  "pk": 1395,
  "fields": {
    "question": 465,
    "key": "c",
    "text": "Це техніка, яка гарантує, що кожна команда в плейбуку виконується лише один раз."
  }
},
{
  "model": "interview_app.option",
  "pk": 1396,
  "fields": {
    "question": 466,
    "key": "a",
    "text": "Це плагін, який відповідає за взаємодію з API конкретного сервісу (напр., AWS, GCP, Cloudflare) і керування його ресурсами."
  }
},
{
  "model": "interview_app.option",
  "pk": 1397,
  "fields": {
    "question": 466,
    "key": "b",
    "text": "Це компанія, яка надає послуги хостингу для Terraform."
  }
},
{
  "model": "interview_app.option",
  "pk": 1398,
  "fields": {
    "question": 466,
    "key": "c",
    "text": "Це змінна в Terraform, яка вказує, в якій хмарі розгортати інфраструктуру."
  }
},
{
  "model": "interview_app.option",
  "pk": 1399,
  "fields": {
    "question": 467,
    "key": "a",
    "text": "Тому що access keys працюють повільніше через необхідність їх перевірки при кожному запиті."
  }
},
{
  "model": "interview_app.option",
  "pk": 1400,
  "fields": {
    "question": 467,
    "key": "b",
    "text": "Тому що ролі надають більше прав доступу, ніж access keys."
  }
},
{
  "model": "interview_app.option",
  "pk": 1401,
  "fields": {
    "question": 467,
    "key": "c",
    "text": "Тому що ролі надають тимчасові, автоматично ротовані облікові дані додатку, не вимагаючи зберігання довготривалих секретних ключів на диску, які можуть бути скомпрометовані."
  }
},
{
  "model": "interview_app.option",
  "pk": 1402,
  "fields": {
    "question": 468,
    "key": "a",
    "text": "Це помилка, коли функція не може запуститися через низьку температуру в дата-центрі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1403,
  "fields": {
    "question": 468,
    "key": "b",
    "text": "Це стан, коли функція запускається, але не отримує вхідних даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1404,
  "fields": {
    "question": 468,
    "key": "c",
    "text": "Це затримка, що виникає при першому виклику функції після періоду бездіяльності, коли платформі потрібно створити нове середовище виконання, завантажити код та ініціалізувати його."
  }
},
{
  "model": "interview_app.option",
  "pk": 1405,
  "fields": {
    "question": 469,
    "key": "a",
    "text": "Це скрипт, який запускає весь пайплайн."
  }
},
{
  "model": "interview_app.option",
  "pk": 1406,
  "fields": {
    "question": 469,
    "key": "b",
    "text": "Це розробник, відповідальний за підтримку CI/CD системи."
  }
},
{
  "model": "interview_app.option",
  "pk": 1407,
  "fields": {
    "question": 469,
    "key": "c",
    "text": "Це машина (фізична або віртуальна), на якій виконуються завдання (jobs) з CI/CD пайплайну (напр., компіляція коду, запуск тестів)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1408,
  "fields": {
    "question": 470,
    "key": "a",
    "text": "Конфігурація через UI є більш гнучкою, оскільки дозволяє змінювати пайплайн 'на льоту'."
  }
},
{
  "model": "interview_app.option",
  "pk": 1409,
  "fields": {
    "question": 470,
    "key": "b",
    "text": "'Pipeline as code' (напр., `Jenkinsfile`, `.gitlab-ci.yml`) дозволяє зберігати конфігурацію пайплайну у версійному контролі разом з кодом, що робить її відтворюваною, прозорою та легшою для рев'ю."
  }
},
{
  "model": "interview_app.option",
  "pk": 1410,
  "fields": {
    "question": 470,
    "key": "c",
    "text": "Різниці немає, UI просто генерує той самий код у фоновому режимі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1411,
  "fields": {
    "question": 471,
    "key": "a",
    "text": "Це застарілий код, який слід видалити з проекту."
  }
},
{
  "model": "interview_app.option",
  "pk": 1412,
  "fields": {
    "question": 471,
    "key": "b",
    "text": "Це помилка, яка виникає під час виконання пайплайну."
  }
},
{
  "model": "interview_app.option",
  "pk": 1413,
  "fields": {
    "question": 471,
    "key": "c",
    "text": "Це файл або набір файлів (напр., скомпільований бінарний файл, звіт про покриття тестами, Docker-образ), які створюються під час виконання завдання (job) і можуть бути збережені та передані на наступні етапи."
  }
},
{
  "model": "interview_app.option",
  "pk": 1414,
  "fields": {
    "question": 472,
    "key": "a",
    "text": "Це техніка, при якій існують два ідентичні продакшен-середовища ('blue' і 'green'). Нова версія розгортається в неактивне середовище, а потім трафік миттєво переключається на нього. Це дозволяє швидко відкотитися назад."
  }
},
{
  "model": "interview_app.option",
  "pk": 1415,
  "fields": {
    "question": 472,
    "key": "b",
    "text": "Це розгортання, яке поступово змінює колір інтерфейсу сайту з синього на зелений."
  }
},
{
  "model": "interview_app.option",
  "pk": 1416,
  "fields": {
    "question": 472,
    "key": "c",
    "text": "Це стратегія, при якій оновлюється лише половина серверів, а інша половина залишається на старій версії."
  }
},
{
  "model": "interview_app.option",
  "pk": 1417,
  "fields": {
    "question": 473,
    "key": "a",
    "text": "Це ендпоінт, який перевіряє здоров'я користувача, що зробив запит."
  }
},
{
  "model": "interview_app.option",
  "pk": 1418,
  "fields": {
    "question": 473,
    "key": "b",
    "text": "Це сторінка, на якій відображається детальна статистика про стан сервера."
  }
},
{
  "model": "interview_app.option",
  "pk": 1419,
  "fields": {
    "question": 473,
    "key": "c",
    "text": "Це спеціальний URL (напр., `/healthz`), який повертає статус працездатності додатку. Він використовується системами оркестрації (Kubernetes) та балансувальниками навантаження для визначення, чи готовий сервіс приймати трафік."
  }
},
{
  "model": "interview_app.option",
  "pk": 1420,
  "fields": {
    "question": 474,
    "key": "a",
    "text": "Це синоніми, які виконують однакову дію."
  }
},
{
  "model": "interview_app.option",
  "pk": 1421,
  "fields": {
    "question": 474,
    "key": "b",
    "text": "`run` запускає сервіси, а `up` — зупиняє їх."
  }
},
{
  "model": "interview_app.option",
  "pk": 1422,
  "fields": {
    "question": 474,
    "key": "c",
    "text": "`up` запускає всі сервіси, визначені в `docker-compose.yml`, у фоновому режимі. `run` запускає один екземпляр конкретного сервісу для виконання одноразової команди (напр., міграції бази даних)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1423,
  "fields": {
    "question": 475,
    "key": "a",
    "text": "Це віртуальна мережа, яка створюється поверх фізичної мережі і дозволяє контейнерам, запущеним на різних хостах, спілкуватися один з одним так, ніби вони знаходяться в одній мережі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1424,
  "fields": {
    "question": 475,
    "key": "b",
    "text": "Це мережа, яка накладається на існуючу і блокує весь трафік."
  }
},
{
  "model": "interview_app.option",
  "pk": 1425,
  "fields": {
    "question": 475,
    "key": "c",
    "text": "Це мережа, призначена виключно для керуючого трафіку між вузлами кластера."
  }
},
{
  "model": "interview_app.option",
  "pk": 1426,
  "fields": {
    "question": 476,
    "key": "a",
    "text": "Це помилка, яка виникає при невдалому встановленні SSL-з'єднання."
  }
},
{
  "model": "interview_app.option",
  "pk": 1427,
  "fields": {
    "question": 476,
    "key": "b",
    "text": "Це процес, при якому TLS/SSL з'єднання розшифровується на проксі-сервері або балансувальнику навантаження, а трафік до внутрішніх серверів (backend) іде вже нешифрованим. Це зменшує навантаження на сервери додатків."
  }
},
{
  "model": "interview_app.option",
  "pk": 1428,
  "fields": {
    "question": 476,
    "key": "c",
    "text": "Це процес продовження терміну дії SSL-сертифіката."
  }
},
{
  "model": "interview_app.option",
  "pk": 1429,
  "fields": {
    "question": 477,
    "key": "a",
    "text": "Це контейнер, який запускається і повинен успішно завершитися перед запуском основного контейнера в поді. Використовується для виконання підготовчих завдань, наприклад, очікування на базу даних або завантаження конфігурації."
  }
},
{
  "model": "interview_app.option",
  "pk": 1430,
  "fields": {
    "question": 477,
    "key": "b",
    "text": "Це перший контейнер, який запускається на вузлі при його старті."
  }
},
{
  "model": "interview_app.option",
  "pk": 1431,
  "fields": {
    "question": 477,
    "key": "c",
    "text": "Це контейнер, який ініціалізує весь кластер Kubernetes."
  }
},
{
  "model": "interview_app.option",
  "pk": 1432,
  "fields": {
    "question": 478,
    "key": "a",
    "text": "Це скрипт або сервіс, який збирає метрики з системи, що не підтримує формат Prometheus нативно (напр., база даних, ОС), і надає їх через HTTP-ендпоінт у форматі, зрозумілому для Prometheus."
  }
},
{
  "model": "interview_app.option",
  "pk": 1433,
  "fields": {
    "question": 478,
    "key": "b",
    "text": "Це функція в Prometheus для експорту зібраних даних у файл."
  }
},
{
  "model": "interview_app.option",
  "pk": 1434,
  "fields": {
    "question": 478,
    "key": "c",
    "text": "Це плагін для Grafana, який дозволяє показувати дані з Prometheus."
  }
},
{
  "model": "interview_app.option",
  "pk": 1435,
  "fields": {
    "question": 479,
    "key": "a",
    "text": "В Pull-моделі система моніторингу сама періодично запитує ('тягне') метрики з сервісів. В Push-моделі сервіси самі активно відправляють ('штовхають') свої метрики в систему моніторингу."
  }
},
{
  "model": "interview_app.option",
  "pk": 1436,
  "fields": {
    "question": 479,
    "key": "b",
    "text": "Pull-модель використовується для логів, а Push — для метрик."
  }
},
{
  "model": "interview_app.option",
  "pk": 1437,
  "fields": {
    "question": 479,
    "key": "c",
    "text": "Push-модель є більш надійною, оскільки не залежить від доступності системи моніторингу."
  }
},
{
  "model": "interview_app.option",
  "pk": 1438,
  "fields": {
    "question": 480,
    "key": "a",
    "text": "Це процес відстеження повного шляху запиту, який проходить через кілька сервісів. Кожному запиту присвоюється унікальний ID, що дозволяє візуалізувати затримки на кожному етапі та швидко знаходити проблеми."
  }
},
{
  "model": "interview_app.option",
  "pk": 1439,
  "fields": {
    "question": 480,
    "key": "b",
    "text": "Це логування всіх мережевих пакетів, які проходять між сервісами."
  }
},
{
  "model": "interview_app.option",
  "pk": 1440,
  "fields": {
    "question": 480,
    "key": "c",
    "text": "Це трасування викликів функцій всередині одного сервісу."
  }
},
{
  "model": "interview_app.option",
  "pk": 1441,
  "fields": {
    "question": 481,
    "key": "a",
    "text": "Це команда Git для візуалізації потоку даних між гілками."
  }
},
{
  "model": "interview_app.option",
  "pk": 1442,
  "fields": {
    "question": 481,
    "key": "b",
    "text": "Це плагін для CI/CD систем, який автоматизує роботу з Git."
  }
},
{
  "model": "interview_app.option",
  "pk": 1443,
  "fields": {
    "question": 481,
    "key": "c",
    "text": "Це модель ветвлення в Git, яка пропонує використовувати довготривалі гілки `master` і `develop`, а також короткотривалі гілки для фіч (`feature`), релізів (`release`) та термінових виправлень (`hotfix`)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1444,
  "fields": {
    "question": 482,
    "key": "a",
    "text": "Це версіонування, яке використовує слова замість цифр."
  }
},
{
  "model": "interview_app.option",
  "pk": 1445,
  "fields": {
    "question": 482,
    "key": "b",
    "text": "Це система, яка автоматично присвоює версії коду на основі його семантичного аналізу."
  }
},
{
  "model": "interview_app.option",
  "pk": 1446,
  "fields": {
    "question": 482,
    "key": "c",
    "text": "Це стандарт версіонування у форматі MAJOR.MINOR.PATCH, де MAJOR змінюється при несумісних змінах API, MINOR — при додаванні функціоналу зі зворотною сумісністю, PATCH — при виправленні помилок."
  }
},
{
  "model": "interview_app.option",
  "pk": 1447,
  "fields": {
    "question": 483,
    "key": "a",
    "text": "`setup.py` використовується для старих проектів, а `requirements.txt` — для нових."
  }
},
{
  "model": "interview_app.option",
  "pk": 1448,
  "fields": {
    "question": 483,
    "key": "b",
    "text": "`requirements.txt` зазвичай фіксує точні версії залежностей для конкретного середовища (для відтворюваності). `setup.py`/`pyproject.toml` визначає абстрактні залежності бібліотеки, яку ви розповсюджуєте."
  }
},
{
  "model": "interview_app.option",
  "pk": 1449,
  "fields": {
    "question": 483,
    "key": "c",
    "text": "Різниці немає, вони виконують однакову функцію."
  }
},
{
  "model": "interview_app.option",
  "pk": 1450,
  "fields": {
    "question": 484,
    "key": "a",
    "text": "Це ізольоване середовище, яке дозволяє встановлювати залежності для конкретного проекту, не конфліктуючи з глобальними пакетами або залежностями інших проектів."
  }
},
{
  "model": "interview_app.option",
  "pk": 1451,
  "fields": {
    "question": 484,
    "key": "b",
    "text": "Це віртуальна машина, на якій запускається Python."
  }
},
{
  "model": "interview_app.option",
  "pk": 1452,
  "fields": {
    "question": 484,
    "key": "c",
    "text": "Це спосіб запускати кілька версій Python одночасно."
  }
},
{
  "model": "interview_app.option",
  "pk": 1453,
  "fields": {
    "question": 485,
    "key": "a",
    "text": "Це набір правил, що стандартизує взаємодію між клієнтом і сервером, включаючи ідентифікацію ресурсів через URI, маніпуляцію через HTTP-методи та самоописові повідомлення."
  }
},
{
  "model": "interview_app.option",
  "pk": 1454,
  "fields": {
    "question": 485,
    "key": "b",
    "text": "Це означає, що інтерфейс користувача (UI) повинен бути однаковим для всіх клієнтів, що взаємодіють з API."
  }
},
{
  "model": "interview_app.option",
  "pk": 1455,
  "fields": {
    "question": 485,
    "key": "c",
    "text": "Це вимога, щоб усі відповіді сервера були в однаковому форматі, наприклад, виключно JSON."
  }
},
{
  "model": "interview_app.option",
  "pk": 1456,
  "fields": {
    "question": 486,
    "key": "a",
    "text": "Це техніка для керування станом додатку на стороні клієнта за допомогою HTML5."
  }
},
{
  "model": "interview_app.option",
  "pk": 1457,
  "fields": {
    "question": 486,
    "key": "b",
    "text": "Це система, яка автоматично генерує документацію для REST API."
  }
},
{
  "model": "interview_app.option",
  "pk": 1458,
  "fields": {
    "question": 486,
    "key": "c",
    "text": "Це принцип, згідно з яким відповідь сервера повинна містити посилання (hypermedia), які дозволяють клієнту динамічно відкривати нові дії та ресурси, не маючи заздалегідь закодованих URI."
  }
},
{
  "model": "interview_app.option",
  "pk": 1459,
  "fields": {
    "question": 487,
    "key": "a",
    "text": "`PATCH` є більш безпечним, оскільки завжди виконується в межах транзакції, на відміну від `PUT`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1460,
  "fields": {
    "question": 487,
    "key": "b",
    "text": "`PUT` повністю замінює ресурс, вимагаючи від клієнта надсилати весь об'єкт. `PATCH` застосовує часткові зміни до ресурсу, надсилаючи лише інструкції щодо змін."
  }
},
{
  "model": "interview_app.option",
  "pk": 1461,
  "fields": {
    "question": 487,
    "key": "c",
    "text": "`PUT` є ідемпотентним, а `PATCH` — ні."
  }
},
{
  "model": "interview_app.option",
  "pk": 1462,
  "fields": {
    "question": 488,
    "key": "a",
    "text": "Це властивість методу, при якій повторне його виконання з тими ж параметрами призводить до того ж стану ресурсу, що й перше. Ідемпотентними є `GET`, `HEAD`, `OPTIONS`, `PUT`, `DELETE`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1463,
  "fields": {
    "question": 488,
    "key": "b",
    "text": "Це властивість, яка гарантує, що метод завжди поверне однаковий результат. Всі методи, крім `POST`, є ідемпотентними."
  }
},
{
  "model": "interview_app.option",
  "pk": 1464,
  "fields": {
    "question": 488,
    "key": "c",
    "text": "Це означає, що метод не змінює стан сервера. Ідемпотентними є `GET`, `HEAD`, `OPTIONS`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1465,
  "fields": {
    "question": 489,
    "key": "a",
    "text": "Це метод, який не змінює стан ресурсу на сервері. Його можна викликати без побоювання побічних ефектів. До них належать `GET`, `HEAD`, `OPTIONS`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1466,
  "fields": {
    "question": 489,
    "key": "b",
    "text": "Це метод, який використовує HTTPS для шифрування даних."
  }
},
{
  "model": "interview_app.option",
  "pk": 1467,
  "fields": {
    "question": 489,
    "key": "c",
    "text": "Це будь-який метод, який не повертає помилку 5xx."
  }
},
{
  "model": "interview_app.option",
  "pk": 1468,
  "fields": {
    "question": 490,
    "key": "a",
    "text": "Для встановлення конфігураційних опцій для майбутніх запитів до сервера."
  }
},
{
  "model": "interview_app.option",
  "pk": 1469,
  "fields": {
    "question": 490,
    "key": "b",
    "text": "Для отримання інформації про доступні опції комунікації для цільового ресурсу, наприклад, список підтримуваних методів (у заголовку `Allow`). Також використовується для CORS preflight-запитів."
  }
},
{
  "model": "interview_app.option",
  "pk": 1470,
  "fields": {
    "question": 490,
    "key": "c",
    "text": "Це необов'язковий метод, який є синонімом до `GET`, але без тіла відповіді."
  }
},
{
  "model": "interview_app.option",
  "pk": 1471,
  "fields": {
    "question": 491,
    "key": "a",
    "text": "Він містить директиви для кешування як у запитах, так і у відповідях. Наприклад, `max-age` вказує, скільки часу об'єкт можна вважати свіжим, а `no-cache` вимагає валідації з сервером."
  }
},
{
  "model": "interview_app.option",
  "pk": 1472,
  "fields": {
    "question": 491,
    "key": "b",
    "text": "Це заголовок, який повністю вимикає кешування для всього сайту."
  }
},
{
  "model": "interview_app.option",
  "pk": 1473,
  "fields": {
    "question": 491,
    "key": "c",
    "text": "Він використовується сервером, щоб вказати, які дані клієнт повинен кешувати."
  }
},
{
  "model": "interview_app.option",
  "pk": 1474,
  "fields": {
    "question": 492,
    "key": "a",
    "text": "`ETag` — це зашифрована версія тіла відповіді, яку клієнт може розшифрувати локально."
  }
},
{
  "model": "interview_app.option",
  "pk": 1475,
  "fields": {
    "question": 492,
    "key": "b",
    "text": "Сервер надсилає унікальний ідентифікатор версії ресурсу (`ETag`). Клієнт при повторному запиті надсилає цей ідентифікатор у заголовку `If-None-Match`. Якщо ресурс не змінився, сервер відповідає `304 Not Modified` без тіла."
  }
},
{
  "model": "interview_app.option",
  "pk": 1476,
  "fields": {
    "question": 492,
    "key": "c",
    "text": "Клієнт надсилає `ETag`, і якщо він збігається, сервер надсилає повну відповідь з кешу."
  }
},
{
  "model": "interview_app.option",
  "pk": 1477,
  "fields": {
    "question": 493,
    "key": "a",
    "text": "Це запит, який клієнт надсилає для 'прогріву' з'єднання з сервером."
  }
},
{
  "model": "interview_app.option",
  "pk": 1478,
  "fields": {
    "question": 493,
    "key": "b",
    "text": "Це запит з методом `OPTIONS`, який браузер автоматично надсилає перед 'складними' крос-доменними запитами (напр., з нестандартними заголовками або методом `PUT`/`DELETE`), щоб перевірити, чи дозволяє сервер такий запит."
  }
},
{
  "model": "interview_app.option",
  "pk": 1479,
  "fields": {
    "question": 493,
    "key": "c",
    "text": "Це перевірка, чи доступний сервер, перед відправкою основного запиту."
  }
},
{
  "model": "interview_app.option",
  "pk": 1480,
  "fields": {
    "question": 494,
    "key": "a",
    "text": "`302` є більш сучасним і швидким, ніж `301`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1481,
  "fields": {
    "question": 494,
    "key": "b",
    "text": "`301` дозволяє змінювати метод запиту (напр., з `POST` на `GET`), а `302` — ні."
  }
},
{
  "model": "interview_app.option",
  "pk": 1482,
  "fields": {
    "question": 494,
    "key": "c",
    "text": "`301` вказує, що ресурс назавжди переміщено на новий URL, і клієнтам/пошуковим системам слід оновити свої посилання. `302` вказує на тимчасове перенаправлення."
  }
},
{
  "model": "interview_app.option",
  "pk": 1483,
  "fields": {
    "question": 495,
    "key": "a",
    "text": "Це стандарт, який описує, які саме шифри слід використовувати в HTTPS."
  }
},
{
  "model": "interview_app.option",
  "pk": 1484,
  "fields": {
    "question": 495,
    "key": "b",
    "text": "Це механізм безпеки, при якому сервер повідомляє браузеру (через заголовок `Strict-Transport-Security`), що взаємодіяти з ним слід лише по HTTPS. Це запобігає атакам SSL stripping."
  }
},
{
  "model": "interview_app.option",
  "pk": 1485,
  "fields": {
    "question": 495,
    "key": "c",
    "text": "Це вимога, щоб усі дані в тілі запиту були зашифровані."
  }
},
{
  "model": "interview_app.option",
  "pk": 1486,
  "fields": {
    "question": 496,
    "key": "a",
    "text": "Це процес, який відбувається лише один раз при першому відвідуванні сайту."
  }
},
{
  "model": "interview_app.option",
  "pk": 1487,
  "fields": {
    "question": 496,
    "key": "b",
    "text": "Це процес, під час якого клієнт і сервер домовляються про версію протоколу та шифри, сервер автентифікує себе за допомогою сертифіката, і вони генерують спільний сесійний ключ для шифрування подальшого трафіку."
  }
},
{
  "model": "interview_app.option",
  "pk": 1488,
  "fields": {
    "question": 496,
    "key": "c",
    "text": "Це обмін HTTP-заголовками для встановлення з'єднання."
  }
},
{
  "model": "interview_app.option",
  "pk": 1489,
  "fields": {
    "question": 497,
    "key": "a",
    "text": "Це спосіб автентифікації сервера за його іменем, а не за сертифікатом."
  }
},
{
  "model": "interview_app.option",
  "pk": 1490,
  "fields": {
    "question": 497,
    "key": "b",
    "text": "Це механізм, який вказує на фізичне розташування сервера."
  }
},
{
  "model": "interview_app.option",
  "pk": 1491,
  "fields": {
    "question": 497,
    "key": "c",
    "text": "Це розширення TLS, яке дозволяє клієнту вказувати ім'я хоста, до якого він намагається підключитися, на початку хендшейку. Це дозволяє серверу надавати правильний сертифікат, якщо на одній IP-адресі розміщено кілька HTTPS-сайтів."
  }
},
{
  "model": "interview_app.option",
  "pk": 1492,
  "fields": {
    "question": 498,
    "key": "a",
    "text": "Це гарантія, що повідомлення будуть доставлені в майбутньому, навіть якщо з'єднання тимчасово перерветься."
  }
},
{
  "model": "interview_app.option",
  "pk": 1493,
  "fields": {
    "question": 498,
    "key": "b",
    "text": "Це техніка, яка дозволяє шифрувати дані без обміну ключами."
  }
},
{
  "model": "interview_app.option",
  "pk": 1494,
  "fields": {
    "question": 498,
    "key": "c",
    "text": "Це властивість протоколів обміну ключами, яка гарантує, що компрометація довготривалого приватного ключа сервера не дозволить розшифрувати минулі сесії. Це досягається шляхом створення унікального сесійного ключа для кожної сесії."
  }
},
{
  "model": "interview_app.option",
  "pk": 1495,
  "fields": {
    "question": 499,
    "key": "a",
    "text": "Для визначення, які HTTP-методи дозволені для певного URL."
  }
},
{
  "model": "interview_app.option",
  "pk": 1496,
  "fields": {
    "question": 499,
    "key": "b",
    "text": "Для визначення довірених джерел, з яких браузеру дозволено завантажувати ресурси (скрипти, стилі, зображення), що є ефективним засобом захисту від XSS-атак."
  }
},
{
  "model": "interview_app.option",
  "pk": 1497,
  "fields": {
    "question": 499,
    "key": "c",
    "text": "Для вказівки політики кешування для контенту."
  }
},
{
  "model": "interview_app.option",
  "pk": 1498,
  "fields": {
    "question": 500,
    "key": "a",
    "text": "Куки надсилаються з кожним HTTP-запитом до сервера, мають обмеження за розміром (~4KB) і термін дії. `localStorage` зберігає дані лише в браузері, має більший розмір (~5MB) і не має терміну дії."
  }
},
{
  "model": "interview_app.option",
  "pk": 1499,
  "fields": {
    "question": 500,
    "key": "b",
    "text": "Куки можуть зберігати лише рядки, а `localStorage` — будь-які об'єкти JavaScript."
  }
},
{
  "model": "interview_app.option",
  "pk": 1500,
  "fields": {
    "question": 500,
    "key": "c",
    "text": "`localStorage` є більш безпечним, оскільки дані шифруються, на відміну від кук."
  }
},
{
  "model": "interview_app.option",
  "pk": 1501,
  "fields": {
    "question": 501,
    "key": "a",
    "text": "Це техніка для зменшення розміру відповідей API."
  }
},
{
  "model": "interview_app.option",
  "pk": 1502,
  "fields": {
    "question": 501,
    "key": "b",
    "text": "Це процес вимірювання швидкості відповіді API."
  }
},
{
  "model": "interview_app.option",
  "pk": 1503,
  "fields": {
    "question": 501,
    "key": "c",
    "text": "Це обмеження кількості запитів, які клієнт може зробити до API за певний проміжок часу. Це важливо для захисту сервісу від зловживань (DDoS), забезпечення справедливого використання ресурсів та стабільності."
  }
},
{
  "model": "interview_app.option",
  "pk": 1504,
  "fields": {
    "question": 502,
    "key": "a",
    "text": "Це синонім для `200 OK`, але з меншим пріоритетом."
  }
},
{
  "model": "interview_app.option",
  "pk": 1505,
  "fields": {
    "question": 502,
    "key": "b",
    "text": "Коли запит був прийнятий для обробки, але сама обробка ще не завершена (наприклад, для запуску довготривалої асинхронної задачі). Відповідь може містити посилання для перевірки статусу."
  }
},
{
  "model": "interview_app.option",
  "pk": 1506,
  "fields": {
    "question": 502,
    "key": "c",
    "text": "Коли ресурс був успішно створений, але його URL ще невідомий."
  }
},
{
  "model": "interview_app.option",
  "pk": 1507,
  "fields": {
    "question": 503,
    "key": "a",
    "text": "Це бібліотека для виправлення помилок у невалідних JSON-документах."
  }
},
{
  "model": "interview_app.option",
  "pk": 1508,
  "fields": {
    "question": 503,
    "key": "b",
    "text": "Це стандарт, що визначає формат для опису послідовності операцій (`add`, `remove`, `replace`) для часткового оновлення JSON-документа. Часто використовується в тілі запитів `PATCH`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1509,
  "fields": {
    "question": 503,
    "key": "c",
    "text": "Це процес стиснення JSON-документів для передачі по мережі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1510,
  "fields": {
    "question": 504,
    "key": "a",
    "text": "Це послідовність сертифікатів, починаючи від сертифіката сервера і закінчуючи кореневим сертифікатом (Root CA), де кожен сертифікат у ланцюжку підписаний наступним. Це дозволяє клієнту перевірити довіру до сертифіката сервера."
  }
},
{
  "model": "interview_app.option",
  "pk": 1511,
  "fields": {
    "question": 504,
    "key": "b",
    "text": "Це ланцюжок серверів, через які проходить зашифрований трафік."
  }
},
{
  "model": "interview_app.option",
  "pk": 1512,
  "fields": {
    "question": 504,
    "key": "c",
    "text": "Це список відкликаних сертифікатів."
  }
},
{
  "model": "interview_app.option",
  "pk": 1513,
  "fields": {
    "question": 505,
    "key": "a",
    "text": "`public` — для публічних API, `private` — для внутрішніх."
  }
},
{
  "model": "interview_app.option",
  "pk": 1514,
  "fields": {
    "question": 505,
    "key": "b",
    "text": "`public` означає, що відповідь може бути кешована будь-яким кешем (напр., проксі-сервером). `private` означає, що вона призначена лише для кінцевого клієнта і не повинна кешуватися спільними кешами."
  }
},
{
  "model": "interview_app.option",
  "pk": 1515,
  "fields": {
    "question": 505,
    "key": "c",
    "text": "`private` означає, що кеш повинен бути зашифрований."
  }
},
{
  "model": "interview_app.option",
  "pk": 1516,
  "fields": {
    "question": 506,
    "key": "a",
    "text": "Щоб вказати, які мови програмування підтримує клієнт."
  }
},
{
  "model": "interview_app.option",
  "pk": 1517,
  "fields": {
    "question": 506,
    "key": "b",
    "text": "Щоб підтвердити, що клієнт прийняв умови використання сервісу."
  }
},
{
  "model": "interview_app.option",
  "pk": 1518,
  "fields": {
    "question": 506,
    "key": "c",
    "text": "Щоб повідомити серверу, які типи контенту (MIME-типи, напр., `application/json`, `application/xml`) клієнт може зрозуміти та обробити."
  }
},
{
  "model": "interview_app.option",
  "pk": 1519,
  "fields": {
    "question": 507,
    "key": "a",
    "text": "Це техніка, при якій клієнт утримує та повторно використовує TCP-з'єднання до одного й того ж хоста для кількох HTTP-запитів, що усуває накладні витрати на встановлення нового з'єднання (TCP та TLS handshake) для кожного запиту."
  }
},
{
  "model": "interview_app.option",
  "pk": 1520,
  "fields": {
    "question": 507,
    "key": "b",
    "text": "Це об'єднання кількох HTTP-запитів в один великий запит."
  }
},
{
  "model": "interview_app.option",
  "pk": 1521,
  "fields": {
    "question": 507,
    "key": "c",
    "text": "Це черга запитів, які очікують на відправку."
  }
},
{
  "model": "interview_app.option",
  "pk": 1522,
  "fields": {
    "question": 508,
    "key": "a",
    "text": "Це блокування, яке виникає, коли заголовок запиту є занадто великим."
  }
},
{
  "model": "interview_app.option",
  "pk": 1523,
  "fields": {
    "question": 508,
    "key": "b",
    "text": "Це проблема, коли один повільний запит блокує всі наступні запити в межах одного TCP-з'єднання, оскільки відповіді повинні надсилатися в тому ж порядку, що й запити. Цю проблему вирішує мультиплексування в HTTP/2."
  }
},
{
  "model": "interview_app.option",
  "pk": 1524,
  "fields": {
    "question": 508,
    "key": "c",
    "text": "Це ситуація, коли сервер може обробити лише перший запит з черги."
  }
},
{
  "model": "interview_app.option",
  "pk": 1525,
  "fields": {
    "question": 509,
    "key": "a",
    "text": "Всі три атрибути використовуються для шифрування значення куки."
  }
},
{
  "model": "interview_app.option",
  "pk": 1526,
  "fields": {
    "question": 509,
    "key": "b",
    "text": "Вони визначають, на яких сайтах (доменах) буде доступна кука."
  }
},
{
  "model": "interview_app.option",
  "pk": 1527,
  "fields": {
    "question": 509,
    "key": "c",
    "text": "`Secure` дозволяє надсилати куку лише по HTTPS. `HttpOnly` забороняє доступ до куки з JavaScript (захист від XSS). `SameSite` контролює, чи надсилається кука при крос-сайтових запитах (захист від CSRF)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1528,
  "fields": {
    "question": 510,
    "key": "a",
    "text": "Вони є взаємозамінними, і вибір залежить від сервера."
  }
},
{
  "model": "interview_app.option",
  "pk": 1529,
  "fields": {
    "question": 510,
    "key": "b",
    "text": "`401` означає, що запит вимагає автентифікації, або вона не вдалася. `403` означає, що клієнт автентифікований, але не має прав доступу до ресурсу."
  }
},
{
  "model": "interview_app.option",
  "pk": 1530,
  "fields": {
    "question": 510,
    "key": "c",
    "text": "`403` є більш серйозною помилкою, ніж `401`."
  }
},
{
  "model": "interview_app.option",
  "pk": 1531,
  "fields": {
    "question": 511,
    "key": "a",
    "text": "Це інструмент для тестування навантаження на API."
  }
},
{
  "model": "interview_app.option",
  "pk": 1532,
  "fields": {
    "question": 511,
    "key": "b",
    "text": "Це стандарт для опису REST API у машиночитаному форматі (YAML або JSON), який дозволяє автоматично генерувати документацію, клієнтські SDK та серверні заглушки."
  }
},
{
  "model": "interview_app.option",
  "pk": 1533,
  "fields": {
    "question": 511,
    "key": "c",
    "text": "Це протокол, який є альтернативою REST."
  }
},
{
  "model": "interview_app.option",
  "pk": 1534,
  "fields": {
    "question": 512,
    "key": "a",
    "text": "Це проблема, коли два клієнти читають один і той же ресурс, а потім намагаються його оновити. Оновлення від другого клієнта може перезаписати оновлення першого. Вирішується за допомогою умовних запитів (з `ETag` та `If-Match`)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1535,
  "fields": {
    "question": 512,
    "key": "b",
    "text": "Це ситуація, коли оновлення застосовується двічі."
  }
},
{
  "model": "interview_app.option",
  "pk": 1536,
  "fields": {
    "question": 512,
    "key": "c",
    "text": "Це помилка, коли оновлення не доходить до сервера через проблеми з мережею."
  }
},
{
  "model": "interview_app.option",
  "pk": 1537,
  "fields": {
    "question": 513,
    "key": "a",
    "text": "Це програмне забезпечення, яке реалізує протокол TLS."
  }
},
{
  "model": "interview_app.option",
  "pk": 1538,
  "fields": {
    "question": 513,
    "key": "b",
    "text": "Це набір сертифікатів, яким довіряє сервер."
  }
},
{
  "model": "interview_app.option",
  "pk": 1539,
  "fields": {
    "question": 513,
    "key": "c",
    "text": "Це набір криптографічних алгоритмів, які використовуються для захисту з'єднання. Він включає алгоритм обміну ключами, алгоритм шифрування та алгоритм перевірки цілісності повідомлень (MAC)."
  }
},
{
  "model": "interview_app.option",
  "pk": 1540,
  "fields": {
    "question": 514,
    "key": "a",
    "text": "Це шлюз, який об'єднує кілька gRPC-сервісів в один."
  }
},
{
  "model": "interview_app.option",
  "pk": 1541,
  "fields": {
    "question": 514,
    "key": "b",
    "text": "Це бібліотека для створення gRPC-клієнтів на мовах, що не підтримують gRPC нативно."
  }
},
{
  "model": "interview_app.option",
  "pk": 1542,
  "fields": {
    "question": 514,
    "key": "c",
    "text": "Це проксі-сервер, який транслює RESTful JSON API в gRPC-запити. Це дозволяє надавати традиційний REST-інтерфейс для мікросервісів, які всередині спілкуються через gRPC."
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 1,
  "fields": {
    "question": 393,
    "user_text_answer": "овтафвафьф",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T08:37:04.602Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 2,
  "fields": {
    "question": 21,
    "user_text_answer": "ьлєлфвім",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T08:38:01.955Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 3,
  "fields": {
    "question": 190,
    "user_text_answer": "афівафвмсччя",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T08:38:12.391Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 4,
  "fields": {
    "question": 92,
    "user_text_answer": "Наслідування це один з 4 прицнипів ООП. Означає що дочірні класи можуть наслідувати поведінку батьківських.",
    "ai_response": "True",
    "is_correct_by_ai": true,
    "created_at": "2025-08-14T08:38:53.149Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 5,
  "fields": {
    "question": 5,
    "user_text_answer": "Набір правил та порад для написання лаконічног та структурованого коду.",
    "ai_response": "True",
    "is_correct_by_ai": true,
    "created_at": "2025-08-14T08:41:06.576Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 6,
  "fields": {
    "question": 424,
    "user_text_answer": "-",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T08:43:22.848Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 7,
  "fields": {
    "question": 346,
    "user_text_answer": "-",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T08:43:44.979Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 8,
  "fields": {
    "question": 72,
    "user_text_answer": "slice[first:step:stop]",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T08:44:16.159Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 9,
  "fields": {
    "question": 77,
    "user_text_answer": "ві",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T09:07:47.434Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 10,
  "fields": {
    "question": 297,
    "user_text_answer": "фа",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T09:08:45.480Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 11,
  "fields": {
    "question": 80,
    "user_text_answer": "афіва",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T09:09:46.512Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 12,
  "fields": {
    "question": 400,
    "user_text_answer": "фв",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T09:09:54.771Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 13,
  "fields": {
    "question": 477,
    "user_text_answer": "ві",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T09:10:02.178Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 14,
  "fields": {
    "question": 386,
    "user_text_answer": "Retrieval-Augmented Generation (RAG) - це метод в штучному інтелекті, який поєднує в собі можливості пошуку інформації з генеративними моделями для створення більш точних, релевантних та інформативних відповідей.",
    "ai_response": "True",
    "is_correct_by_ai": true,
    "created_at": "2025-08-14T09:10:36.687Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 15,
  "fields": {
    "question": 25,
    "user_text_answer": "простота безпека та особливість пайтона",
    "ai_response": "True",
    "is_correct_by_ai": true,
    "created_at": "2025-08-14T09:20:27.238Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 16,
  "fields": {
    "question": 443,
    "user_text_answer": "лдж",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T09:24:02.060Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 17,
  "fields": {
    "question": 396,
    "user_text_answer": "л",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T09:24:15.556Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 18,
  "fields": {
    "question": 345,
    "user_text_answer": "використовується для перехоплення звернень до атрибутів об'єкта. Він викликається кожного разу, коли намагаються отримати доступ до атрибуту об'єкта, незалежно від того, чи існує цей атрибут. Це дозволяє повністю контролювати доступ до атрибутів і змінювати логіку отримання значень.",
    "ai_response": "True",
    "is_correct_by_ai": true,
    "created_at": "2025-08-14T09:27:22.151Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 19,
  "fields": {
    "question": 110,
    "user_text_answer": "True",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T09:28:08.268Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 20,
  "fields": {
    "question": 269,
    "user_text_answer": "дозволяє мати декілька папок з одним репозиторієм",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T09:28:53.222Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 21,
  "fields": {
    "question": 67,
    "user_text_answer": "н",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T09:29:27.499Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 22,
  "fields": {
    "question": 59,
    "user_text_answer": "ч",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T09:30:17.436Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 23,
  "fields": {
    "question": 440,
    "user_text_answer": "в",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T09:31:02.228Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 24,
  "fields": {
    "question": 418,
    "user_text_answer": "це принцип за яким будують cicd кодом а не переванжо інтерфейсом",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T09:32:08.241Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 25,
  "fields": {
    "question": 136,
    "user_text_answer": "ві",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T09:32:19.547Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 26,
  "fields": {
    "question": 473,
    "user_text_answer": "щоб перевіряти стан коду та не допускати якоїсь небажаної поведінки",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T09:32:56.430Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 27,
  "fields": {
    "question": 11,
    "user_text_answer": "я",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T09:33:08.158Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 28,
  "fields": {
    "question": 76,
    "user_text_answer": "я",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T09:33:16.707Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 29,
  "fields": {
    "question": 308,
    "user_text_answer": "в ресті є 4 основних запити post get put delete і ще 3 а в graphql тільки здається виткористовуєтьсяя один пост і його там якось маніпулюють ним",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T09:34:08.577Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 30,
  "fields": {
    "question": 328,
    "user_text_answer": "mro це method resolution order тобто за допомогою нього відомо як саме відбувається наслідування повіедінки в  класах",
    "ai_response": "True",
    "is_correct_by_ai": true,
    "created_at": "2025-08-14T11:41:02.261Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 31,
  "fields": {
    "question": 51,
    "user_text_answer": "аві",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-14T11:41:13.219Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 32,
  "fields": {
    "question": 125,
    "user_text_answer": "не знаю",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-16T07:27:28.170Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 33,
  "fields": {
    "question": 273,
    "user_text_answer": "св",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-16T07:28:00.018Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 34,
  "fields": {
    "question": 281,
    "user_text_answer": "к",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-16T07:28:07.249Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 35,
  "fields": {
    "question": 169,
    "user_text_answer": "к",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-16T07:28:15.231Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 36,
  "fields": {
    "question": 41,
    "user_text_answer": "в",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-16T07:28:21.623Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 37,
  "fields": {
    "question": 255,
    "user_text_answer": "ві",
    "ai_response": "False",
    "is_correct_by_ai": false,
    "created_at": "2025-08-16T07:28:32.342Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 38,
  "fields": {
    "question": 44,
    "user_text_answer": "Обгортки для функції які змінюють її функціонал та можуть змінювати її поведінку.",
    "ai_response": "True",
    "is_correct_by_ai": true,
    "created_at": "2025-08-16T07:29:22.941Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 39,
  "fields": {
    "question": 86,
    "user_text_answer": "mutable тип данних в пайтоні який може містити в собі змінні елементи але не копії",
    "ai_response": "```json\n{\n  \"is_correct\": false,\n  \"complexity\": \"Trainee\"\n}\n```\n",
    "is_correct_by_ai": false,
    "created_at": "2025-08-18T07:27:06.004Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 40,
  "fields": {
    "question": 373,
    "user_text_answer": "Використовуються для створення підписок та оповіщення з певних каналів",
    "ai_response": "```json\n{\n  \"is_correct\": false,\n  \"complexity\": \"Junior\"\n}\n```\n",
    "is_correct_by_ai": false,
    "created_at": "2025-08-18T07:28:55.173Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 41,
  "fields": {
    "question": 150,
    "user_text_answer": "це об'єкт, який представляє собою відкритий файл і дозволяє взаємодіяти з ним.",
    "ai_response": "```json\n{\n  \"is_correct\": false,\n  \"complexity\": \"Junior\"\n}\n```\n",
    "is_correct_by_ai": false,
    "created_at": "2025-08-18T07:30:00.818Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 42,
  "fields": {
    "question": 249,
    "user_text_answer": "Думаю це функція яка вибирає певний обєкт який в подальшому потрібно буде якось оновити",
    "ai_response": "```json\n{\n  \"is_correct\": false,\n  \"complexity\": \"Strong Junior\"\n}\n```\n",
    "is_correct_by_ai": false,
    "created_at": "2025-08-18T07:31:13.557Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 43,
  "fields": {
    "question": 375,
    "user_text_answer": "це спеціальний тип однопольного індексу, який дозволяє автоматично видаляти документи з колекції після закінчення певного часу.",
    "ai_response": "```json\n{\n  \"is_correct\": true,\n  \"complexity\": \"Junior\"\n}\n```\n",
    "is_correct_by_ai": true,
    "created_at": "2025-08-18T07:32:11.707Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 44,
  "fields": {
    "question": 136,
    "user_text_answer": "конструкція для виявлення не бажаної поведінки коду та відловлення цієї поведінки також застосовується try finally else разом з ними",
    "ai_response": "```json\n{\n  \"is_correct\": false,\n  \"complexity\": \"Junior\"\n}\n```\n",
    "is_correct_by_ai": false,
    "created_at": "2025-08-18T07:33:40.768Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 45,
  "fields": {
    "question": 360,
    "user_text_answer": "створює незалежні ітератори з одного, вихідного ітератора. Це схоже на створення",
    "ai_response": "```json\n{\n  \"is_correct\": false,\n  \"complexity\": \"Junior\"\n}\n```\n",
    "is_correct_by_ai": false,
    "created_at": "2025-08-18T07:35:13.135Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 46,
  "fields": {
    "question": 165,
    "user_text_answer": "це бібліотека в пайтоні для стовренння однопотокового асинхронного коду",
    "ai_response": "```json\n{\n  \"is_correct\": false,\n  \"complexity\": \"Junior\"\n}\n```\n",
    "is_correct_by_ai": false,
    "created_at": "2025-08-18T07:36:40.037Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 47,
  "fields": {
    "question": 353,
    "user_text_answer": "?",
    "ai_response": "```json\n{\n  \"is_correct\": false,\n  \"complexity\": \"Strong Junior\"\n}\n```\n",
    "is_correct_by_ai": false,
    "created_at": "2025-08-18T07:37:04.028Z"
  }
},
{
  "model": "interview_app.aievaluationattempt",
  "pk": 48,
  "fields": {
    "question": 186,
    "user_text_answer": "коли різні потоки хочуть отримати доступ до одного ресурсу і не відомо який потік бере данні перший",
    "ai_response": "```json\n{\n  \"is_correct\": false,\n  \"complexity\": \"Junior\"\n}\n```\n",
    "is_correct_by_ai": false,
    "created_at": "2025-08-18T08:01:25.157Z"
  }
}
]
